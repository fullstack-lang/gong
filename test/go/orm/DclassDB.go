// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"github.com/jinzhu/gorm"

	"github.com/fullstack-lang/gong/test/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_Dclass sql.NullBool
var __Dclass_time__dummyDeclaration time.Duration
var dummy_Dclass_sort sort.Float64Slice

// DclassAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model dclassAPI
type DclassAPI struct {
	gorm.Model

	models.Dclass

	// encoding of pointers
	DclassPointersEnconding
}

// DclassPointersEnconding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type DclassPointersEnconding struct {
	// insertion for pointer fields encoding declaration
}

// DclassDB describes a dclass in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model dclassDB
type DclassDB struct {
	gorm.Model

	// insertion for basic fields declaration
	// Declation for basic field dclassDB.Name {{BasicKind}} (to be completed)
	Name_Data sql.NullString

	// encoding of pointers
	DclassPointersEnconding
}

// DclassDBs arrays dclassDBs
// swagger:response dclassDBsResponse
type DclassDBs []DclassDB

// DclassDBResponse provides response
// swagger:response dclassDBResponse
type DclassDBResponse struct {
	DclassDB
}

type BackRepoDclassStruct struct {
	// stores DclassDB according to their gorm ID
	Map_DclassDBID_DclassDB *map[uint]*DclassDB

	// stores DclassDB ID according to Dclass address
	Map_DclassPtr_DclassDBID *map[*models.Dclass]uint

	// stores Dclass according to their gorm ID
	Map_DclassDBID_DclassPtr *map[uint]*models.Dclass

	db *gorm.DB
}

func (backRepoDclass *BackRepoDclassStruct) GetDB() *gorm.DB {
	return backRepoDclass.db
}

// GetDclassDBFromDclassPtr is a handy function to access the back repo instance from the stage instance
func (backRepoDclass *BackRepoDclassStruct) GetDclassDBFromDclassPtr(dclass *models.Dclass) (dclassDB *DclassDB) {
	id := (*backRepoDclass.Map_DclassPtr_DclassDBID)[dclass]
	dclassDB = (*backRepoDclass.Map_DclassDBID_DclassDB)[id]
	return
}

// BackRepoDclass.Init set up the BackRepo of the Dclass
func (backRepoDclass *BackRepoDclassStruct) Init(db *gorm.DB) (Error error) {

	if backRepoDclass.Map_DclassDBID_DclassPtr != nil {
		err := errors.New("In Init, backRepoDclass.Map_DclassDBID_DclassPtr should be nil")
		return err
	}

	if backRepoDclass.Map_DclassDBID_DclassDB != nil {
		err := errors.New("In Init, backRepoDclass.Map_DclassDBID_DclassDB should be nil")
		return err
	}

	if backRepoDclass.Map_DclassPtr_DclassDBID != nil {
		err := errors.New("In Init, backRepoDclass.Map_DclassPtr_DclassDBID should be nil")
		return err
	}

	tmp := make(map[uint]*models.Dclass, 0)
	backRepoDclass.Map_DclassDBID_DclassPtr = &tmp

	tmpDB := make(map[uint]*DclassDB, 0)
	backRepoDclass.Map_DclassDBID_DclassDB = &tmpDB

	tmpID := make(map[*models.Dclass]uint, 0)
	backRepoDclass.Map_DclassPtr_DclassDBID = &tmpID

	backRepoDclass.db = db
	return
}

// BackRepoDclass.CommitPhaseOne commits all staged instances of Dclass to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoDclass *BackRepoDclassStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for dclass := range stage.Dclasss {
		backRepoDclass.CommitPhaseOneInstance(dclass)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, dclass := range *backRepoDclass.Map_DclassDBID_DclassPtr {
		if _, ok := stage.Dclasss[dclass]; !ok {
			backRepoDclass.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoDclass.CommitDeleteInstance commits deletion of Dclass to the BackRepo
func (backRepoDclass *BackRepoDclassStruct) CommitDeleteInstance(id uint) (Error error) {

	dclass := (*backRepoDclass.Map_DclassDBID_DclassPtr)[id]

	// dclass is not staged anymore, remove dclassDB
	dclassDB := (*backRepoDclass.Map_DclassDBID_DclassDB)[id]
	query := backRepoDclass.db.Unscoped().Delete(&dclassDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	delete((*backRepoDclass.Map_DclassPtr_DclassDBID), dclass)
	delete((*backRepoDclass.Map_DclassDBID_DclassPtr), id)
	delete((*backRepoDclass.Map_DclassDBID_DclassDB), id)

	return
}

// BackRepoDclass.CommitPhaseOneInstance commits dclass staged instances of Dclass to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoDclass *BackRepoDclassStruct) CommitPhaseOneInstance(dclass *models.Dclass) (Error error) {

	// check if the dclass is not commited yet
	if _, ok := (*backRepoDclass.Map_DclassPtr_DclassDBID)[dclass]; ok {
		return
	}

	// initiate dclass
	var dclassDB DclassDB
	dclassDB.CopyBasicFieldsFromDclass(dclass)

	query := backRepoDclass.db.Create(&dclassDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*backRepoDclass.Map_DclassPtr_DclassDBID)[dclass] = dclassDB.ID
	(*backRepoDclass.Map_DclassDBID_DclassPtr)[dclassDB.ID] = dclass
	(*backRepoDclass.Map_DclassDBID_DclassDB)[dclassDB.ID] = &dclassDB

	return
}

// BackRepoDclass.CommitPhaseTwo commits all staged instances of Dclass to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDclass *BackRepoDclassStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, dclass := range *backRepoDclass.Map_DclassDBID_DclassPtr {
		backRepoDclass.CommitPhaseTwoInstance(backRepo, idx, dclass)
	}

	return
}

// BackRepoDclass.CommitPhaseTwoInstance commits {{structname }} of models.Dclass to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDclass *BackRepoDclassStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, dclass *models.Dclass) (Error error) {

	// fetch matching dclassDB
	if dclassDB, ok := (*backRepoDclass.Map_DclassDBID_DclassDB)[idx]; ok {

		dclassDB.CopyBasicFieldsFromDclass(dclass)

		// insertion point for translating pointers encodings into actual pointers
		query := backRepoDclass.db.Save(&dclassDB)
		if query.Error != nil {
			return query.Error
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Dclass intance %s", dclass.Name))
		return err
	}

	return
}

// BackRepoDclass.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One is the creation of instance in the stage
//
// NOTE: the is supposed to have been reset before
//
func (backRepoDclass *BackRepoDclassStruct) CheckoutPhaseOne() (Error error) {

	dclassDBArray := make([]DclassDB, 0)
	query := backRepoDclass.db.Find(&dclassDBArray)
	if query.Error != nil {
		return query.Error
	}

	// copy orm objects to the the map
	for _, dclassDB := range dclassDBArray {
		backRepoDclass.CheckoutPhaseOneInstance(&dclassDB)
	}

	return
}

// CheckoutPhaseOneInstance takes a dclassDB that has been found in the DB, updates the backRepo and stages the
// models version of the dclassDB
func (backRepoDclass *BackRepoDclassStruct) CheckoutPhaseOneInstance(dclassDB *DclassDB) (Error error) {

	dclass, ok := (*backRepoDclass.Map_DclassDBID_DclassPtr)[dclassDB.ID]
	if !ok {
		dclass = new(models.Dclass)

		(*backRepoDclass.Map_DclassDBID_DclassPtr)[dclassDB.ID] = dclass
		(*backRepoDclass.Map_DclassPtr_DclassDBID)[dclass] = dclassDB.ID

		// append model store with the new element
		dclass.Stage()
	}
	dclassDB.CopyBasicFieldsToDclass(dclass)

	// preserve pointer to dclassDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_DclassDBID_DclassDB)[dclassDB hold variable pointers
	dclassDB_Data := *dclassDB
	preservedPtrToDclass := &dclassDB_Data
	(*backRepoDclass.Map_DclassDBID_DclassDB)[dclassDB.ID] = preservedPtrToDclass

	return
}

// BackRepoDclass.CheckoutPhaseTwo Checkouts all staged instances of Dclass to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDclass *BackRepoDclassStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, dclassDB := range *backRepoDclass.Map_DclassDBID_DclassDB {
		backRepoDclass.CheckoutPhaseTwoInstance(backRepo, dclassDB)
	}
	return
}

// BackRepoDclass.CheckoutPhaseTwoInstance Checkouts staged instances of Dclass to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoDclass *BackRepoDclassStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, dclassDB *DclassDB) (Error error) {

	dclass := (*backRepoDclass.Map_DclassDBID_DclassPtr)[dclassDB.ID]
	_ = dclass // sometimes, there is no code generated. This lines voids the "unused variable" compilation error

	// insertion point for checkout of pointer encoding
	return
}

// CommitDclass allows commit of a single dclass (if already staged)
func (backRepo *BackRepoStruct) CommitDclass(dclass *models.Dclass) {
	backRepo.BackRepoDclass.CommitPhaseOneInstance(dclass)
	if id, ok := (*backRepo.BackRepoDclass.Map_DclassPtr_DclassDBID)[dclass]; ok {
		backRepo.BackRepoDclass.CommitPhaseTwoInstance(backRepo, id, dclass)
	}
}

// CommitDclass allows checkout of a single dclass (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutDclass(dclass *models.Dclass) {
	// check if the dclass is staged
	if _, ok := (*backRepo.BackRepoDclass.Map_DclassPtr_DclassDBID)[dclass]; ok {

		if id, ok := (*backRepo.BackRepoDclass.Map_DclassPtr_DclassDBID)[dclass]; ok {
			var dclassDB DclassDB
			dclassDB.ID = id

			if err := backRepo.BackRepoDclass.db.First(&dclassDB, id).Error; err != nil {
				log.Panicln("CheckoutDclass : Problem with getting object with id:", id)
			}
			backRepo.BackRepoDclass.CheckoutPhaseOneInstance(&dclassDB)
			backRepo.BackRepoDclass.CheckoutPhaseTwoInstance(backRepo, &dclassDB)
		}
	}
}

// CopyBasicFieldsToDclassDB is used to copy basic fields between the Stage or the CRUD to the back repo
func (dclassDB *DclassDB) CopyBasicFieldsFromDclass(dclass *models.Dclass) {
	// insertion point for fields commit
	dclassDB.Name_Data.String = dclass.Name
	dclassDB.Name_Data.Valid = true

}

// CopyBasicFieldsToDclassDB is used to copy basic fields between the Stage or the CRUD to the back repo
func (dclassDB *DclassDB) CopyBasicFieldsToDclass(dclass *models.Dclass) {

	// insertion point for checkout of basic fields (back repo to stage)
	dclass.Name = dclassDB.Name_Data.String
}

// Backup generates a json file from a slice of all DclassDB instances in the backrepo
func (backRepoDclass *BackRepoDclassStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "DclassDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*DclassDB, 0)
	for _, dclassDB := range *backRepoDclass.Map_DclassDBID_DclassDB {
		forBackup = append(forBackup, dclassDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Panic("Cannot json Dclass ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Panic("Cannot write the json Dclass file", err.Error())
	}
}

// RestorePhaseOne read the file "DclassDB.json" in dirPath that stores an array
// of DclassDB and stores it in the database
// the map BackRepoDclassid_atBckpTime_newID is updated accordingly
func (backRepoDclass *BackRepoDclassStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoDclassid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "DclassDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Panic("Cannot restore/open the json Dclass file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*DclassDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_DclassDBID_DclassDB
	for _, dclassDB := range forRestore {

		dclassDB_ID_atBackupTime := dclassDB.ID
		dclassDB.ID = 0
		query := backRepoDclass.db.Create(dclassDB)
		if query.Error != nil {
			log.Panic(query.Error)
		}
		(*backRepoDclass.Map_DclassDBID_DclassDB)[dclassDB.ID] = dclassDB
		BackRepoDclassid_atBckpTime_newID[dclassDB_ID_atBackupTime] = dclassDB.ID
	}

	if err != nil {
		log.Panic("Cannot restore/unmarshall json Dclass file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<Dclass>id_atBckpTime_newID
// to compute new index
func (backRepoDclass *BackRepoDclassStruct) RestorePhaseTwo() {

	for _, dclassDB := range (*backRepoDclass.Map_DclassDBID_DclassDB) {

		// next line of code is to avert unused variable compilation error
		_ = dclassDB

		// insertion point for reindexing pointers encoding
		// update databse with new index encoding
		query := backRepoDclass.db.Model(dclassDB).Updates(*dclassDB)
		if query.Error != nil {
			log.Panic(query.Error)
		}
	}

}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoDclassid_atBckpTime_newID map[uint]uint
