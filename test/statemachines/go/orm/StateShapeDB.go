// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gong/test/statemachines/go/db"
	"github.com/fullstack-lang/gong/test/statemachines/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_StateShape_sql sql.NullBool
var dummy_StateShape_time time.Duration
var dummy_StateShape_sort sort.Float64Slice

// StateShapeAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model stateshapeAPI
type StateShapeAPI struct {
	gorm.Model

	models.StateShape_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	StateShapePointersEncoding StateShapePointersEncoding
}

// StateShapePointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type StateShapePointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field State is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	StateID sql.NullInt64
}

// StateShapeDB describes a stateshape in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model stateshapeDB
type StateShapeDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field stateshapeDB.Name
	Name_Data sql.NullString

	// Declation for basic field stateshapeDB.IsExpanded
	// provide the sql storage for the boolan
	IsExpanded_Data sql.NullBool

	// Declation for basic field stateshapeDB.X
	X_Data sql.NullFloat64

	// Declation for basic field stateshapeDB.Y
	Y_Data sql.NullFloat64

	// Declation for basic field stateshapeDB.Width
	Width_Data sql.NullFloat64

	// Declation for basic field stateshapeDB.Height
	Height_Data sql.NullFloat64

	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	StateShapePointersEncoding
}

// StateShapeDBs arrays stateshapeDBs
// swagger:response stateshapeDBsResponse
type StateShapeDBs []StateShapeDB

// StateShapeDBResponse provides response
// swagger:response stateshapeDBResponse
type StateShapeDBResponse struct {
	StateShapeDB
}

// StateShapeWOP is a StateShape without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type StateShapeWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`

	IsExpanded bool `xlsx:"2"`

	X float64 `xlsx:"3"`

	Y float64 `xlsx:"4"`

	Width float64 `xlsx:"5"`

	Height float64 `xlsx:"6"`
	// insertion for WOP pointer fields
}

var StateShape_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
	"IsExpanded",
	"X",
	"Y",
	"Width",
	"Height",
}

type BackRepoStateShapeStruct struct {
	// stores StateShapeDB according to their gorm ID
	Map_StateShapeDBID_StateShapeDB map[uint]*StateShapeDB

	// stores StateShapeDB ID according to StateShape address
	Map_StateShapePtr_StateShapeDBID map[*models.StateShape]uint

	// stores StateShape according to their gorm ID
	Map_StateShapeDBID_StateShapePtr map[uint]*models.StateShape

	db db.DBInterface

	stage *models.Stage
}

func (backRepoStateShape *BackRepoStateShapeStruct) GetStage() (stage *models.Stage) {
	stage = backRepoStateShape.stage
	return
}

func (backRepoStateShape *BackRepoStateShapeStruct) GetDB() db.DBInterface {
	return backRepoStateShape.db
}

// GetStateShapeDBFromStateShapePtr is a handy function to access the back repo instance from the stage instance
func (backRepoStateShape *BackRepoStateShapeStruct) GetStateShapeDBFromStateShapePtr(stateshape *models.StateShape) (stateshapeDB *StateShapeDB) {
	id := backRepoStateShape.Map_StateShapePtr_StateShapeDBID[stateshape]
	stateshapeDB = backRepoStateShape.Map_StateShapeDBID_StateShapeDB[id]
	return
}

// BackRepoStateShape.CommitPhaseOne commits all staged instances of StateShape to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoStateShape *BackRepoStateShapeStruct) CommitPhaseOne(stage *models.Stage) (Error error) {

	var stateshapes []*models.StateShape
	for stateshape := range stage.StateShapes {
		stateshapes = append(stateshapes, stateshape)
	}

	// Sort by the order stored in Map_Staged_Order.
	sort.Slice(stateshapes, func(i, j int) bool {
		return stage.StateShapeMap_Staged_Order[stateshapes[i]] < stage.StateShapeMap_Staged_Order[stateshapes[j]]
	})

	for _, stateshape := range stateshapes {
		backRepoStateShape.CommitPhaseOneInstance(stateshape)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, stateshape := range backRepoStateShape.Map_StateShapeDBID_StateShapePtr {
		if _, ok := stage.StateShapes[stateshape]; !ok {
			backRepoStateShape.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoStateShape.CommitDeleteInstance commits deletion of StateShape to the BackRepo
func (backRepoStateShape *BackRepoStateShapeStruct) CommitDeleteInstance(id uint) (Error error) {

	stateshape := backRepoStateShape.Map_StateShapeDBID_StateShapePtr[id]

	// stateshape is not staged anymore, remove stateshapeDB
	stateshapeDB := backRepoStateShape.Map_StateShapeDBID_StateShapeDB[id]
	db, _ := backRepoStateShape.db.Unscoped()
	_, err := db.Delete(stateshapeDB)
	if err != nil {
		log.Fatal(err)
	}

	// update stores
	delete(backRepoStateShape.Map_StateShapePtr_StateShapeDBID, stateshape)
	delete(backRepoStateShape.Map_StateShapeDBID_StateShapePtr, id)
	delete(backRepoStateShape.Map_StateShapeDBID_StateShapeDB, id)

	return
}

// BackRepoStateShape.CommitPhaseOneInstance commits stateshape staged instances of StateShape to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoStateShape *BackRepoStateShapeStruct) CommitPhaseOneInstance(stateshape *models.StateShape) (Error error) {

	// check if the stateshape is not commited yet
	if _, ok := backRepoStateShape.Map_StateShapePtr_StateShapeDBID[stateshape]; ok {
		return
	}

	// initiate stateshape
	var stateshapeDB StateShapeDB
	stateshapeDB.CopyBasicFieldsFromStateShape(stateshape)

	_, err := backRepoStateShape.db.Create(&stateshapeDB)
	if err != nil {
		log.Fatal(err)
	}

	// update stores
	backRepoStateShape.Map_StateShapePtr_StateShapeDBID[stateshape] = stateshapeDB.ID
	backRepoStateShape.Map_StateShapeDBID_StateShapePtr[stateshapeDB.ID] = stateshape
	backRepoStateShape.Map_StateShapeDBID_StateShapeDB[stateshapeDB.ID] = &stateshapeDB

	return
}

// BackRepoStateShape.CommitPhaseTwo commits all staged instances of StateShape to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoStateShape *BackRepoStateShapeStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, stateshape := range backRepoStateShape.Map_StateShapeDBID_StateShapePtr {
		backRepoStateShape.CommitPhaseTwoInstance(backRepo, idx, stateshape)
	}

	return
}

// BackRepoStateShape.CommitPhaseTwoInstance commits {{structname }} of models.StateShape to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoStateShape *BackRepoStateShapeStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, stateshape *models.StateShape) (Error error) {

	// fetch matching stateshapeDB
	if stateshapeDB, ok := backRepoStateShape.Map_StateShapeDBID_StateShapeDB[idx]; ok {

		stateshapeDB.CopyBasicFieldsFromStateShape(stateshape)

		// insertion point for translating pointers encodings into actual pointers
		// commit pointer value stateshape.State translates to updating the stateshape.StateID
		stateshapeDB.StateID.Valid = true // allow for a 0 value (nil association)
		if stateshape.State != nil {
			if StateId, ok := backRepo.BackRepoState.Map_StatePtr_StateDBID[stateshape.State]; ok {
				stateshapeDB.StateID.Int64 = int64(StateId)
				stateshapeDB.StateID.Valid = true
			}
		} else {
			stateshapeDB.StateID.Int64 = 0
			stateshapeDB.StateID.Valid = true
		}

		_, err := backRepoStateShape.db.Save(stateshapeDB)
		if err != nil {
			log.Fatal(err)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown StateShape intance %s", stateshape.Name))
		return err
	}

	return
}

// BackRepoStateShape.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoStateShape *BackRepoStateShapeStruct) CheckoutPhaseOne() (Error error) {

	stateshapeDBArray := make([]StateShapeDB, 0)
	_, err := backRepoStateShape.db.Find(&stateshapeDBArray)
	if err != nil {
		return err
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	stateshapeInstancesToBeRemovedFromTheStage := make(map[*models.StateShape]any)
	for key, value := range backRepoStateShape.stage.StateShapes {
		stateshapeInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, stateshapeDB := range stateshapeDBArray {
		backRepoStateShape.CheckoutPhaseOneInstance(&stateshapeDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		stateshape, ok := backRepoStateShape.Map_StateShapeDBID_StateShapePtr[stateshapeDB.ID]
		if ok {
			delete(stateshapeInstancesToBeRemovedFromTheStage, stateshape)
		}
	}

	// remove from stage and back repo's 3 maps all stateshapes that are not in the checkout
	for stateshape := range stateshapeInstancesToBeRemovedFromTheStage {
		stateshape.Unstage(backRepoStateShape.GetStage())

		// remove instance from the back repo 3 maps
		stateshapeID := backRepoStateShape.Map_StateShapePtr_StateShapeDBID[stateshape]
		delete(backRepoStateShape.Map_StateShapePtr_StateShapeDBID, stateshape)
		delete(backRepoStateShape.Map_StateShapeDBID_StateShapeDB, stateshapeID)
		delete(backRepoStateShape.Map_StateShapeDBID_StateShapePtr, stateshapeID)
	}

	return
}

// CheckoutPhaseOneInstance takes a stateshapeDB that has been found in the DB, updates the backRepo and stages the
// models version of the stateshapeDB
func (backRepoStateShape *BackRepoStateShapeStruct) CheckoutPhaseOneInstance(stateshapeDB *StateShapeDB) (Error error) {

	stateshape, ok := backRepoStateShape.Map_StateShapeDBID_StateShapePtr[stateshapeDB.ID]
	if !ok {
		stateshape = new(models.StateShape)

		backRepoStateShape.Map_StateShapeDBID_StateShapePtr[stateshapeDB.ID] = stateshape
		backRepoStateShape.Map_StateShapePtr_StateShapeDBID[stateshape] = stateshapeDB.ID

		// append model store with the new element
		stateshape.Name = stateshapeDB.Name_Data.String
		stateshape.Stage(backRepoStateShape.GetStage())
	}
	stateshapeDB.CopyBasicFieldsToStateShape(stateshape)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	stateshape.Stage(backRepoStateShape.GetStage())

	// preserve pointer to stateshapeDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_StateShapeDBID_StateShapeDB)[stateshapeDB hold variable pointers
	stateshapeDB_Data := *stateshapeDB
	preservedPtrToStateShape := &stateshapeDB_Data
	backRepoStateShape.Map_StateShapeDBID_StateShapeDB[stateshapeDB.ID] = preservedPtrToStateShape

	return
}

// BackRepoStateShape.CheckoutPhaseTwo Checkouts all staged instances of StateShape to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoStateShape *BackRepoStateShapeStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, stateshapeDB := range backRepoStateShape.Map_StateShapeDBID_StateShapeDB {
		backRepoStateShape.CheckoutPhaseTwoInstance(backRepo, stateshapeDB)
	}
	return
}

// BackRepoStateShape.CheckoutPhaseTwoInstance Checkouts staged instances of StateShape to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoStateShape *BackRepoStateShapeStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, stateshapeDB *StateShapeDB) (Error error) {

	stateshape := backRepoStateShape.Map_StateShapeDBID_StateShapePtr[stateshapeDB.ID]

	stateshapeDB.DecodePointers(backRepo, stateshape)

	return
}

func (stateshapeDB *StateShapeDB) DecodePointers(backRepo *BackRepoStruct, stateshape *models.StateShape) {

	// insertion point for checkout of pointer encoding
	// State field	
	{
		id := stateshapeDB.StateID.Int64
		if id != 0 {
			tmp, ok := backRepo.BackRepoState.Map_StateDBID_StatePtr[uint(id)]

			// if the pointer id is unknown, it is not a problem, maybe the target was removed from the front
			if !ok {
				log.Println("DecodePointers: stateshape.State, unknown pointer id", id)
				stateshape.State = nil
			} else {
				// updates only if field has changed
				if stateshape.State == nil || stateshape.State != tmp {
					stateshape.State = tmp
				}
			}
		} else {
			stateshape.State = nil
		}
	}
	
	return
}

// CommitStateShape allows commit of a single stateshape (if already staged)
func (backRepo *BackRepoStruct) CommitStateShape(stateshape *models.StateShape) {
	backRepo.BackRepoStateShape.CommitPhaseOneInstance(stateshape)
	if id, ok := backRepo.BackRepoStateShape.Map_StateShapePtr_StateShapeDBID[stateshape]; ok {
		backRepo.BackRepoStateShape.CommitPhaseTwoInstance(backRepo, id, stateshape)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitStateShape allows checkout of a single stateshape (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutStateShape(stateshape *models.StateShape) {
	// check if the stateshape is staged
	if _, ok := backRepo.BackRepoStateShape.Map_StateShapePtr_StateShapeDBID[stateshape]; ok {

		if id, ok := backRepo.BackRepoStateShape.Map_StateShapePtr_StateShapeDBID[stateshape]; ok {
			var stateshapeDB StateShapeDB
			stateshapeDB.ID = id

			if _, err := backRepo.BackRepoStateShape.db.First(&stateshapeDB, id); err != nil {
				log.Fatalln("CheckoutStateShape : Problem with getting object with id:", id)
			}
			backRepo.BackRepoStateShape.CheckoutPhaseOneInstance(&stateshapeDB)
			backRepo.BackRepoStateShape.CheckoutPhaseTwoInstance(backRepo, &stateshapeDB)
		}
	}
}

// CopyBasicFieldsFromStateShape
func (stateshapeDB *StateShapeDB) CopyBasicFieldsFromStateShape(stateshape *models.StateShape) {
	// insertion point for fields commit

	stateshapeDB.Name_Data.String = stateshape.Name
	stateshapeDB.Name_Data.Valid = true

	stateshapeDB.IsExpanded_Data.Bool = stateshape.IsExpanded
	stateshapeDB.IsExpanded_Data.Valid = true

	stateshapeDB.X_Data.Float64 = stateshape.X
	stateshapeDB.X_Data.Valid = true

	stateshapeDB.Y_Data.Float64 = stateshape.Y
	stateshapeDB.Y_Data.Valid = true

	stateshapeDB.Width_Data.Float64 = stateshape.Width
	stateshapeDB.Width_Data.Valid = true

	stateshapeDB.Height_Data.Float64 = stateshape.Height
	stateshapeDB.Height_Data.Valid = true
}

// CopyBasicFieldsFromStateShape_WOP
func (stateshapeDB *StateShapeDB) CopyBasicFieldsFromStateShape_WOP(stateshape *models.StateShape_WOP) {
	// insertion point for fields commit

	stateshapeDB.Name_Data.String = stateshape.Name
	stateshapeDB.Name_Data.Valid = true

	stateshapeDB.IsExpanded_Data.Bool = stateshape.IsExpanded
	stateshapeDB.IsExpanded_Data.Valid = true

	stateshapeDB.X_Data.Float64 = stateshape.X
	stateshapeDB.X_Data.Valid = true

	stateshapeDB.Y_Data.Float64 = stateshape.Y
	stateshapeDB.Y_Data.Valid = true

	stateshapeDB.Width_Data.Float64 = stateshape.Width
	stateshapeDB.Width_Data.Valid = true

	stateshapeDB.Height_Data.Float64 = stateshape.Height
	stateshapeDB.Height_Data.Valid = true
}

// CopyBasicFieldsFromStateShapeWOP
func (stateshapeDB *StateShapeDB) CopyBasicFieldsFromStateShapeWOP(stateshape *StateShapeWOP) {
	// insertion point for fields commit

	stateshapeDB.Name_Data.String = stateshape.Name
	stateshapeDB.Name_Data.Valid = true

	stateshapeDB.IsExpanded_Data.Bool = stateshape.IsExpanded
	stateshapeDB.IsExpanded_Data.Valid = true

	stateshapeDB.X_Data.Float64 = stateshape.X
	stateshapeDB.X_Data.Valid = true

	stateshapeDB.Y_Data.Float64 = stateshape.Y
	stateshapeDB.Y_Data.Valid = true

	stateshapeDB.Width_Data.Float64 = stateshape.Width
	stateshapeDB.Width_Data.Valid = true

	stateshapeDB.Height_Data.Float64 = stateshape.Height
	stateshapeDB.Height_Data.Valid = true
}

// CopyBasicFieldsToStateShape
func (stateshapeDB *StateShapeDB) CopyBasicFieldsToStateShape(stateshape *models.StateShape) {
	// insertion point for checkout of basic fields (back repo to stage)
	stateshape.Name = stateshapeDB.Name_Data.String
	stateshape.IsExpanded = stateshapeDB.IsExpanded_Data.Bool
	stateshape.X = stateshapeDB.X_Data.Float64
	stateshape.Y = stateshapeDB.Y_Data.Float64
	stateshape.Width = stateshapeDB.Width_Data.Float64
	stateshape.Height = stateshapeDB.Height_Data.Float64
}

// CopyBasicFieldsToStateShape_WOP
func (stateshapeDB *StateShapeDB) CopyBasicFieldsToStateShape_WOP(stateshape *models.StateShape_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	stateshape.Name = stateshapeDB.Name_Data.String
	stateshape.IsExpanded = stateshapeDB.IsExpanded_Data.Bool
	stateshape.X = stateshapeDB.X_Data.Float64
	stateshape.Y = stateshapeDB.Y_Data.Float64
	stateshape.Width = stateshapeDB.Width_Data.Float64
	stateshape.Height = stateshapeDB.Height_Data.Float64
}

// CopyBasicFieldsToStateShapeWOP
func (stateshapeDB *StateShapeDB) CopyBasicFieldsToStateShapeWOP(stateshape *StateShapeWOP) {
	stateshape.ID = int(stateshapeDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	stateshape.Name = stateshapeDB.Name_Data.String
	stateshape.IsExpanded = stateshapeDB.IsExpanded_Data.Bool
	stateshape.X = stateshapeDB.X_Data.Float64
	stateshape.Y = stateshapeDB.Y_Data.Float64
	stateshape.Width = stateshapeDB.Width_Data.Float64
	stateshape.Height = stateshapeDB.Height_Data.Float64
}

// Backup generates a json file from a slice of all StateShapeDB instances in the backrepo
func (backRepoStateShape *BackRepoStateShapeStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "StateShapeDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*StateShapeDB, 0)
	for _, stateshapeDB := range backRepoStateShape.Map_StateShapeDBID_StateShapeDB {
		forBackup = append(forBackup, stateshapeDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json StateShape ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json StateShape file", err.Error())
	}
}

// Backup generates a json file from a slice of all StateShapeDB instances in the backrepo
func (backRepoStateShape *BackRepoStateShapeStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*StateShapeDB, 0)
	for _, stateshapeDB := range backRepoStateShape.Map_StateShapeDBID_StateShapeDB {
		forBackup = append(forBackup, stateshapeDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("StateShape")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&StateShape_Fields, -1)
	for _, stateshapeDB := range forBackup {

		var stateshapeWOP StateShapeWOP
		stateshapeDB.CopyBasicFieldsToStateShapeWOP(&stateshapeWOP)

		row := sh.AddRow()
		row.WriteStruct(&stateshapeWOP, -1)
	}
}

// RestoreXL from the "StateShape" sheet all StateShapeDB instances
func (backRepoStateShape *BackRepoStateShapeStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoStateShapeid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["StateShape"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoStateShape.rowVisitorStateShape)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoStateShape *BackRepoStateShapeStruct) rowVisitorStateShape(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var stateshapeWOP StateShapeWOP
		row.ReadStruct(&stateshapeWOP)

		// add the unmarshalled struct to the stage
		stateshapeDB := new(StateShapeDB)
		stateshapeDB.CopyBasicFieldsFromStateShapeWOP(&stateshapeWOP)

		stateshapeDB_ID_atBackupTime := stateshapeDB.ID
		stateshapeDB.ID = 0
		_, err := backRepoStateShape.db.Create(stateshapeDB)
		if err != nil {
			log.Fatal(err)
		}
		backRepoStateShape.Map_StateShapeDBID_StateShapeDB[stateshapeDB.ID] = stateshapeDB
		BackRepoStateShapeid_atBckpTime_newID[stateshapeDB_ID_atBackupTime] = stateshapeDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "StateShapeDB.json" in dirPath that stores an array
// of StateShapeDB and stores it in the database
// the map BackRepoStateShapeid_atBckpTime_newID is updated accordingly
func (backRepoStateShape *BackRepoStateShapeStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoStateShapeid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "StateShapeDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json StateShape file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*StateShapeDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_StateShapeDBID_StateShapeDB
	for _, stateshapeDB := range forRestore {

		stateshapeDB_ID_atBackupTime := stateshapeDB.ID
		stateshapeDB.ID = 0
		_, err := backRepoStateShape.db.Create(stateshapeDB)
		if err != nil {
			log.Fatal(err)
		}
		backRepoStateShape.Map_StateShapeDBID_StateShapeDB[stateshapeDB.ID] = stateshapeDB
		BackRepoStateShapeid_atBckpTime_newID[stateshapeDB_ID_atBackupTime] = stateshapeDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json StateShape file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<StateShape>id_atBckpTime_newID
// to compute new index
func (backRepoStateShape *BackRepoStateShapeStruct) RestorePhaseTwo() {

	for _, stateshapeDB := range backRepoStateShape.Map_StateShapeDBID_StateShapeDB {

		// next line of code is to avert unused variable compilation error
		_ = stateshapeDB

		// insertion point for reindexing pointers encoding
		// reindexing State field
		if stateshapeDB.StateID.Int64 != 0 {
			stateshapeDB.StateID.Int64 = int64(BackRepoStateid_atBckpTime_newID[uint(stateshapeDB.StateID.Int64)])
			stateshapeDB.StateID.Valid = true
		}

		// update databse with new index encoding
		db, _ := backRepoStateShape.db.Model(stateshapeDB)
		_, err := db.Updates(*stateshapeDB)
		if err != nil {
			log.Fatal(err)
		}
	}

}

// BackRepoStateShape.ResetReversePointers commits all staged instances of StateShape to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoStateShape *BackRepoStateShapeStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, stateshape := range backRepoStateShape.Map_StateShapeDBID_StateShapePtr {
		backRepoStateShape.ResetReversePointersInstance(backRepo, idx, stateshape)
	}

	return
}

func (backRepoStateShape *BackRepoStateShapeStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, stateshape *models.StateShape) (Error error) {

	// fetch matching stateshapeDB
	if stateshapeDB, ok := backRepoStateShape.Map_StateShapeDBID_StateShapeDB[idx]; ok {
		_ = stateshapeDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoStateShapeid_atBckpTime_newID map[uint]uint
