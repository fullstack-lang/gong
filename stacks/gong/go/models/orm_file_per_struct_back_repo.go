package models

import (
	"fmt"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const BackRepoPerStructTemplateCode = `// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"errors"
	"fmt"
	"log"
	"time"

	"github.com/jinzhu/gorm"
	"{{PkgPathRoot}}"
)

// dummy variable to have the import database/sql wihthout compile failure id no sql is used
var dummy_{{Structname}} sql.NullBool
var __{{Structname}}_time__dummyDeclaration time.Duration

// {{Structname}}API is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model {{structname}}API
type {{Structname}}API struct {
	models.{{Structname}}

	// insertion for fields declaration{{` + string(rune(BackRepoFieldsDeclaration)) + `}}
	// end of insertion
}

// {{Structname}}DB describes a {{structname}} in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model {{structname}}DB
type {{Structname}}DB struct {
	gorm.Model

	{{Structname}}API
}

// {{Structname}}DBs arrays {{structname}}DBs
// swagger:response {{structname}}DBsResponse
type {{Structname}}DBs []{{Structname}}DB

// {{Structname}}DBResponse provides response
// swagger:response {{structname}}DBResponse
type {{Structname}}DBResponse struct {
	{{Structname}}DB
}

type BackRepo{{Structname}}Struct struct {
	// stores {{Structname}}DB according to their gorm ID
	Map_{{Structname}}DBID_{{Structname}}DB *map[uint]*{{Structname}}DB

	// stores {{Structname}}DB ID according to {{Structname}} address
	Map_{{Structname}}Ptr_{{Structname}}DBID *map[*models.{{Structname}}]uint

	// stores {{Structname}} according to their gorm ID
	Map_{{Structname}}DBID_{{Structname}}Ptr *map[uint]*models.{{Structname}}

	db *gorm.DB
}

// BackRepo{{Structname}}.Init set up the BackRepo of the {{Structname}}
func (backRepo{{Structname}} *BackRepo{{Structname}}Struct) Init(db *gorm.DB) (Error error) {

	if backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}Ptr != nil {
		err := errors.New("In Init, backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}Ptr should be nil")
		return err
	}

	if backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}DB != nil {
		err := errors.New("In Init, backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}DB should be nil")
		return err
	}

	if backRepo{{Structname}}.Map_{{Structname}}Ptr_{{Structname}}DBID != nil {
		err := errors.New("In Init, backRepo{{Structname}}.Map_{{Structname}}Ptr_{{Structname}}DBID should be nil")
		return err
	}

	tmp := make(map[uint]*models.{{Structname}}, 0)
	backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}Ptr = &tmp

	tmpDB := make(map[uint]*{{Structname}}DB, 0)
	backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}DB = &tmpDB

	tmpID := make(map[*models.{{Structname}}]uint, 0)
	backRepo{{Structname}}.Map_{{Structname}}Ptr_{{Structname}}DBID = &tmpID

	backRepo{{Structname}}.db = db
	return
}

// BackRepo{{Structname}}.CommitPhaseOne commits all staged instances of {{Structname}} to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepo{{Structname}} *BackRepo{{Structname}}Struct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for {{structname}} := range stage.{{Structname}}s {
		backRepo{{Structname}}.CommitPhaseOneInstance({{structname}})
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, {{structname}} := range *backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}Ptr {
		if _, ok := stage.{{Structname}}s[{{structname}}]; !ok {
			backRepo{{Structname}}.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepo{{Structname}}.CommitDeleteInstance commits deletion of {{Structname}} to the BackRepo
func (backRepo{{Structname}} *BackRepo{{Structname}}Struct) CommitDeleteInstance(id uint) (Error error) {

	{{structname}} := (*backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}Ptr)[id]

	// {{structname}} is not staged anymore, remove {{structname}}DB
	{{structname}}DB := (*backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}DB)[id]
	query := backRepo{{Structname}}.db.Unscoped().Delete(&{{structname}}DB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	delete((*backRepo{{Structname}}.Map_{{Structname}}Ptr_{{Structname}}DBID), {{structname}})
	delete((*backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}Ptr), id)
	delete((*backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}DB), id)

	return
}

// BackRepo{{Structname}}.CommitPhaseOneInstance commits {{structname}} staged instances of {{Structname}} to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepo{{Structname}} *BackRepo{{Structname}}Struct) CommitPhaseOneInstance({{structname}} *models.{{Structname}}) (Error error) {

	// check if the {{structname}} is not commited yet
	if _, ok := (*backRepo{{Structname}}.Map_{{Structname}}Ptr_{{Structname}}DBID)[{{structname}}]; ok {
		return
	}

	// initiate {{structname}}
	var {{structname}}DB {{Structname}}DB
	{{structname}}DB.{{Structname}} = *{{structname}}

	query := backRepo{{Structname}}.db.Create(&{{structname}}DB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*backRepo{{Structname}}.Map_{{Structname}}Ptr_{{Structname}}DBID)[{{structname}}] = {{structname}}DB.ID
	(*backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}Ptr)[{{structname}}DB.ID] = {{structname}}
	(*backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}DB)[{{structname}}DB.ID] = &{{structname}}DB

	return
}

// BackRepo{{Structname}}.CommitPhaseTwo commits all staged instances of {{Structname}} to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepo{{Structname}} *BackRepo{{Structname}}Struct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, {{structname}} := range *backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}Ptr {
		backRepo{{Structname}}.CommitPhaseTwoInstance(backRepo, idx, {{structname}})
	}

	return
}

// BackRepo{{Structname}}.CommitPhaseTwoInstance commits {{structname }} of models.{{Structname}} to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepo{{Structname}} *BackRepo{{Structname}}Struct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, {{structname}} *models.{{Structname}}) (Error error) {

	// fetch matching {{structname}}DB
	if {{structname}}DB, ok := (*backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}DB)[idx]; ok {

		{
			{
				// insertion point for fields commit{{` + string(rune(BackRepoFieldsCommitNew)) + `}}
			}
		}
		query := backRepo{{Structname}}.db.Save(&{{structname}}DB)
		if query.Error != nil {
			return query.Error
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown {{Structname}} intance %s", {{structname}}.Name))
		return err
	}

	return
}

// BackRepo{{Structname}}.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One is the creation of instance in the stage
//
// NOTE: the is supposed to have been reset before
//
func (backRepo{{Structname}} *BackRepo{{Structname}}Struct) CheckoutPhaseOne() (Error error) {

	{{structname}}DBArray := make([]{{Structname}}DB, 0)
	query := backRepo{{Structname}}.db.Find(&{{structname}}DBArray)
	if query.Error != nil {
		return query.Error
	}

	// copy orm objects to the the map
	for _, {{structname}}DB := range {{structname}}DBArray {
		backRepo{{Structname}}.CheckoutPhaseOneInstance(&{{structname}}DB)
	}

	return
}

// CheckoutPhaseOneInstance takes a {{structname}}DB that has been found in the DB, updates the backRepo and stages the
// models version of the {{structname}}DB
func (backRepo{{Structname}} *BackRepo{{Structname}}Struct) CheckoutPhaseOneInstance({{structname}}DB *{{Structname}}DB) (Error error) {

	// if absent, create entries in the backRepo{{Structname}} maps.
	{{structname}}WithNewFieldValues := {{structname}}DB.{{Structname}}
	if _, ok := (*backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}Ptr)[{{structname}}DB.ID]; !ok {

		(*backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}Ptr)[{{structname}}DB.ID] = &{{structname}}WithNewFieldValues
		(*backRepo{{Structname}}.Map_{{Structname}}Ptr_{{Structname}}DBID)[&{{structname}}WithNewFieldValues] = {{structname}}DB.ID

		// append model store with the new element
		{{structname}}WithNewFieldValues.Stage()
	}
	{{structname}}DBWithNewFieldValues := *{{structname}}DB
	(*backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}DB)[{{structname}}DB.ID] = &{{structname}}DBWithNewFieldValues

	return
}

// BackRepo{{Structname}}.CheckoutPhaseTwo Checkouts all staged instances of {{Structname}} to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepo{{Structname}} *BackRepo{{Structname}}Struct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, {{structname}}DB := range *backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}DB {
		backRepo{{Structname}}.CheckoutPhaseTwoInstance(backRepo, {{structname}}DB)
	}
	return
}

// BackRepo{{Structname}}.CheckoutPhaseTwoInstance Checkouts staged instances of {{Structname}} to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepo{{Structname}} *BackRepo{{Structname}}Struct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, {{structname}}DB *{{Structname}}DB) (Error error) {

	{{structname}} := (*backRepo{{Structname}}.Map_{{Structname}}DBID_{{Structname}}Ptr)[{{structname}}DB.ID]
	_ = {{structname}} // sometimes, there is no code generated. This lines voids the "unused variable" compilation error
	{
		{
			// insertion point for checkout, i.e. update of fields of stage instance from fields of back repo instances
			//{{` + string(rune(BackRepoFieldsCheckoutNew)) + `}}
		}
	}
	return
}

// Commit{{Structname}} allows commit of a single {{structname}} (if already staged)
func (backRepo *BackRepoStruct) Commit{{Structname}}({{structname}} *models.{{Structname}}) {
	backRepo.BackRepo{{Structname}}.CommitPhaseOneInstance({{structname}})
	if id, ok := (*backRepo.BackRepo{{Structname}}.Map_{{Structname}}Ptr_{{Structname}}DBID)[{{structname}}]; ok {
		backRepo.BackRepo{{Structname}}.CommitPhaseTwoInstance(backRepo, id, {{structname}})
	}
}

// Commit{{Structname}} allows checkout of a single {{structname}} (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) Checkout{{Structname}}({{structname}} *models.{{Structname}}) {
	// check if the {{structname}} is staged
	if _, ok := (*backRepo.BackRepo{{Structname}}.Map_{{Structname}}Ptr_{{Structname}}DBID)[{{structname}}]; ok {

		if id, ok := (*backRepo.BackRepo{{Structname}}.Map_{{Structname}}Ptr_{{Structname}}DBID)[{{structname}}]; ok {
			var {{structname}}DB {{Structname}}DB
			{{structname}}DB.ID = id

			if err := backRepo.BackRepo{{Structname}}.db.First(&{{structname}}DB, id).Error; err != nil {
				log.Panicln("Checkout{{Structname}} : Problem with getting object with id:", id)
			}
			backRepo.BackRepo{{Structname}}.CheckoutPhaseOneInstance(&{{structname}}DB)
			backRepo.BackRepo{{Structname}}.CheckoutPhaseTwoInstance(backRepo, &{{structname}}DB)
		}
	}
}
`

// insertion points
type BackRepoInsertionPoint int

const (
	BackRepoFieldsDeclaration BackRepoInsertionPoint = iota
	BackRepoFieldsCommitNew
	BackRepoFieldsCheckoutNew
	BackRepoNbInsertionPoints
)

//
// Sub Templates
//
type BackRepoPerStructSubTemplate int

const (
	BackRepoDeclarationBasicField BackRepoPerStructSubTemplate = iota
	BackRepoCommitBasicField
	BackRepoCheckoutBasicField

	BackRepoDeclarationTimeField
	BackRepoCommitTimeField
	BackRepoCheckoutTimeField

	BackRepoCommitBasicFieldEnum
	BackRepoCheckoutBasicFieldEnum

	BackRepoCommitBasicFieldInt
	BackRepoCheckoutBasicFieldInt

	BackRepoDeclarationBasicBooleanField
	BackRepoCommitBasicBooleanField
	BackRepoCheckoutBasicFieldBoolean

	BackRepoDeclarationPointerToStructField
	BackRepoCommitNewPointerToStructField
	BackRepoCheckoutNewPointerToStructStageField

	BackRepoDeclarationSliceOfPointerToStructField
	BackRepoCommitSliceOfPointerToStructField
	BackRepoCommitNewSliceOfPointerToStructField
	BackRepoCheckoutNewSliceOfPointerToStructStageField
)

var BackRepoFieldSubTemplateCode map[BackRepoPerStructSubTemplate]string = map[BackRepoPerStructSubTemplate]string{

	//
	// Declarations
	//

	BackRepoDeclarationBasicField: `
	// Declation for basic field {{structname}}DB.{{FieldName}} {{BasicKind}} (to be completed)
	{{FieldName}}_Data sql.{{SqlNullType}}
`,

	BackRepoDeclarationTimeField: `
	// Declation for basic field {{structname}}DB.{{FieldName}}
	{{FieldName}}_Data sql.NullTime
`,

	BackRepoDeclarationBasicBooleanField: `
	// Declation for basic field {{structname}}DB.{{FieldName}} {{BasicKind}} (to be completed)
	// provide the sql storage for the boolan
	{{FieldName}}_Data sql.NullBool
`,

	BackRepoDeclarationPointerToStructField: `
	// field {{FieldName}} is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	{{FieldName}}ID sql.NullInt64

	// all gong Struct has a Name field, this enables this data to object field
	{{FieldName}}Name string
`,

	BackRepoDeclarationSliceOfPointerToStructField: `
	// Implementation of a reverse ID for field {{AssociationStructName}}{}.{{FieldName}} []*{{Structname}}
	{{AssociationStructName}}_{{FieldName}}DBID sql.NullInt64
`,

	//
	// Commit sub templates
	//

	BackRepoCommitBasicField: `
				{{structname}}DB.{{FieldName}}_Data.{{SqlNullType}} = {{structname}}.{{FieldName}}
				{{structname}}DB.{{FieldName}}_Data.Valid = true
`,

	BackRepoCommitBasicFieldEnum: `
				{{structname}}DB.{{FieldName}}_Data.String = string({{structname}}.{{FieldName}})
				{{structname}}DB.{{FieldName}}_Data.Valid = true
`,

	BackRepoCommitBasicFieldInt: `
				{{structname}}DB.{{FieldName}}_Data.Int64 = int64({{structname}}.{{FieldName}})
				{{structname}}DB.{{FieldName}}_Data.Valid = true
`,
	BackRepoCommitTimeField: `
				{{structname}}DB.{{FieldName}}_Data.Time = {{structname}}.{{FieldName}}
				{{structname}}DB.{{FieldName}}_Data.Valid = true
`,

	BackRepoCommitBasicBooleanField: `
				{{structname}}DB.{{FieldName}}_Data.Bool = {{structname}}.{{FieldName}}
				{{structname}}DB.{{FieldName}}_Data.Valid = true
`,

	BackRepoCommitNewPointerToStructField: `
				// commit pointer value {{structname}}.{{FieldName}} translates to updating the {{structname}}.{{FieldName}}ID
				{{structname}}DB.{{FieldName}}ID.Valid = true // allow for a 0 value (nil association)
				if {{structname}}.{{FieldName}} != nil {
					if {{FieldName}}Id, ok := (*backRepo.BackRepo{{AssociationStructName}}.Map_{{AssociationStructName}}Ptr_{{AssociationStructName}}DBID)[{{structname}}.{{FieldName}}]; ok {
						{{structname}}DB.{{FieldName}}ID.Int64 = int64({{FieldName}}Id)
					}
				}
`,

	BackRepoCommitSliceOfPointerToStructField: `
				// commit a slice of pointer translates to update reverse pointer to {{AssociationStructName}}, i.e.
				for _, {{associationStructName}} := range {{structname}}.{{FieldName}} {
					if {{associationStructName}}DBID, ok := (*map_{{AssociationStructName}}Ptr_{{AssociationStructName}}DBID)[{{associationStructName}}]; ok {
						if {{associationStructName}}DB, ok := (*map_{{AssociationStructName}}DBID_{{AssociationStructName}}DB)[{{associationStructName}}DBID]; ok {
							{{associationStructName}}DB.{{Structname}}_{{FieldName}}DBID.Int64 = int64({{structname}}DB.ID)
							{{associationStructName}}DB.{{Structname}}_{{FieldName}}DBID.Valid = true
							if q := db.Save(&{{associationStructName}}DB); q.Error != nil {
								return q.Error
							}
						}
					}
				}
`,

	BackRepoCommitNewSliceOfPointerToStructField: `
				// commit a slice of pointer translates to update reverse pointer to {{AssociationStructName}}, i.e.
				for _, {{associationStructName}} := range {{structname}}.{{FieldName}} {
					if {{associationStructName}}DBID, ok := (*backRepo.BackRepo{{AssociationStructName}}.Map_{{AssociationStructName}}Ptr_{{AssociationStructName}}DBID)[{{associationStructName}}]; ok {
						if {{associationStructName}}DB, ok := (*backRepo.BackRepo{{AssociationStructName}}.Map_{{AssociationStructName}}DBID_{{AssociationStructName}}DB)[{{associationStructName}}DBID]; ok {
							{{associationStructName}}DB.{{Structname}}_{{FieldName}}DBID.Int64 = int64({{structname}}DB.ID)
							{{associationStructName}}DB.{{Structname}}_{{FieldName}}DBID.Valid = true
							if q := backRepo{{Structname}}.db.Save(&{{associationStructName}}DB); q.Error != nil {
								return q.Error
							}
						}
					}
				}
`,

	//
	// sub template for checkouts
	//

	BackRepoCheckoutBasicField: `
			{{structname}}.{{FieldName}} = {{structname}}DB.{{FieldName}}_Data.{{SqlNullType}}
`,

	BackRepoCheckoutTimeField: `
			{{structname}}.{{FieldName}} = {{structname}}DB.{{FieldName}}_Data.Time
`,

	BackRepoCheckoutBasicFieldEnum: `
			{{structname}}.{{FieldName}} = models.{{EnumType}}({{structname}}DB.{{FieldName}}_Data.String)
`,

	BackRepoCheckoutBasicFieldInt: `
			{{structname}}.{{FieldName}} = {{FieldType}}({{structname}}DB.{{FieldName}}_Data.Int64)
`,

	BackRepoCheckoutBasicFieldBoolean: `
			{{structname}}.{{FieldName}} = {{structname}}DB.{{FieldName}}_Data.Bool`,

	BackRepoCheckoutNewPointerToStructStageField: `
			// {{FieldName}} field
			if {{structname}}DB.{{FieldName}}ID.Int64 != 0 {
				{{structname}}.{{FieldName}} = (*backRepo.BackRepo{{AssociationStructName}}.Map_{{AssociationStructName}}DBID_{{AssociationStructName}}Ptr)[uint({{structname}}DB.{{FieldName}}ID.Int64)]
			}
`,

	BackRepoCheckoutNewSliceOfPointerToStructStageField: `
			// parse all {{AssociationStructName}}DB and redeem the array of poiners to {{Structname}}
			// first reset the slice
			{{structname}}.{{FieldName}} = {{structname}}.{{FieldName}}[:0]
			for _, {{AssociationStructName}}DB := range *backRepo.BackRepo{{AssociationStructName}}.Map_{{AssociationStructName}}DBID_{{AssociationStructName}}DB {
				if {{AssociationStructName}}DB.{{Structname}}_{{FieldName}}DBID.Int64 == int64({{structname}}DB.ID) {
					{{AssociationStructName}} := (*backRepo.BackRepo{{AssociationStructName}}.Map_{{AssociationStructName}}DBID_{{AssociationStructName}}Ptr)[{{AssociationStructName}}DB.ID]
					{{structname}}.{{FieldName}} = append({{structname}}.{{FieldName}}, {{AssociationStructName}})
				}
			}
`,
}

// MultiCodeGeneratorBackRepo parses mdlPkg and generates the code for the
// back repository code
func MultiCodeGeneratorBackRepo(
	mdlPkg *ModelPkg,
	pkgName string,
	pkgGoPath string,
	dirPath string) {

	// have alphabetical order generation
	structList := []*GongStruct{}
	for _, _struct := range mdlPkg.GongStructs {
		if _struct.HasNameField() {
			structList = append(structList, _struct)
		}
	}
	sort.Slice(structList[:], func(i, j int) bool {
		return structList[i].Name < structList[j].Name
	})

	for _, _struct := range structList {

		codeGO := BackRepoPerStructTemplateCode

		insertions := make(map[BackRepoInsertionPoint]string)
		for insertion := BackRepoInsertionPoint(0); insertion < BackRepoNbInsertionPoints; insertion++ {
			insertions[insertion] = ""
		}
		for _, field := range _struct.Fields {
			switch field.(type) {
			case *GongBasicField:
				gongBasicField := field.(*GongBasicField)

				if gongBasicField.basicKind == types.Bool {

					insertions[BackRepoFieldsDeclaration] += Replace2(
						BackRepoFieldSubTemplateCode[BackRepoDeclarationBasicBooleanField],
						"{{FieldName}}", gongBasicField.Name,
						"{{BasicKind}}", gongBasicField.Type.Underlying().String())

					insertions[BackRepoFieldsCommitNew] += Replace1(
						BackRepoFieldSubTemplateCode[BackRepoCommitBasicBooleanField],
						"{{FieldName}}", gongBasicField.Name)

					insertions[BackRepoFieldsCheckoutNew] += Replace1(
						BackRepoFieldSubTemplateCode[BackRepoCheckoutBasicFieldBoolean],
						"{{FieldName}}", gongBasicField.Name)

				} else {
					switch gongBasicField.basicKind {
					case types.String:
						insertions[BackRepoFieldsDeclaration] += Replace2(
							BackRepoFieldSubTemplateCode[BackRepoDeclarationBasicField],
							"{{FieldName}}", gongBasicField.Name,
							"{{SqlNullType}}", "NullString")

						if gongBasicField.GongEnum != nil {
							insertions[BackRepoFieldsCommitNew] += Replace1(
								BackRepoFieldSubTemplateCode[BackRepoCommitBasicFieldEnum],
								"{{FieldName}}", gongBasicField.Name)

							insertions[BackRepoFieldsCheckoutNew] += Replace2(
								BackRepoFieldSubTemplateCode[BackRepoCheckoutBasicFieldEnum],
								"{{FieldName}}", gongBasicField.Name,
								"{{EnumType}}", gongBasicField.GongEnum.Name)

						} else {
							insertions[BackRepoFieldsCommitNew] += Replace2(
								BackRepoFieldSubTemplateCode[BackRepoCommitBasicField],
								"{{FieldName}}", gongBasicField.Name,
								"{{SqlNullType}}", "String")

							insertions[BackRepoFieldsCheckoutNew] += Replace2(
								BackRepoFieldSubTemplateCode[BackRepoCheckoutBasicField],
								"{{FieldName}}", gongBasicField.Name,
								"{{SqlNullType}}", "String")

						}
					case types.Float64:
						insertions[BackRepoFieldsDeclaration] += Replace2(
							BackRepoFieldSubTemplateCode[BackRepoDeclarationBasicField],
							"{{FieldName}}", gongBasicField.Name,
							"{{SqlNullType}}", "NullFloat64")

						insertions[BackRepoFieldsCommitNew] += Replace2(
							BackRepoFieldSubTemplateCode[BackRepoCommitBasicField],
							"{{FieldName}}", gongBasicField.Name,
							"{{SqlNullType}}", "Float64")

						insertions[BackRepoFieldsCheckoutNew] += Replace2(
							BackRepoFieldSubTemplateCode[BackRepoCheckoutBasicField],
							"{{FieldName}}", gongBasicField.Name,
							"{{SqlNullType}}", "Float64")
					case types.Int, types.Int64:
						insertions[BackRepoFieldsDeclaration] += Replace2(
							BackRepoFieldSubTemplateCode[BackRepoDeclarationBasicField],
							"{{FieldName}}", gongBasicField.Name,
							"{{SqlNullType}}", "NullInt64")

						insertions[BackRepoFieldsCommitNew] += Replace1(
							BackRepoFieldSubTemplateCode[BackRepoCommitBasicFieldInt],
							"{{FieldName}}", gongBasicField.Name)

						insertions[BackRepoFieldsCheckoutNew] += Replace2(
							BackRepoFieldSubTemplateCode[BackRepoCheckoutBasicFieldInt],
							"{{FieldName}}", gongBasicField.Name,
							"{{FieldType}}", gongBasicField.DeclaredType)
					default:
					}
				}

			case *GongTimeField:
				gongTimeField := field.(*GongTimeField)
				insertions[BackRepoFieldsDeclaration] += Replace1(
					BackRepoFieldSubTemplateCode[BackRepoDeclarationTimeField],
					"{{FieldName}}", gongTimeField.Name)

				insertions[BackRepoFieldsCheckoutNew] += Replace1(
					BackRepoFieldSubTemplateCode[BackRepoCheckoutTimeField],
					"{{FieldName}}", gongTimeField.Name)

				insertions[BackRepoFieldsCommitNew] += Replace1(
					BackRepoFieldSubTemplateCode[BackRepoCommitTimeField],
					"{{FieldName}}", gongTimeField.Name)

			case *PointerToGongStructField:
				modelPointerToStruct := field.(*PointerToGongStructField)

				insertions[BackRepoFieldsDeclaration] += Replace1(
					BackRepoFieldSubTemplateCode[BackRepoDeclarationPointerToStructField],
					"{{FieldName}}", modelPointerToStruct.Name)

				insertions[BackRepoFieldsCommitNew] += Replace3(
					BackRepoFieldSubTemplateCode[BackRepoCommitNewPointerToStructField],
					"{{AssociationStructName}}", modelPointerToStruct.GongStruct.Name,
					"{{associationStructName}}", strings.ToLower(modelPointerToStruct.GongStruct.Name),
					"{{FieldName}}", modelPointerToStruct.Name)

				insertions[BackRepoFieldsCheckoutNew] += Replace3(
					BackRepoFieldSubTemplateCode[BackRepoCheckoutNewPointerToStructStageField],
					"{{AssociationStructName}}", modelPointerToStruct.GongStruct.Name,
					"{{associationStructName}}", strings.ToLower(modelPointerToStruct.GongStruct.Name),
					"{{FieldName}}", modelPointerToStruct.Name)

			case *SliceOfPointerToGongStructField:
				fieldSliceOfPointerToModel := field.(*SliceOfPointerToGongStructField)

				insertions[BackRepoFieldsCommitNew] += Replace3(
					BackRepoFieldSubTemplateCode[BackRepoCommitNewSliceOfPointerToStructField],
					"{{AssociationStructName}}", fieldSliceOfPointerToModel.GongStruct.Name,
					"{{associationStructName}}", strings.ToLower(fieldSliceOfPointerToModel.GongStruct.Name),
					"{{FieldName}}", fieldSliceOfPointerToModel.Name)

				insertions[BackRepoFieldsCheckoutNew] += Replace3(
					BackRepoFieldSubTemplateCode[BackRepoCheckoutNewSliceOfPointerToStructStageField],
					"{{AssociationStructName}}", fieldSliceOfPointerToModel.GongStruct.Name,
					"{{associationStructName}}", strings.ToLower(fieldSliceOfPointerToModel.GongStruct.Name),
					"{{FieldName}}", fieldSliceOfPointerToModel.Name)
			}
		}

		//
		// Parse all fields from other structs that points to this struct
		//
		for _, __struct := range structList {
			for _, field := range __struct.Fields {
				switch field.(type) {
				case *SliceOfPointerToGongStructField:
					fieldSliceOfPointerToModel := field.(*SliceOfPointerToGongStructField)

					if fieldSliceOfPointerToModel.GongStruct == _struct {

						insertions[BackRepoFieldsDeclaration] += Replace2(
							BackRepoFieldSubTemplateCode[BackRepoDeclarationSliceOfPointerToStructField],
							"{{FieldName}}", fieldSliceOfPointerToModel.Name,
							"{{AssociationStructName}}", __struct.Name)
					}
				}
			}
		}

		// substitutes {{<<insertion points>>}} stuff with generated code
		for insertion := BackRepoInsertionPoint(0); insertion < BackRepoNbInsertionPoints; insertion++ {
			toReplace := "{{" + string(rune(insertion)) + "}}"
			codeGO = strings.ReplaceAll(codeGO, toReplace, insertions[insertion])
		}

		// substitutes struct level {{<...>}}Â stuff
		codeGO = Replace6(codeGO,
			"{{PkgName}}", pkgName,
			"{{TitlePkgName}}", strings.Title(pkgName),
			"{{pkgname}}", strings.ToLower(pkgName),
			"{{PkgPathRoot}}", strings.ReplaceAll(pkgGoPath, "/orm", ""),
			"{{Structname}}", _struct.Name,
			"{{structname}}", strings.ToLower(_struct.Name))

		file, err := os.Create(filepath.Join(dirPath, _struct.Name+"DB.go"))
		if err != nil {
			log.Panic(err)
		}
		defer file.Close()
		fmt.Fprint(file, codeGO)

	}
}
