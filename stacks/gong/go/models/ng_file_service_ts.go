package models

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const NgServiceTmpl = `// generated by MultiCodeGeneratorNgService
import { Injectable } from '@angular/core';
import { HttpClientModule } from '@angular/common/http';
import { HttpClient, HttpHeaders } from '@angular/common/http';

/*
 * Behavior subject
 */
import { BehaviorSubject } from 'rxjs';
import { Observable, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';

import { {{Structname}}API } from './{{structname}}-api';
import { {{Structname}}DB } from './{{structname}}-db';

@Injectable({
  providedIn: 'root'
})
export class {{Structname}}Service {

  httpOptions = {
    headers: new HttpHeaders({ 'Content-Type': 'application/json' })
  };

  // Kamar Ra√Ømo: Adding a way to communicate between components that share information
  // so that they are notified of a change.
  {{Structname}}ServiceChanged: BehaviorSubject<string> = new BehaviorSubject("");

  private {{structname}}sUrl = 'http://{{addr}}/{{PkgPathRoot}}/v1/{{structname}}s';

  constructor(
    private http: HttpClient
  ) { }

  /** GET {{structname}}s from the server */
  get{{Structname}}s(): Observable<{{Structname}}DB[]> {
    return this.http.get<{{Structname}}DB[]>(this.{{structname}}sUrl)
      .pipe(
        tap(_ => this.log('fetched {{structname}}s')),
        catchError(this.handleError<{{Structname}}DB[]>('get{{Structname}}s', []))
      );
  }

  /** GET {{structname}} by id. Will 404 if id not found */
  get{{Structname}}(id: number): Observable<{{Structname}}DB> {
    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;
    return this.http.get<{{Structname}}DB>(url).pipe(
      tap(_ => this.log(` + "`" + `fetched {{structname}} id=${id}` + "`" + `)),
      catchError(this.handleError<{{Structname}}DB>(` + "`" + `get{{Structname}} id=${id}` + "`" + `))
    );
  }

  //////// Save methods //////////

  /** POST: add a new {{structname}} to the server */
  post{{Structname}}({{structname}}API: {{Structname}}API): Observable<{{Structname}}DB> {
    return this.http.post<{{Structname}}DB>(this.{{structname}}sUrl, {{structname}}API, this.httpOptions).pipe(
      tap((new{{Structname}}: {{Structname}}DB) => {})
    );
  }

  /** DELETE: delete the {{structname}}db from the server */
  delete{{Structname}}({{structname}}db: {{Structname}}DB | number): Observable<{{Structname}}DB> {
    const id = typeof {{structname}}db === 'number' ? {{structname}}db : {{structname}}db.ID;
    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;

    return this.http.delete<{{Structname}}DB>(url, this.httpOptions).pipe(
      tap(_ => this.log(` + "`" + `deleted {{structname}}db id=${id}` + "`" + `)),
      catchError(this.handleError<{{Structname}}DB>('delete{{Structname}}'))
    );
  }

  /** PUT: update the {{structname}}db on the server */
  update{{Structname}}({{structname}}db: {{Structname}}DB): Observable<{{Structname}}DB> {
    const id = typeof {{structname}}db === 'number' ? {{structname}}db : {{structname}}db.ID;
    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;

    // insertion point for reset of reverse pointers (to avoid circular JSON){{` + string(rune(NgServiceTsInsertionPointerReset)) + `}}

    return this.http.put(url, {{structname}}db, this.httpOptions).pipe(
      tap(_ => {
        // insertion point for restoration of reverse pointers{{` + string(rune(NgServiceTsInsertionPointerRestore)) + `}}
        this.log(` + "`" + `updated {{structname}}db id=${{{structname}}db.ID}` + "`" + `)
      }),
      catchError(this.handleError<{{Structname}}DB>('update{{Structname}}'))
    );
  }

  /**
   * Handle Http operation that failed.
   * Let the app continue.
   * @param operation - name of the operation that failed
   * @param result - optional value to return as the observable result
   */
  private handleError<T>(operation = 'operation', result?: T) {
    return (error: any): Observable<T> => {

      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead

      // TODO: better job of transforming error for user consumption
      this.log(` + "`" + `${operation} failed: ${error.message}` + "`" + `);

      // Let the app keep running by returning an empty result.
      return of(result as T);
    };
  }

  private log(message: string) {

  }
}
`

// Insertion points
// insertion points in the main template
type NgServiceTsInsertionPoint int

const (
	NgServiceTsInsertionPointerReset NgServiceTsInsertionPoint = iota
	NgServiceTsInsertionPointerRestore

	NgServiceTsInsertionsNb
)

type NgServiceSubTemplate int

const (
	NgServiceTSPointerToGongStructReset NgServiceSubTemplate = iota
	NgServiceTSSliceOfPointerToGongStructReset
	NgServiceTSSliceOfPointerToGongStructReversePointerReset
	NgServiceTSSliceOfPointerToGongStructReversePointerRestore
)

var NgServiceSubTemplateCode map[NgServiceSubTemplate]string = map[NgServiceSubTemplate]string{

	NgServiceTSPointerToGongStructReset: `
    {{structname}}db.{{FieldName}} = {}`,

	NgServiceTSSliceOfPointerToGongStructReset: `
    {{structname}}db.{{FieldName}} = []`,

	NgServiceTSSliceOfPointerToGongStructReversePointerReset: `
    let _{{AssocStructName}}_{{FieldName}}_reverse = {{structname}}db.{{AssocStructName}}_{{FieldName}}_reverse
    {{structname}}db.{{AssocStructName}}_{{FieldName}}_reverse = {}`,

	NgServiceTSSliceOfPointerToGongStructReversePointerRestore: `
        {{structname}}db.{{AssocStructName}}_{{FieldName}}_reverse = _{{AssocStructName}}_{{FieldName}}_reverse`,
}

// MultiCodeGeneratorNgService generates the code for the
// services
func MultiCodeGeneratorNgService(
	mdlPkg *ModelPkg,
	PkgName,
	MatTargetPath,
	PkgGoPath string,
	apiPath string) {

	// have alphabetical order generation
	structList := []*GongStruct{}
	for _, _struct := range mdlPkg.GongStructs {
		structList = append(structList, _struct)
	}
	sort.Slice(structList[:], func(i, j int) bool {
		return structList[i].Name < structList[j].Name
	})

	for _, _struct := range structList {

		// generate the typescript file
		codeTS := NgServiceTmpl

		codeTS = strings.ReplaceAll(codeTS, "{{addr}}", apiPath)

		TSinsertions := make(map[NgServiceTsInsertionPoint]string)
		for insertion := NgServiceTsInsertionPoint(0); insertion < NgServiceTsInsertionsNb; insertion++ {
			TSinsertions[insertion] = ""
		}

		for _, field := range _struct.Fields {
			switch field.(type) {
			case *PointerToGongStructField:
				modelPointerToStructField := field.(*PointerToGongStructField)
				_ = modelPointerToStructField

				TSinsertions[NgServiceTsInsertionPointerReset] +=
					Replace1(NgServiceSubTemplateCode[NgServiceTSPointerToGongStructReset],
						"{{FieldName}}", modelPointerToStructField.Name)

			case *SliceOfPointerToGongStructField:
				fieldSliceOfPointerToModel := field.(*SliceOfPointerToGongStructField)
				_ = fieldSliceOfPointerToModel

				TSinsertions[NgServiceTsInsertionPointerReset] +=
					Replace1(NgServiceSubTemplateCode[NgServiceTSSliceOfPointerToGongStructReset],
						"{{FieldName}}", fieldSliceOfPointerToModel.Name)
			}
		}

		//
		// Parse all fields from other structs that points to this struct
		//
		for _, __struct := range structList {
			for _, field := range __struct.Fields {
				switch field.(type) {
				case *SliceOfPointerToGongStructField:
					fieldSliceOfPointerToModel := field.(*SliceOfPointerToGongStructField)

					if fieldSliceOfPointerToModel.GongStruct == _struct {

						TSinsertions[NgServiceTsInsertionPointerReset] +=
							Replace2(NgServiceSubTemplateCode[NgServiceTSSliceOfPointerToGongStructReversePointerReset],
								"{{FieldName}}", fieldSliceOfPointerToModel.Name,
								"{{AssocStructName}}", __struct.Name)

						TSinsertions[NgServiceTsInsertionPointerRestore] +=
							Replace2(NgServiceSubTemplateCode[NgServiceTSSliceOfPointerToGongStructReversePointerRestore],
								"{{FieldName}}", fieldSliceOfPointerToModel.Name,
								"{{AssocStructName}}", __struct.Name)

					}
				}
			}
		}

		for insertion := NgServiceTsInsertionPoint(0); insertion < NgServiceTsInsertionsNb; insertion++ {
			toReplace := "{{" + string(rune(insertion)) + "}}"
			codeTS = strings.ReplaceAll(codeTS, toReplace, TSinsertions[insertion])
		}
		// final replacement
		codeTS = Replace6(codeTS,
			"{{PkgName}}", PkgName,
			"{{TitlePkgName}}", strings.Title(PkgName),
			"{{pkgname}}", strings.ToLower(PkgName),
			"{{PkgPathRoot}}", strings.ReplaceAll(PkgGoPath, "/models", ""),
			"{{Structname}}", _struct.Name,
			"{{structname}}", strings.ToLower(_struct.Name))

		{
			file, err := os.Create(filepath.Join(MatTargetPath, strings.ToLower(_struct.Name)+".service.ts"))
			if err != nil {
				log.Panic(err)
			}
			defer file.Close()
			fmt.Fprint(file, codeTS)
		}
	}
}
