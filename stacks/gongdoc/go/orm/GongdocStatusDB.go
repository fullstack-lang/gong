// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"errors"
	"fmt"
	"log"

	"github.com/fullstack-lang/gong/stacks/gongdoc/go/models"
	"github.com/jinzhu/gorm"
)

// dummy variable to have the import database/sql wihthout compile failure id no sql is used
var dummy_GongdocStatus sql.NullBool

// GongdocStatusAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model gongdocstatusAPI
type GongdocStatusAPI struct {
	models.GongdocStatus

	// insertion for fields declaration
	// Declation for basic field gongdocstatusDB.Name {{BasicKind}} (to be completed)
	Name_Data sql.NullString

	// Declation for basic field gongdocstatusDB.Status {{BasicKind}} (to be completed)
	Status_Data sql.NullString

	// Declation for basic field gongdocstatusDB.CommandCompletionDate {{BasicKind}} (to be completed)
	CommandCompletionDate_Data sql.NullString

	// end of insertion
}

// GongdocStatusDB describes a gongdocstatus in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model gongdocstatusDB
type GongdocStatusDB struct {
	gorm.Model

	GongdocStatusAPI
}

// GongdocStatusDBs arrays gongdocstatusDBs
// swagger:response gongdocstatusDBsResponse
type GongdocStatusDBs []GongdocStatusDB

// GongdocStatusDBResponse provides response
// swagger:response gongdocstatusDBResponse
type GongdocStatusDBResponse struct {
	GongdocStatusDB
}

type BackRepoGongdocStatusStruct struct {
	// stores GongdocStatusDB according to their gorm ID
	Map_GongdocStatusDBID_GongdocStatusDB *map[uint]*GongdocStatusDB

	// stores GongdocStatusDB ID according to GongdocStatus address
	Map_GongdocStatusPtr_GongdocStatusDBID *map[*models.GongdocStatus]uint

	// stores GongdocStatus according to their gorm ID
	Map_GongdocStatusDBID_GongdocStatusPtr *map[uint]*models.GongdocStatus

	db *gorm.DB
}

// BackRepoGongdocStatus.Init set up the BackRepo of the GongdocStatus
func (backRepoGongdocStatus *BackRepoGongdocStatusStruct) Init(db *gorm.DB) (Error error) {

	if backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusPtr != nil {
		err := errors.New("In Init, backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusPtr should be nil")
		return err
	}

	if backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusDB != nil {
		err := errors.New("In Init, backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusDB should be nil")
		return err
	}

	if backRepoGongdocStatus.Map_GongdocStatusPtr_GongdocStatusDBID != nil {
		err := errors.New("In Init, backRepoGongdocStatus.Map_GongdocStatusPtr_GongdocStatusDBID should be nil")
		return err
	}

	tmp := make(map[uint]*models.GongdocStatus, 0)
	backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusPtr = &tmp

	tmpDB := make(map[uint]*GongdocStatusDB, 0)
	backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusDB = &tmpDB

	tmpID := make(map[*models.GongdocStatus]uint, 0)
	backRepoGongdocStatus.Map_GongdocStatusPtr_GongdocStatusDBID = &tmpID

	backRepoGongdocStatus.db = db
	return
}

// BackRepoGongdocStatus.CommitPhaseOne commits all staged instances of GongdocStatus to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoGongdocStatus *BackRepoGongdocStatusStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for gongdocstatus := range stage.GongdocStatuss {
		backRepoGongdocStatus.CommitPhaseOneInstance(gongdocstatus)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, gongdocstatus := range *backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusPtr {
		if _, ok := stage.GongdocStatuss[gongdocstatus]; !ok {
			backRepoGongdocStatus.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoGongdocStatus.CommitDeleteInstance commits deletion of GongdocStatus to the BackRepo
func (backRepoGongdocStatus *BackRepoGongdocStatusStruct) CommitDeleteInstance(id uint) (Error error) {

	gongdocstatus := (*backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusPtr)[id]

	// gongdocstatus is not staged anymore, remove gongdocstatusDB
	gongdocstatusDB := (*backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusDB)[id]
	query := backRepoGongdocStatus.db.Unscoped().Delete(&gongdocstatusDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	delete((*backRepoGongdocStatus.Map_GongdocStatusPtr_GongdocStatusDBID), gongdocstatus)
	delete((*backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusPtr), id)
	delete((*backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusDB), id)

	return
}

// BackRepoGongdocStatus.CommitPhaseOneInstance commits gongdocstatus staged instances of GongdocStatus to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoGongdocStatus *BackRepoGongdocStatusStruct) CommitPhaseOneInstance(gongdocstatus *models.GongdocStatus) (Error error) {

	// check if the gongdocstatus is not commited yet
	if _, ok := (*backRepoGongdocStatus.Map_GongdocStatusPtr_GongdocStatusDBID)[gongdocstatus]; ok {
		return
	}

	// initiate gongdocstatus
	var gongdocstatusDB GongdocStatusDB
	gongdocstatusDB.GongdocStatus = *gongdocstatus

	query := backRepoGongdocStatus.db.Create(&gongdocstatusDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*backRepoGongdocStatus.Map_GongdocStatusPtr_GongdocStatusDBID)[gongdocstatus] = gongdocstatusDB.ID
	(*backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusPtr)[gongdocstatusDB.ID] = gongdocstatus
	(*backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusDB)[gongdocstatusDB.ID] = &gongdocstatusDB

	return
}

// BackRepoGongdocStatus.CommitPhaseTwo commits all staged instances of GongdocStatus to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoGongdocStatus *BackRepoGongdocStatusStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, gongdocstatus := range *backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusPtr {
		backRepoGongdocStatus.CommitPhaseTwoInstance(backRepo, idx, gongdocstatus)
	}

	return
}

// BackRepoGongdocStatus.CommitPhaseTwoInstance commits {{structname }} of models.GongdocStatus to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoGongdocStatus *BackRepoGongdocStatusStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, gongdocstatus *models.GongdocStatus) (Error error) {

	// fetch matching gongdocstatusDB
	if gongdocstatusDB, ok := (*backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusDB)[idx]; ok {

		{
			{
				// insertion point for fields commit
				gongdocstatusDB.Name_Data.String = gongdocstatus.Name
				gongdocstatusDB.Name_Data.Valid = true

				gongdocstatusDB.Status_Data.String = string(gongdocstatus.Status)
				gongdocstatusDB.Status_Data.Valid = true

				gongdocstatusDB.CommandCompletionDate_Data.String = gongdocstatus.CommandCompletionDate
				gongdocstatusDB.CommandCompletionDate_Data.Valid = true

			}
		}
		query := backRepoGongdocStatus.db.Save(&gongdocstatusDB)
		if query.Error != nil {
			return query.Error
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown GongdocStatus intance %s", gongdocstatus.Name))
		return err
	}

	return
}

// BackRepoGongdocStatus.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One is the creation of instance in the stage
//
// NOTE: the is supposed to have been reset before
//
func (backRepoGongdocStatus *BackRepoGongdocStatusStruct) CheckoutPhaseOne() (Error error) {

	gongdocstatusDBArray := make([]GongdocStatusDB, 0)
	query := backRepoGongdocStatus.db.Find(&gongdocstatusDBArray)
	if query.Error != nil {
		return query.Error
	}

	// copy orm objects to the the map
	for _, gongdocstatusDB := range gongdocstatusDBArray {
		backRepoGongdocStatus.CheckoutPhaseOneInstance(&gongdocstatusDB)
	}

	return
}

// CheckoutPhaseOneInstance takes a gongdocstatusDB that has been found in the DB, updates the backRepo and stages the
// models version of the gongdocstatusDB
func (backRepoGongdocStatus *BackRepoGongdocStatusStruct) CheckoutPhaseOneInstance(gongdocstatusDB *GongdocStatusDB) (Error error) {

	// if absent, create entries in the backRepoGongdocStatus maps.
	gongdocstatusWithNewFieldValues := gongdocstatusDB.GongdocStatus
	if _, ok := (*backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusPtr)[gongdocstatusDB.ID]; !ok {

		(*backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusPtr)[gongdocstatusDB.ID] = &gongdocstatusWithNewFieldValues
		(*backRepoGongdocStatus.Map_GongdocStatusPtr_GongdocStatusDBID)[&gongdocstatusWithNewFieldValues] = gongdocstatusDB.ID

		// append model store with the new element
		gongdocstatusWithNewFieldValues.Stage()
	}
	gongdocstatusDBWithNewFieldValues := *gongdocstatusDB
	(*backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusDB)[gongdocstatusDB.ID] = &gongdocstatusDBWithNewFieldValues

	return
}

// BackRepoGongdocStatus.CheckoutPhaseTwo Checkouts all staged instances of GongdocStatus to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoGongdocStatus *BackRepoGongdocStatusStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, gongdocstatusDB := range *backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusDB {
		backRepoGongdocStatus.CheckoutPhaseTwoInstance(backRepo, gongdocstatusDB)
	}
	return
}

// BackRepoGongdocStatus.CheckoutPhaseTwoInstance Checkouts staged instances of GongdocStatus to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoGongdocStatus *BackRepoGongdocStatusStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, gongdocstatusDB *GongdocStatusDB) (Error error) {

	gongdocstatus := (*backRepoGongdocStatus.Map_GongdocStatusDBID_GongdocStatusPtr)[gongdocstatusDB.ID]
	_ = gongdocstatus // sometimes, there is no code generated. This lines voids the "unused variable" compilation error
	{
		{
			// insertion point for checkout, i.e. update of fields of stage instance from fields of back repo instances
			//
			gongdocstatus.Name = gongdocstatusDB.Name_Data.String

			gongdocstatus.Status = models.GongdocCommandType(gongdocstatusDB.Status_Data.String)

			gongdocstatus.CommandCompletionDate = gongdocstatusDB.CommandCompletionDate_Data.String

		}
	}
	return
}

// CommitGongdocStatus allows commit of a single gongdocstatus (if already staged)
func (backRepo *BackRepoStruct) CommitGongdocStatus(gongdocstatus *models.GongdocStatus) {
	backRepo.BackRepoGongdocStatus.CommitPhaseOneInstance(gongdocstatus)
	if id, ok := (*backRepo.BackRepoGongdocStatus.Map_GongdocStatusPtr_GongdocStatusDBID)[gongdocstatus]; ok {
		backRepo.BackRepoGongdocStatus.CommitPhaseTwoInstance(backRepo, id, gongdocstatus)
	}
}

// CommitGongdocStatus allows checkout of a single gongdocstatus (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutGongdocStatus(gongdocstatus *models.GongdocStatus) {
	// check if the gongdocstatus is staged
	if _, ok := (*backRepo.BackRepoGongdocStatus.Map_GongdocStatusPtr_GongdocStatusDBID)[gongdocstatus]; ok {

		if id, ok := (*backRepo.BackRepoGongdocStatus.Map_GongdocStatusPtr_GongdocStatusDBID)[gongdocstatus]; ok {
			var gongdocstatusDB GongdocStatusDB
			gongdocstatusDB.ID = id

			if err := backRepo.BackRepoGongdocStatus.db.First(&gongdocstatusDB, id).Error; err != nil {
				log.Panicln("CheckoutGongdocStatus : Problem with getting object with id:", id)
			}
			backRepo.BackRepoGongdocStatus.CheckoutPhaseOneInstance(&gongdocstatusDB)
			backRepo.BackRepoGongdocStatus.CheckoutPhaseTwoInstance(backRepo, &gongdocstatusDB)
		}
	}
}
