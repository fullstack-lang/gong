// generated by ModelGongFileTemplate
package models

import "sort"

// swagger:ignore
type __void struct{}

// needed for creating set of instances in the stage
var __member __void

// StageStruct enables storage of staged instances
// swagger:ignore
type StageStruct struct { // insertion point for definition of arrays registering instances
	Classdiagrams map[*Classdiagram]struct{}

	Classshapes map[*Classshape]struct{}

	Fields map[*Field]struct{}

	GongdocCommands map[*GongdocCommand]struct{}

	GongdocStatuss map[*GongdocStatus]struct{}

	Links map[*Link]struct{}

	Pkgelts map[*Pkgelt]struct{}

	Positions map[*Position]struct{}

	States map[*State]struct{}

	Umlscs map[*Umlsc]struct{}

	Vertices map[*Vertice]struct{}

	AllModelsStructCreateCallback AllModelsStructCreateInterface

	AllModelsStructDeleteCallback AllModelsStructDeleteInterface

	BackRepo BackRepoInterface
}

type BackRepoInterface interface {
	Commit(stage *StageStruct)
	Checkout(stage *StageStruct)
	// insertion point for Commit and Checkout signatures
	CommitClassdiagram(classdiagram *Classdiagram)
	CheckoutClassdiagram(classdiagram *Classdiagram)
	CommitClassshape(classshape *Classshape)
	CheckoutClassshape(classshape *Classshape)
	CommitField(field *Field)
	CheckoutField(field *Field)
	CommitGongdocCommand(gongdoccommand *GongdocCommand)
	CheckoutGongdocCommand(gongdoccommand *GongdocCommand)
	CommitGongdocStatus(gongdocstatus *GongdocStatus)
	CheckoutGongdocStatus(gongdocstatus *GongdocStatus)
	CommitLink(link *Link)
	CheckoutLink(link *Link)
	CommitPkgelt(pkgelt *Pkgelt)
	CheckoutPkgelt(pkgelt *Pkgelt)
	CommitPosition(position *Position)
	CheckoutPosition(position *Position)
	CommitState(state *State)
	CheckoutState(state *State)
	CommitUmlsc(umlsc *Umlsc)
	CheckoutUmlsc(umlsc *Umlsc)
	CommitVertice(vertice *Vertice)
	CheckoutVertice(vertice *Vertice)
	GetLastCommitNb() uint
}

// swagger:ignore instructs the gong compiler (gongc) to avoid this particular struct
var Stage StageStruct = StageStruct{ // insertion point for array initiatialisation
	Classdiagrams: make(map[*Classdiagram]struct{}, 0),

	Classshapes: make(map[*Classshape]struct{}, 0),

	Fields: make(map[*Field]struct{}, 0),

	GongdocCommands: make(map[*GongdocCommand]struct{}, 0),

	GongdocStatuss: make(map[*GongdocStatus]struct{}, 0),

	Links: make(map[*Link]struct{}, 0),

	Pkgelts: make(map[*Pkgelt]struct{}, 0),

	Positions: make(map[*Position]struct{}, 0),

	States: make(map[*State]struct{}, 0),

	Umlscs: make(map[*Umlsc]struct{}, 0),

	Vertices: make(map[*Vertice]struct{}, 0),

}

func (stage *StageStruct) Commit() {
	if stage.BackRepo != nil {
		stage.BackRepo.Commit(stage)
	}
}

func (stage *StageStruct) Checkout() {
	if stage.BackRepo != nil {
		stage.BackRepo.Checkout(stage)
	}
}

// insertion point for cumulative sub template with model space calls
func (stage *StageStruct) getClassdiagramOrderedStructWithNameField() []*Classdiagram {
	// have alphabetical order generation
	classdiagramOrdered := []*Classdiagram{}
	for classdiagram := range stage.Classdiagrams {
		classdiagramOrdered = append(classdiagramOrdered, classdiagram)
	}
	sort.Slice(classdiagramOrdered[:], func(i, j int) bool {
		return classdiagramOrdered[i].Name < classdiagramOrdered[j].Name
	})
	return classdiagramOrdered
}

// Stage puts classdiagram to the model stage
func (classdiagram *Classdiagram) Stage() *Classdiagram {
	Stage.Classdiagrams[classdiagram] = __member
	return classdiagram
}

// Unstage removes classdiagram off the model stage
func (classdiagram *Classdiagram) Unstage() *Classdiagram {
	delete(Stage.Classdiagrams, classdiagram)
	return classdiagram
}

// commit classdiagram to the back repo (if it is already staged)
func (classdiagram *Classdiagram) Commit() *Classdiagram {
	if _, ok := Stage.Classdiagrams[classdiagram]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitClassdiagram(classdiagram)
		}
	}
	return classdiagram
}

// Checkout classdiagram to the back repo (if it is already staged)
func (classdiagram *Classdiagram) Checkout() *Classdiagram {
	if _, ok := Stage.Classdiagrams[classdiagram]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutClassdiagram(classdiagram)
		}
	}
	return classdiagram
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of classdiagram to the model stage
func (classdiagram *Classdiagram) StageCopy() *Classdiagram {
	_classdiagram := new(Classdiagram)
	*_classdiagram = *classdiagram
	_classdiagram.Stage()
	return _classdiagram
}

// StageAndCommit appends classdiagram to the model stage and commit to the orm repo
func (classdiagram *Classdiagram) StageAndCommit() *Classdiagram {
	classdiagram.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassdiagram(classdiagram)
	}
	return classdiagram
}

// DeleteStageAndCommit appends classdiagram to the model stage and commit to the orm repo
func (classdiagram *Classdiagram) DeleteStageAndCommit() *Classdiagram {
	classdiagram.Unstage()
	DeleteORMClassdiagram(classdiagram)
	return classdiagram
}

// StageCopyAndCommit appends a copy of classdiagram to the model stage and commit to the orm repo
func (classdiagram *Classdiagram) StageCopyAndCommit() *Classdiagram {
	_classdiagram := new(Classdiagram)
	*_classdiagram = *classdiagram
	_classdiagram.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassdiagram(classdiagram)
	}
	return _classdiagram
}

// CreateORMClassdiagram enables dynamic staging of a Classdiagram instance
func CreateORMClassdiagram(classdiagram *Classdiagram) {
	classdiagram.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassdiagram(classdiagram)
	}
}

// DeleteORMClassdiagram enables dynamic staging of a Classdiagram instance
func DeleteORMClassdiagram(classdiagram *Classdiagram) {
	classdiagram.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMClassdiagram(classdiagram)
	}
}

func (stage *StageStruct) getClassshapeOrderedStructWithNameField() []*Classshape {
	// have alphabetical order generation
	classshapeOrdered := []*Classshape{}
	for classshape := range stage.Classshapes {
		classshapeOrdered = append(classshapeOrdered, classshape)
	}
	sort.Slice(classshapeOrdered[:], func(i, j int) bool {
		return classshapeOrdered[i].Name < classshapeOrdered[j].Name
	})
	return classshapeOrdered
}

// Stage puts classshape to the model stage
func (classshape *Classshape) Stage() *Classshape {
	Stage.Classshapes[classshape] = __member
	return classshape
}

// Unstage removes classshape off the model stage
func (classshape *Classshape) Unstage() *Classshape {
	delete(Stage.Classshapes, classshape)
	return classshape
}

// commit classshape to the back repo (if it is already staged)
func (classshape *Classshape) Commit() *Classshape {
	if _, ok := Stage.Classshapes[classshape]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitClassshape(classshape)
		}
	}
	return classshape
}

// Checkout classshape to the back repo (if it is already staged)
func (classshape *Classshape) Checkout() *Classshape {
	if _, ok := Stage.Classshapes[classshape]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutClassshape(classshape)
		}
	}
	return classshape
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of classshape to the model stage
func (classshape *Classshape) StageCopy() *Classshape {
	_classshape := new(Classshape)
	*_classshape = *classshape
	_classshape.Stage()
	return _classshape
}

// StageAndCommit appends classshape to the model stage and commit to the orm repo
func (classshape *Classshape) StageAndCommit() *Classshape {
	classshape.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassshape(classshape)
	}
	return classshape
}

// DeleteStageAndCommit appends classshape to the model stage and commit to the orm repo
func (classshape *Classshape) DeleteStageAndCommit() *Classshape {
	classshape.Unstage()
	DeleteORMClassshape(classshape)
	return classshape
}

// StageCopyAndCommit appends a copy of classshape to the model stage and commit to the orm repo
func (classshape *Classshape) StageCopyAndCommit() *Classshape {
	_classshape := new(Classshape)
	*_classshape = *classshape
	_classshape.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassshape(classshape)
	}
	return _classshape
}

// CreateORMClassshape enables dynamic staging of a Classshape instance
func CreateORMClassshape(classshape *Classshape) {
	classshape.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassshape(classshape)
	}
}

// DeleteORMClassshape enables dynamic staging of a Classshape instance
func DeleteORMClassshape(classshape *Classshape) {
	classshape.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMClassshape(classshape)
	}
}

func (stage *StageStruct) getFieldOrderedStructWithNameField() []*Field {
	// have alphabetical order generation
	fieldOrdered := []*Field{}
	for field := range stage.Fields {
		fieldOrdered = append(fieldOrdered, field)
	}
	sort.Slice(fieldOrdered[:], func(i, j int) bool {
		return fieldOrdered[i].Name < fieldOrdered[j].Name
	})
	return fieldOrdered
}

// Stage puts field to the model stage
func (field *Field) Stage() *Field {
	Stage.Fields[field] = __member
	return field
}

// Unstage removes field off the model stage
func (field *Field) Unstage() *Field {
	delete(Stage.Fields, field)
	return field
}

// commit field to the back repo (if it is already staged)
func (field *Field) Commit() *Field {
	if _, ok := Stage.Fields[field]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitField(field)
		}
	}
	return field
}

// Checkout field to the back repo (if it is already staged)
func (field *Field) Checkout() *Field {
	if _, ok := Stage.Fields[field]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutField(field)
		}
	}
	return field
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of field to the model stage
func (field *Field) StageCopy() *Field {
	_field := new(Field)
	*_field = *field
	_field.Stage()
	return _field
}

// StageAndCommit appends field to the model stage and commit to the orm repo
func (field *Field) StageAndCommit() *Field {
	field.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMField(field)
	}
	return field
}

// DeleteStageAndCommit appends field to the model stage and commit to the orm repo
func (field *Field) DeleteStageAndCommit() *Field {
	field.Unstage()
	DeleteORMField(field)
	return field
}

// StageCopyAndCommit appends a copy of field to the model stage and commit to the orm repo
func (field *Field) StageCopyAndCommit() *Field {
	_field := new(Field)
	*_field = *field
	_field.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMField(field)
	}
	return _field
}

// CreateORMField enables dynamic staging of a Field instance
func CreateORMField(field *Field) {
	field.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMField(field)
	}
}

// DeleteORMField enables dynamic staging of a Field instance
func DeleteORMField(field *Field) {
	field.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMField(field)
	}
}

func (stage *StageStruct) getGongdocCommandOrderedStructWithNameField() []*GongdocCommand {
	// have alphabetical order generation
	gongdoccommandOrdered := []*GongdocCommand{}
	for gongdoccommand := range stage.GongdocCommands {
		gongdoccommandOrdered = append(gongdoccommandOrdered, gongdoccommand)
	}
	sort.Slice(gongdoccommandOrdered[:], func(i, j int) bool {
		return gongdoccommandOrdered[i].Name < gongdoccommandOrdered[j].Name
	})
	return gongdoccommandOrdered
}

// Stage puts gongdoccommand to the model stage
func (gongdoccommand *GongdocCommand) Stage() *GongdocCommand {
	Stage.GongdocCommands[gongdoccommand] = __member
	return gongdoccommand
}

// Unstage removes gongdoccommand off the model stage
func (gongdoccommand *GongdocCommand) Unstage() *GongdocCommand {
	delete(Stage.GongdocCommands, gongdoccommand)
	return gongdoccommand
}

// commit gongdoccommand to the back repo (if it is already staged)
func (gongdoccommand *GongdocCommand) Commit() *GongdocCommand {
	if _, ok := Stage.GongdocCommands[gongdoccommand]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitGongdocCommand(gongdoccommand)
		}
	}
	return gongdoccommand
}

// Checkout gongdoccommand to the back repo (if it is already staged)
func (gongdoccommand *GongdocCommand) Checkout() *GongdocCommand {
	if _, ok := Stage.GongdocCommands[gongdoccommand]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutGongdocCommand(gongdoccommand)
		}
	}
	return gongdoccommand
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of gongdoccommand to the model stage
func (gongdoccommand *GongdocCommand) StageCopy() *GongdocCommand {
	_gongdoccommand := new(GongdocCommand)
	*_gongdoccommand = *gongdoccommand
	_gongdoccommand.Stage()
	return _gongdoccommand
}

// StageAndCommit appends gongdoccommand to the model stage and commit to the orm repo
func (gongdoccommand *GongdocCommand) StageAndCommit() *GongdocCommand {
	gongdoccommand.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocCommand(gongdoccommand)
	}
	return gongdoccommand
}

// DeleteStageAndCommit appends gongdoccommand to the model stage and commit to the orm repo
func (gongdoccommand *GongdocCommand) DeleteStageAndCommit() *GongdocCommand {
	gongdoccommand.Unstage()
	DeleteORMGongdocCommand(gongdoccommand)
	return gongdoccommand
}

// StageCopyAndCommit appends a copy of gongdoccommand to the model stage and commit to the orm repo
func (gongdoccommand *GongdocCommand) StageCopyAndCommit() *GongdocCommand {
	_gongdoccommand := new(GongdocCommand)
	*_gongdoccommand = *gongdoccommand
	_gongdoccommand.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocCommand(gongdoccommand)
	}
	return _gongdoccommand
}

// CreateORMGongdocCommand enables dynamic staging of a GongdocCommand instance
func CreateORMGongdocCommand(gongdoccommand *GongdocCommand) {
	gongdoccommand.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocCommand(gongdoccommand)
	}
}

// DeleteORMGongdocCommand enables dynamic staging of a GongdocCommand instance
func DeleteORMGongdocCommand(gongdoccommand *GongdocCommand) {
	gongdoccommand.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMGongdocCommand(gongdoccommand)
	}
}

func (stage *StageStruct) getGongdocStatusOrderedStructWithNameField() []*GongdocStatus {
	// have alphabetical order generation
	gongdocstatusOrdered := []*GongdocStatus{}
	for gongdocstatus := range stage.GongdocStatuss {
		gongdocstatusOrdered = append(gongdocstatusOrdered, gongdocstatus)
	}
	sort.Slice(gongdocstatusOrdered[:], func(i, j int) bool {
		return gongdocstatusOrdered[i].Name < gongdocstatusOrdered[j].Name
	})
	return gongdocstatusOrdered
}

// Stage puts gongdocstatus to the model stage
func (gongdocstatus *GongdocStatus) Stage() *GongdocStatus {
	Stage.GongdocStatuss[gongdocstatus] = __member
	return gongdocstatus
}

// Unstage removes gongdocstatus off the model stage
func (gongdocstatus *GongdocStatus) Unstage() *GongdocStatus {
	delete(Stage.GongdocStatuss, gongdocstatus)
	return gongdocstatus
}

// commit gongdocstatus to the back repo (if it is already staged)
func (gongdocstatus *GongdocStatus) Commit() *GongdocStatus {
	if _, ok := Stage.GongdocStatuss[gongdocstatus]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitGongdocStatus(gongdocstatus)
		}
	}
	return gongdocstatus
}

// Checkout gongdocstatus to the back repo (if it is already staged)
func (gongdocstatus *GongdocStatus) Checkout() *GongdocStatus {
	if _, ok := Stage.GongdocStatuss[gongdocstatus]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutGongdocStatus(gongdocstatus)
		}
	}
	return gongdocstatus
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of gongdocstatus to the model stage
func (gongdocstatus *GongdocStatus) StageCopy() *GongdocStatus {
	_gongdocstatus := new(GongdocStatus)
	*_gongdocstatus = *gongdocstatus
	_gongdocstatus.Stage()
	return _gongdocstatus
}

// StageAndCommit appends gongdocstatus to the model stage and commit to the orm repo
func (gongdocstatus *GongdocStatus) StageAndCommit() *GongdocStatus {
	gongdocstatus.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocStatus(gongdocstatus)
	}
	return gongdocstatus
}

// DeleteStageAndCommit appends gongdocstatus to the model stage and commit to the orm repo
func (gongdocstatus *GongdocStatus) DeleteStageAndCommit() *GongdocStatus {
	gongdocstatus.Unstage()
	DeleteORMGongdocStatus(gongdocstatus)
	return gongdocstatus
}

// StageCopyAndCommit appends a copy of gongdocstatus to the model stage and commit to the orm repo
func (gongdocstatus *GongdocStatus) StageCopyAndCommit() *GongdocStatus {
	_gongdocstatus := new(GongdocStatus)
	*_gongdocstatus = *gongdocstatus
	_gongdocstatus.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocStatus(gongdocstatus)
	}
	return _gongdocstatus
}

// CreateORMGongdocStatus enables dynamic staging of a GongdocStatus instance
func CreateORMGongdocStatus(gongdocstatus *GongdocStatus) {
	gongdocstatus.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocStatus(gongdocstatus)
	}
}

// DeleteORMGongdocStatus enables dynamic staging of a GongdocStatus instance
func DeleteORMGongdocStatus(gongdocstatus *GongdocStatus) {
	gongdocstatus.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMGongdocStatus(gongdocstatus)
	}
}

func (stage *StageStruct) getLinkOrderedStructWithNameField() []*Link {
	// have alphabetical order generation
	linkOrdered := []*Link{}
	for link := range stage.Links {
		linkOrdered = append(linkOrdered, link)
	}
	sort.Slice(linkOrdered[:], func(i, j int) bool {
		return linkOrdered[i].Name < linkOrdered[j].Name
	})
	return linkOrdered
}

// Stage puts link to the model stage
func (link *Link) Stage() *Link {
	Stage.Links[link] = __member
	return link
}

// Unstage removes link off the model stage
func (link *Link) Unstage() *Link {
	delete(Stage.Links, link)
	return link
}

// commit link to the back repo (if it is already staged)
func (link *Link) Commit() *Link {
	if _, ok := Stage.Links[link]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitLink(link)
		}
	}
	return link
}

// Checkout link to the back repo (if it is already staged)
func (link *Link) Checkout() *Link {
	if _, ok := Stage.Links[link]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutLink(link)
		}
	}
	return link
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of link to the model stage
func (link *Link) StageCopy() *Link {
	_link := new(Link)
	*_link = *link
	_link.Stage()
	return _link
}

// StageAndCommit appends link to the model stage and commit to the orm repo
func (link *Link) StageAndCommit() *Link {
	link.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLink(link)
	}
	return link
}

// DeleteStageAndCommit appends link to the model stage and commit to the orm repo
func (link *Link) DeleteStageAndCommit() *Link {
	link.Unstage()
	DeleteORMLink(link)
	return link
}

// StageCopyAndCommit appends a copy of link to the model stage and commit to the orm repo
func (link *Link) StageCopyAndCommit() *Link {
	_link := new(Link)
	*_link = *link
	_link.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLink(link)
	}
	return _link
}

// CreateORMLink enables dynamic staging of a Link instance
func CreateORMLink(link *Link) {
	link.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLink(link)
	}
}

// DeleteORMLink enables dynamic staging of a Link instance
func DeleteORMLink(link *Link) {
	link.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMLink(link)
	}
}

func (stage *StageStruct) getPkgeltOrderedStructWithNameField() []*Pkgelt {
	// have alphabetical order generation
	pkgeltOrdered := []*Pkgelt{}
	for pkgelt := range stage.Pkgelts {
		pkgeltOrdered = append(pkgeltOrdered, pkgelt)
	}
	sort.Slice(pkgeltOrdered[:], func(i, j int) bool {
		return pkgeltOrdered[i].Name < pkgeltOrdered[j].Name
	})
	return pkgeltOrdered
}

// Stage puts pkgelt to the model stage
func (pkgelt *Pkgelt) Stage() *Pkgelt {
	Stage.Pkgelts[pkgelt] = __member
	return pkgelt
}

// Unstage removes pkgelt off the model stage
func (pkgelt *Pkgelt) Unstage() *Pkgelt {
	delete(Stage.Pkgelts, pkgelt)
	return pkgelt
}

// commit pkgelt to the back repo (if it is already staged)
func (pkgelt *Pkgelt) Commit() *Pkgelt {
	if _, ok := Stage.Pkgelts[pkgelt]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitPkgelt(pkgelt)
		}
	}
	return pkgelt
}

// Checkout pkgelt to the back repo (if it is already staged)
func (pkgelt *Pkgelt) Checkout() *Pkgelt {
	if _, ok := Stage.Pkgelts[pkgelt]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutPkgelt(pkgelt)
		}
	}
	return pkgelt
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of pkgelt to the model stage
func (pkgelt *Pkgelt) StageCopy() *Pkgelt {
	_pkgelt := new(Pkgelt)
	*_pkgelt = *pkgelt
	_pkgelt.Stage()
	return _pkgelt
}

// StageAndCommit appends pkgelt to the model stage and commit to the orm repo
func (pkgelt *Pkgelt) StageAndCommit() *Pkgelt {
	pkgelt.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPkgelt(pkgelt)
	}
	return pkgelt
}

// DeleteStageAndCommit appends pkgelt to the model stage and commit to the orm repo
func (pkgelt *Pkgelt) DeleteStageAndCommit() *Pkgelt {
	pkgelt.Unstage()
	DeleteORMPkgelt(pkgelt)
	return pkgelt
}

// StageCopyAndCommit appends a copy of pkgelt to the model stage and commit to the orm repo
func (pkgelt *Pkgelt) StageCopyAndCommit() *Pkgelt {
	_pkgelt := new(Pkgelt)
	*_pkgelt = *pkgelt
	_pkgelt.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPkgelt(pkgelt)
	}
	return _pkgelt
}

// CreateORMPkgelt enables dynamic staging of a Pkgelt instance
func CreateORMPkgelt(pkgelt *Pkgelt) {
	pkgelt.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPkgelt(pkgelt)
	}
}

// DeleteORMPkgelt enables dynamic staging of a Pkgelt instance
func DeleteORMPkgelt(pkgelt *Pkgelt) {
	pkgelt.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMPkgelt(pkgelt)
	}
}

func (stage *StageStruct) getPositionOrderedStructWithNameField() []*Position {
	// have alphabetical order generation
	positionOrdered := []*Position{}
	for position := range stage.Positions {
		positionOrdered = append(positionOrdered, position)
	}
	sort.Slice(positionOrdered[:], func(i, j int) bool {
		return positionOrdered[i].Name < positionOrdered[j].Name
	})
	return positionOrdered
}

// Stage puts position to the model stage
func (position *Position) Stage() *Position {
	Stage.Positions[position] = __member
	return position
}

// Unstage removes position off the model stage
func (position *Position) Unstage() *Position {
	delete(Stage.Positions, position)
	return position
}

// commit position to the back repo (if it is already staged)
func (position *Position) Commit() *Position {
	if _, ok := Stage.Positions[position]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitPosition(position)
		}
	}
	return position
}

// Checkout position to the back repo (if it is already staged)
func (position *Position) Checkout() *Position {
	if _, ok := Stage.Positions[position]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutPosition(position)
		}
	}
	return position
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of position to the model stage
func (position *Position) StageCopy() *Position {
	_position := new(Position)
	*_position = *position
	_position.Stage()
	return _position
}

// StageAndCommit appends position to the model stage and commit to the orm repo
func (position *Position) StageAndCommit() *Position {
	position.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPosition(position)
	}
	return position
}

// DeleteStageAndCommit appends position to the model stage and commit to the orm repo
func (position *Position) DeleteStageAndCommit() *Position {
	position.Unstage()
	DeleteORMPosition(position)
	return position
}

// StageCopyAndCommit appends a copy of position to the model stage and commit to the orm repo
func (position *Position) StageCopyAndCommit() *Position {
	_position := new(Position)
	*_position = *position
	_position.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPosition(position)
	}
	return _position
}

// CreateORMPosition enables dynamic staging of a Position instance
func CreateORMPosition(position *Position) {
	position.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPosition(position)
	}
}

// DeleteORMPosition enables dynamic staging of a Position instance
func DeleteORMPosition(position *Position) {
	position.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMPosition(position)
	}
}

func (stage *StageStruct) getStateOrderedStructWithNameField() []*State {
	// have alphabetical order generation
	stateOrdered := []*State{}
	for state := range stage.States {
		stateOrdered = append(stateOrdered, state)
	}
	sort.Slice(stateOrdered[:], func(i, j int) bool {
		return stateOrdered[i].Name < stateOrdered[j].Name
	})
	return stateOrdered
}

// Stage puts state to the model stage
func (state *State) Stage() *State {
	Stage.States[state] = __member
	return state
}

// Unstage removes state off the model stage
func (state *State) Unstage() *State {
	delete(Stage.States, state)
	return state
}

// commit state to the back repo (if it is already staged)
func (state *State) Commit() *State {
	if _, ok := Stage.States[state]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitState(state)
		}
	}
	return state
}

// Checkout state to the back repo (if it is already staged)
func (state *State) Checkout() *State {
	if _, ok := Stage.States[state]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutState(state)
		}
	}
	return state
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of state to the model stage
func (state *State) StageCopy() *State {
	_state := new(State)
	*_state = *state
	_state.Stage()
	return _state
}

// StageAndCommit appends state to the model stage and commit to the orm repo
func (state *State) StageAndCommit() *State {
	state.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMState(state)
	}
	return state
}

// DeleteStageAndCommit appends state to the model stage and commit to the orm repo
func (state *State) DeleteStageAndCommit() *State {
	state.Unstage()
	DeleteORMState(state)
	return state
}

// StageCopyAndCommit appends a copy of state to the model stage and commit to the orm repo
func (state *State) StageCopyAndCommit() *State {
	_state := new(State)
	*_state = *state
	_state.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMState(state)
	}
	return _state
}

// CreateORMState enables dynamic staging of a State instance
func CreateORMState(state *State) {
	state.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMState(state)
	}
}

// DeleteORMState enables dynamic staging of a State instance
func DeleteORMState(state *State) {
	state.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMState(state)
	}
}

func (stage *StageStruct) getUmlscOrderedStructWithNameField() []*Umlsc {
	// have alphabetical order generation
	umlscOrdered := []*Umlsc{}
	for umlsc := range stage.Umlscs {
		umlscOrdered = append(umlscOrdered, umlsc)
	}
	sort.Slice(umlscOrdered[:], func(i, j int) bool {
		return umlscOrdered[i].Name < umlscOrdered[j].Name
	})
	return umlscOrdered
}

// Stage puts umlsc to the model stage
func (umlsc *Umlsc) Stage() *Umlsc {
	Stage.Umlscs[umlsc] = __member
	return umlsc
}

// Unstage removes umlsc off the model stage
func (umlsc *Umlsc) Unstage() *Umlsc {
	delete(Stage.Umlscs, umlsc)
	return umlsc
}

// commit umlsc to the back repo (if it is already staged)
func (umlsc *Umlsc) Commit() *Umlsc {
	if _, ok := Stage.Umlscs[umlsc]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitUmlsc(umlsc)
		}
	}
	return umlsc
}

// Checkout umlsc to the back repo (if it is already staged)
func (umlsc *Umlsc) Checkout() *Umlsc {
	if _, ok := Stage.Umlscs[umlsc]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutUmlsc(umlsc)
		}
	}
	return umlsc
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of umlsc to the model stage
func (umlsc *Umlsc) StageCopy() *Umlsc {
	_umlsc := new(Umlsc)
	*_umlsc = *umlsc
	_umlsc.Stage()
	return _umlsc
}

// StageAndCommit appends umlsc to the model stage and commit to the orm repo
func (umlsc *Umlsc) StageAndCommit() *Umlsc {
	umlsc.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlsc(umlsc)
	}
	return umlsc
}

// DeleteStageAndCommit appends umlsc to the model stage and commit to the orm repo
func (umlsc *Umlsc) DeleteStageAndCommit() *Umlsc {
	umlsc.Unstage()
	DeleteORMUmlsc(umlsc)
	return umlsc
}

// StageCopyAndCommit appends a copy of umlsc to the model stage and commit to the orm repo
func (umlsc *Umlsc) StageCopyAndCommit() *Umlsc {
	_umlsc := new(Umlsc)
	*_umlsc = *umlsc
	_umlsc.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlsc(umlsc)
	}
	return _umlsc
}

// CreateORMUmlsc enables dynamic staging of a Umlsc instance
func CreateORMUmlsc(umlsc *Umlsc) {
	umlsc.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlsc(umlsc)
	}
}

// DeleteORMUmlsc enables dynamic staging of a Umlsc instance
func DeleteORMUmlsc(umlsc *Umlsc) {
	umlsc.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMUmlsc(umlsc)
	}
}

func (stage *StageStruct) getVerticeOrderedStructWithNameField() []*Vertice {
	// have alphabetical order generation
	verticeOrdered := []*Vertice{}
	for vertice := range stage.Vertices {
		verticeOrdered = append(verticeOrdered, vertice)
	}
	sort.Slice(verticeOrdered[:], func(i, j int) bool {
		return verticeOrdered[i].Name < verticeOrdered[j].Name
	})
	return verticeOrdered
}

// Stage puts vertice to the model stage
func (vertice *Vertice) Stage() *Vertice {
	Stage.Vertices[vertice] = __member
	return vertice
}

// Unstage removes vertice off the model stage
func (vertice *Vertice) Unstage() *Vertice {
	delete(Stage.Vertices, vertice)
	return vertice
}

// commit vertice to the back repo (if it is already staged)
func (vertice *Vertice) Commit() *Vertice {
	if _, ok := Stage.Vertices[vertice]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitVertice(vertice)
		}
	}
	return vertice
}

// Checkout vertice to the back repo (if it is already staged)
func (vertice *Vertice) Checkout() *Vertice {
	if _, ok := Stage.Vertices[vertice]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutVertice(vertice)
		}
	}
	return vertice
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of vertice to the model stage
func (vertice *Vertice) StageCopy() *Vertice {
	_vertice := new(Vertice)
	*_vertice = *vertice
	_vertice.Stage()
	return _vertice
}

// StageAndCommit appends vertice to the model stage and commit to the orm repo
func (vertice *Vertice) StageAndCommit() *Vertice {
	vertice.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVertice(vertice)
	}
	return vertice
}

// DeleteStageAndCommit appends vertice to the model stage and commit to the orm repo
func (vertice *Vertice) DeleteStageAndCommit() *Vertice {
	vertice.Unstage()
	DeleteORMVertice(vertice)
	return vertice
}

// StageCopyAndCommit appends a copy of vertice to the model stage and commit to the orm repo
func (vertice *Vertice) StageCopyAndCommit() *Vertice {
	_vertice := new(Vertice)
	*_vertice = *vertice
	_vertice.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVertice(vertice)
	}
	return _vertice
}

// CreateORMVertice enables dynamic staging of a Vertice instance
func CreateORMVertice(vertice *Vertice) {
	vertice.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVertice(vertice)
	}
}

// DeleteORMVertice enables dynamic staging of a Vertice instance
func DeleteORMVertice(vertice *Vertice) {
	vertice.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMVertice(vertice)
	}
}

// swagger:ignore
type AllModelsStructCreateInterface interface { // insertion point for Callbacks on creation
	CreateORMClassdiagram(Classdiagram *Classdiagram)
	CreateORMClassshape(Classshape *Classshape)
	CreateORMField(Field *Field)
	CreateORMGongdocCommand(GongdocCommand *GongdocCommand)
	CreateORMGongdocStatus(GongdocStatus *GongdocStatus)
	CreateORMLink(Link *Link)
	CreateORMPkgelt(Pkgelt *Pkgelt)
	CreateORMPosition(Position *Position)
	CreateORMState(State *State)
	CreateORMUmlsc(Umlsc *Umlsc)
	CreateORMVertice(Vertice *Vertice)
}

type AllModelsStructDeleteInterface interface { // insertion point for Callbacks on deletion
	DeleteORMClassdiagram(Classdiagram *Classdiagram)
	DeleteORMClassshape(Classshape *Classshape)
	DeleteORMField(Field *Field)
	DeleteORMGongdocCommand(GongdocCommand *GongdocCommand)
	DeleteORMGongdocStatus(GongdocStatus *GongdocStatus)
	DeleteORMLink(Link *Link)
	DeleteORMPkgelt(Pkgelt *Pkgelt)
	DeleteORMPosition(Position *Position)
	DeleteORMState(State *State)
	DeleteORMUmlsc(Umlsc *Umlsc)
	DeleteORMVertice(Vertice *Vertice)
}

func (stage *StageStruct) Reset() { // insertion point for array reset
	stage.Classdiagrams = make(map[*Classdiagram]struct{}, 0)
	stage.Classshapes = make(map[*Classshape]struct{}, 0)
	stage.Fields = make(map[*Field]struct{}, 0)
	stage.GongdocCommands = make(map[*GongdocCommand]struct{}, 0)
	stage.GongdocStatuss = make(map[*GongdocStatus]struct{}, 0)
	stage.Links = make(map[*Link]struct{}, 0)
	stage.Pkgelts = make(map[*Pkgelt]struct{}, 0)
	stage.Positions = make(map[*Position]struct{}, 0)
	stage.States = make(map[*State]struct{}, 0)
	stage.Umlscs = make(map[*Umlsc]struct{}, 0)
	stage.Vertices = make(map[*Vertice]struct{}, 0)
}

func (stage *StageStruct) Nil() { // insertion point for array nil
	stage.Classdiagrams = nil
	stage.Classshapes = nil
	stage.Fields = nil
	stage.GongdocCommands = nil
	stage.GongdocStatuss = nil
	stage.Links = nil
	stage.Pkgelts = nil
	stage.Positions = nil
	stage.States = nil
	stage.Umlscs = nil
	stage.Vertices = nil
}
