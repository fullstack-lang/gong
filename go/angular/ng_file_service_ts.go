package angular

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/fullstack-lang/gong/go/models"
)

const NgServiceTmpl = `// generated by ng_file_service_ts
import { Injectable, Component, Inject } from '@angular/core';
import { HttpClientModule, HttpParams } from '@angular/common/http';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { DOCUMENT, Location } from '@angular/common'

/*
 * Behavior subject
 */
import { BehaviorSubject } from 'rxjs'
import { Observable, of } from 'rxjs'
import { catchError, map, tap } from 'rxjs/operators'

import { {{Structname}}DB } from './{{structname}}-db'
import { {{Structname}}, Copy{{Structname}}To{{Structname}}DB } from './{{structname}}'

import { FrontRepo, FrontRepoService } from './front-repo.service';

// insertion point for imports{{` + string(rune(NgServiceTsInsertionImports)) + `}}

@Injectable({
  providedIn: 'root'
})
export class {{Structname}}Service {

  // Kamar Ra√Ømo: Adding a way to communicate between components that share information
  // so that they are notified of a change.
  {{Structname}}ServiceChanged: BehaviorSubject<string> = new BehaviorSubject("");

  private {{structname}}sUrl: string

  constructor(
    private http: HttpClient,
    @Inject(DOCUMENT) private document: Document
  ) {
    // path to the service share the same origin with the path to the document
    // get the origin in the URL to the document
    let origin = this.document.location.origin

    // if debugging with ng, replace 4200 with 8080
    origin = origin.replace("4200", "8080")

    // compute path to the service
    this.{{structname}}sUrl = origin + '/api/{{PkgPathRoot}}/v1/{{structname}}s';
  }

  /** GET {{structname}}s from the server */
  // gets is more robust to refactoring
  gets(GONG__StackPath: string, frontRepo: FrontRepo): Observable<{{Structname}}DB[]> {
    return this.get{{Structname}}s(GONG__StackPath, frontRepo)
  }
  get{{Structname}}s(GONG__StackPath: string, frontRepo: FrontRepo): Observable<{{Structname}}DB[]> {

    let params = new HttpParams().set("GONG__StackPath", GONG__StackPath)

    return this.http.get<{{Structname}}DB[]>(this.{{structname}}sUrl, { params: params })
      .pipe(
        tap(),
        catchError(this.handleError<{{Structname}}DB[]>('get{{Structname}}s', []))
      );
  }

  /** GET {{structname}} by id. Will 404 if id not found */
  // more robust API to refactoring
  get(id: number, GONG__StackPath: string, frontRepo: FrontRepo): Observable<{{Structname}}DB> {
    return this.get{{Structname}}(id, GONG__StackPath, frontRepo)
  }
  get{{Structname}}(id: number, GONG__StackPath: string, frontRepo: FrontRepo): Observable<{{Structname}}DB> {

    let params = new HttpParams().set("GONG__StackPath", GONG__StackPath)

    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;
    return this.http.get<{{Structname}}DB>(url, { params: params }).pipe(
      // tap(_ => this.log(` + "`" + `fetched {{structname}} id=${id}` + "`" + `)),
      catchError(this.handleError<{{Structname}}DB>(` + "`" + `get{{Structname}} id=${id}` + "`" + `))
    );
  }

  /** POST: add a new {{structname}} to the server */
  post({{structname}}db: {{Structname}}DB, GONG__StackPath: string, frontRepo: FrontRepo): Observable<{{Structname}}DB> {
    return this.post{{Structname}}({{structname}}db, GONG__StackPath, frontRepo)
  }
  post{{Structname}}({{structname}}db: {{Structname}}DB, GONG__StackPath: string, frontRepo: FrontRepo): Observable<{{Structname}}DB> {

    // insertion point for reset of pointers and reverse pointers (to avoid circular JSON){{` + string(rune(NgServiceTsInsertionPointerEncoding)) + `}}

    let params = new HttpParams().set("GONG__StackPath", GONG__StackPath)
    let httpOptions = {
      headers: new HttpHeaders({ 'Content-Type': 'application/json' }),
      params: params
    }

    return this.http.post<{{Structname}}DB>(this.{{structname}}sUrl, {{structname}}db, httpOptions).pipe(
      tap(_ => {
        // insertion point for restoration of reverse pointers{{` + string(rune(NgServiceTsInsertionPointerDecoding)) + `}}
        // this.log(` + "`" + `posted {{structname}}db id=${{{structname}}db.ID}` + "`" + `)
      }),
      catchError(this.handleError<{{Structname}}DB>('post{{Structname}}'))
    );
  }

  /** DELETE: delete the {{structname}}db from the server */
  delete({{structname}}db: {{Structname}}DB | number, GONG__StackPath: string): Observable<{{Structname}}DB> {
    return this.delete{{Structname}}({{structname}}db, GONG__StackPath)
  }
  delete{{Structname}}({{structname}}db: {{Structname}}DB | number, GONG__StackPath: string): Observable<{{Structname}}DB> {
    const id = typeof {{structname}}db === 'number' ? {{structname}}db : {{structname}}db.ID;
    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;

    let params = new HttpParams().set("GONG__StackPath", GONG__StackPath)
    let httpOptions = {
      headers: new HttpHeaders({ 'Content-Type': 'application/json' }),
      params: params
    };

    return this.http.delete<{{Structname}}DB>(url, httpOptions).pipe(
      tap(_ => this.log(` + "`" + `deleted {{structname}}db id=${id}` + "`" + `)),
      catchError(this.handleError<{{Structname}}DB>('delete{{Structname}}'))
    );
  }

  // updateFront copy {{structname}} to a version with encoded pointers and update to the back
  updateFront({{structname}}: {{Structname}}, GONG__StackPath: string): Observable<{{Structname}}DB> {
    let {{structname}}DB = new {{Structname}}DB
    Copy{{Structname}}To{{Structname}}DB({{structname}}, {{structname}}DB)
    const id = typeof {{structname}}DB === 'number' ? {{structname}}DB : {{structname}}DB.ID
    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;
    let params = new HttpParams().set("GONG__StackPath", GONG__StackPath)
    let httpOptions = {
      headers: new HttpHeaders({ 'Content-Type': 'application/json' }),
      params: params
    }

    return this.http.put<{{Structname}}DB>(url, {{structname}}DB, httpOptions).pipe(
      tap(_ => {
      }),
      catchError(this.handleError<{{Structname}}DB>('update{{Structname}}'))
    );
  }

  /** PUT: update the {{structname}}db on the server */
  update({{structname}}db: {{Structname}}DB, GONG__StackPath: string, frontRepo: FrontRepo): Observable<{{Structname}}DB> {
    return this.update{{Structname}}({{structname}}db, GONG__StackPath, frontRepo)
  }
  update{{Structname}}({{structname}}db: {{Structname}}DB, GONG__StackPath: string, frontRepo: FrontRepo): Observable<{{Structname}}DB> {
    const id = typeof {{structname}}db === 'number' ? {{structname}}db : {{structname}}db.ID;
    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;

    // insertion point for reset of pointers (to avoid circular JSON)
    // and encoding of pointers{{` + string(rune(NgServiceTsInsertionPointerEncoding)) + `}}

    let params = new HttpParams().set("GONG__StackPath", GONG__StackPath)
    let httpOptions = {
      headers: new HttpHeaders({ 'Content-Type': 'application/json' }),
      params: params
    };

    return this.http.put<{{Structname}}DB>(url, {{structname}}db, httpOptions).pipe(
      tap(_ => {
        // insertion point for restoration of reverse pointers{{` + string(rune(NgServiceTsInsertionPointerDecoding)) + `}}
        // this.log(` + "`" + `updated {{structname}}db id=${{{structname}}db.ID}` + "`" + `)
      }),
      catchError(this.handleError<{{Structname}}DB>('update{{Structname}}'))
    );
  }

  /**
   * Handle Http operation that failed.
   * Let the app continue.
   * @param operation - name of the operation that failed
   * @param result - optional value to return as the observable result
   */
  private handleError<T>(operation = 'operation in {{Structname}}Service', result?: T) {
    return (error: any): Observable<T> => {

      // TODO: send the error to remote logging infrastructure
      console.error("{{Structname}}Service" + error); // log to console instead

      // TODO: better job of transforming error for user consumption
      this.log(` + "`" + `${operation} failed: ${error.message}` + "`" + `);

      // Let the app keep running by returning an empty result.
      return of(result as T);
    };
  }

  private log(message: string) {
    console.log(message)
  }
}
`

// Insertion points
// insertion points in the main template
type NgServiceTsInsertionPoint int

const (
	NgServiceTsInsertionPointerEncoding NgServiceTsInsertionPoint = iota
	NgServiceTsInsertionPointerDecoding

	NgServiceTsInsertionImports

	NgServiceTsInsertionsNb
)

type NgServiceSubTemplate int

const (
	NgServiceTSPointerToGongStructImports NgServiceSubTemplate = iota
	NgServiceTSPointerToGongStructEncode
	NgServiceTSPointerToGongStructDecode

	NgServiceTSSliceOfPointerToGongStructEncode
	NgServiceTSSliceOfPointerToGongStructDecode
	NgServiceTSSliceOfPointerToGongStructReversePointerReset
	NgServiceTSSliceOfPointerToGongStructReversePointerRestore

	NgServiceTSReversePointerToSliceOfGongStructImports
)

var NgServiceSubTemplateCode map[NgServiceSubTemplate]string = map[NgServiceSubTemplate]string{

	NgServiceTSPointerToGongStructImports: `
import { {{AssocStructName}}DB } from './{{assocStructName}}-db'`,

	NgServiceTSPointerToGongStructEncode: `
    if ({{structname}}db.{{FieldName}} != undefined) {
      {{structname}}db.{{Structname}}PointersEncoding.{{FieldName}}ID.Int64 = {{structname}}db.{{FieldName}}.ID
      {{structname}}db.{{Structname}}PointersEncoding.{{FieldName}}ID.Valid = true
    }
    {{structname}}db.{{FieldName}} = undefined`,

	NgServiceTSPointerToGongStructDecode: `
        {{structname}}db.{{FieldName}} = frontRepo.{{AssocStructName}}s.get({{structname}}db.{{Structname}}PointersEncoding.{{FieldName}}ID.Int64)`,

	NgServiceTSSliceOfPointerToGongStructEncode: `
    {{structname}}db.{{Structname}}PointersEncoding.{{FieldName}} = []
    for (let _{{assocStructName}} of {{structname}}db.{{FieldName}}) {
      {{structname}}db.{{Structname}}PointersEncoding.{{FieldName}}.push(_{{assocStructName}}.ID)
    }
    {{structname}}db.{{FieldName}} = []`,

	NgServiceTSSliceOfPointerToGongStructDecode: `
        {{structname}}db.{{FieldName}} = new Array<{{AssocStructName}}DB>()
        for (let _id of {{structname}}db.{{Structname}}PointersEncoding.{{FieldName}}) {
          let _{{assocStructName}} = frontRepo.{{AssocStructName}}s.get(_id)
          if (_{{assocStructName}} != undefined) {
            {{structname}}db.{{FieldName}}.push(_{{assocStructName}}!)
          }
        }`,

	NgServiceTSSliceOfPointerToGongStructReversePointerReset: `
    let _{{AssocStructName}}_{{FieldName}}_reverse = {{structname}}db.{{Structname}}PointersEncoding.{{AssocStructName}}_{{FieldName}}_reverse
    {{structname}}db.{{Structname}}PointersEncoding.{{AssocStructName}}_{{FieldName}}_reverse = new {{AssocStructName}}DB`,

	NgServiceTSSliceOfPointerToGongStructReversePointerRestore: `
        {{structname}}db.{{Structname}}PointersEncoding.{{AssocStructName}}_{{FieldName}}_reverse = _{{AssocStructName}}_{{FieldName}}_reverse`,

	NgServiceTSReversePointerToSliceOfGongStructImports: `
import { {{AssocStructName}}DB } from './{{assocStructName}}-db'`,
}

// MultiCodeGeneratorNgService generates the code for the
// services
func MultiCodeGeneratorNgService(
	modelPkg *models.ModelPkg,
	apiPath string) {

	PkgName := modelPkg.Name
	MatTargetPath := modelPkg.NgDataLibrarySourceCodeDirectory
	PkgGoPath := modelPkg.PkgPath

	// have alphabetical order generation
	structList := []*models.GongStruct{}
	for _, _struct := range modelPkg.GongStructs {
		structList = append(structList, _struct)
	}
	sort.Slice(structList[:], func(i, j int) bool {
		return structList[i].Name < structList[j].Name
	})

	for _, _struct := range structList {

		if !_struct.HasNameField() || _struct.IsIgnoredForFront {
			continue
		}

		// generate the typescript file
		codeTS := NgServiceTmpl

		codeTS = strings.ReplaceAll(codeTS, "{{addr}}", apiPath)

		TSinsertions := make(map[NgServiceTsInsertionPoint]string)
		for insertion := NgServiceTsInsertionPoint(0); insertion < NgServiceTsInsertionsNb; insertion++ {
			TSinsertions[insertion] = ""
		}

		for _, field := range _struct.Fields {
			switch field := field.(type) {
			case *models.PointerToGongStructField:

				TSinsertions[NgServiceTsInsertionPointerEncoding] +=
					models.Replace2(NgServiceSubTemplateCode[NgServiceTSPointerToGongStructEncode],
						"{{FieldName}}", field.Name,
						"{{AssocStructName}}", field.GongStruct.Name)

				TSinsertions[NgServiceTsInsertionPointerDecoding] +=
					models.Replace3(NgServiceSubTemplateCode[NgServiceTSPointerToGongStructDecode],
						"{{FieldName}}", field.Name,
						"{{assocStructName}}", strings.ToLower(field.GongStruct.Name),
						"{{AssocStructName}}", field.GongStruct.Name)

				var importToInsert = models.Replace2(NgServiceSubTemplateCode[NgServiceTSPointerToGongStructImports],
					"{{AssocStructName}}", field.GongStruct.Name,
					"{{assocStructName}}", strings.ToLower(field.GongStruct.Name))

				// cannot insert twice the same import
				// or import twice the DB
				if !strings.Contains(TSinsertions[NgServiceTsInsertionImports], importToInsert) &&
					_struct.Name != field.GongStruct.Name {
					TSinsertions[NgServiceTsInsertionImports] += importToInsert
				}

			case *models.SliceOfPointerToGongStructField:

				var importToInsert = models.Replace2(NgServiceSubTemplateCode[NgServiceTSPointerToGongStructImports],
					"{{AssocStructName}}", field.GongStruct.Name,
					"{{assocStructName}}", strings.ToLower(field.GongStruct.Name))

				// cannot insert twice the same import
				// or import twice the DB
				if !strings.Contains(TSinsertions[NgServiceTsInsertionImports], importToInsert) &&
					_struct.Name != field.GongStruct.Name {
					TSinsertions[NgServiceTsInsertionImports] += importToInsert
				}

				TSinsertions[NgServiceTsInsertionPointerEncoding] +=
					models.Replace3(NgServiceSubTemplateCode[NgServiceTSSliceOfPointerToGongStructEncode],
						"{{AssocStructName}}", field.GongStruct.Name,
						"{{assocStructName}}", strings.ToLower(field.GongStruct.Name),
						"{{FieldName}}", field.Name)

				TSinsertions[NgServiceTsInsertionPointerDecoding] +=
					models.Replace3(NgServiceSubTemplateCode[NgServiceTSSliceOfPointerToGongStructDecode],
						"{{AssocStructName}}", field.GongStruct.Name,
						"{{assocStructName}}", strings.ToLower(field.GongStruct.Name),
						"{{FieldName}}", field.Name)
			}
		}

		for insertion := NgServiceTsInsertionPoint(0); insertion < NgServiceTsInsertionsNb; insertion++ {
			toReplace := "{{" + string(rune(insertion)) + "}}"
			codeTS = strings.ReplaceAll(codeTS, toReplace, TSinsertions[insertion])
		}
		// final replacement
		codeTS = models.Replace6(codeTS,
			"{{PkgName}}", PkgName,
			"{{TitlePkgName}}", strings.Title(PkgName),
			"{{pkgname}}", strings.ToLower(PkgName),
			"{{PkgPathRoot}}", strings.ReplaceAll(PkgGoPath, "/models", ""),
			"{{Structname}}", _struct.Name,
			"{{structname}}", strings.ToLower(_struct.Name))

		{
			file, err := os.Create(filepath.Join(MatTargetPath, strings.ToLower(_struct.Name)+".service.ts"))
			if err != nil {
				log.Panic(err)
			}
			defer file.Close()
			fmt.Fprint(file, codeTS)
		}
	}
}
