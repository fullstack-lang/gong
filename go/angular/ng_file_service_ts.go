package angular

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/fullstack-lang/gong/go/models"
)

const NgServiceTmpl = `// generated by ng_file_service_ts
import { Injectable, Component, Inject } from '@angular/core';
import { HttpClientModule, HttpParams } from '@angular/common/http';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { DOCUMENT, Location } from '@angular/common'

/*
 * Behavior subject
 */
import { BehaviorSubject } from 'rxjs';
import { Observable, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';

import { {{Structname}}DB } from './{{structname}}-db';

// insertion point for imports{{` + string(rune(NgServiceTsInsertionImports)) + `}}

@Injectable({
  providedIn: 'root'
})
export class {{Structname}}Service {

  // Kamar Ra√Ømo: Adding a way to communicate between components that share information
  // so that they are notified of a change.
  {{Structname}}ServiceChanged: BehaviorSubject<string> = new BehaviorSubject("");

  private {{structname}}sUrl: string

  constructor(
    private http: HttpClient,
    @Inject(DOCUMENT) private document: Document
  ) {
    // path to the service share the same origin with the path to the document
    // get the origin in the URL to the document
    let origin = this.document.location.origin

    // if debugging with ng, replace 4200 with 8080
    origin = origin.replace("4200", "8080")

    // compute path to the service
    this.{{structname}}sUrl = origin + '/api/{{PkgPathRoot}}/v1/{{structname}}s';
  }

  /** GET {{structname}}s from the server */
  // gets is more robust to refactoring
  gets(GONG__StackPath: string): Observable<{{Structname}}DB[]> {
    return this.get{{Structname}}s(GONG__StackPath)
  }
  get{{Structname}}s(GONG__StackPath: string): Observable<{{Structname}}DB[]> {

    let params = new HttpParams().set("GONG__StackPath", GONG__StackPath)

    return this.http.get<{{Structname}}DB[]>(this.{{structname}}sUrl, { params: params })
      .pipe(
        tap(),
		// tap(_ => this.log('fetched {{structname}}s')),
        catchError(this.handleError<{{Structname}}DB[]>('get{{Structname}}s', []))
      );
  }

  /** GET {{structname}} by id. Will 404 if id not found */
  // more robust API to refactoring
  get(id: number, GONG__StackPath: string): Observable<{{Structname}}DB> {
	return this.get{{Structname}}(id, GONG__StackPath)
  }
  get{{Structname}}(id: number, GONG__StackPath: string): Observable<{{Structname}}DB> {

    let params = new HttpParams().set("GONG__StackPath", GONG__StackPath)

    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;
    return this.http.get<{{Structname}}DB>(url, { params: params }).pipe(
      // tap(_ => this.log(` + "`" + `fetched {{structname}} id=${id}` + "`" + `)),
      catchError(this.handleError<{{Structname}}DB>(` + "`" + `get{{Structname}} id=${id}` + "`" + `))
    );
  }

  /** POST: add a new {{structname}} to the server */
  post({{structname}}db: {{Structname}}DB, GONG__StackPath: string): Observable<{{Structname}}DB> {
    return this.post{{Structname}}({{structname}}db, GONG__StackPath)	
  }
  post{{Structname}}({{structname}}db: {{Structname}}DB, GONG__StackPath: string): Observable<{{Structname}}DB> {

    // insertion point for reset of pointers and reverse pointers (to avoid circular JSON){{` + string(rune(NgServiceTsInsertionPointerReset)) + `}}

    let params = new HttpParams().set("GONG__StackPath", GONG__StackPath)
    let httpOptions = {
      headers: new HttpHeaders({ 'Content-Type': 'application/json' }),
      params: params
    }

    return this.http.post<{{Structname}}DB>(this.{{structname}}sUrl, {{structname}}db, httpOptions).pipe(
      tap(_ => {
        // insertion point for restoration of reverse pointers{{` + string(rune(NgServiceTsInsertionPointerRestore)) + `}}
        // this.log(` + "`" + `posted {{structname}}db id=${{{structname}}db.ID}` + "`" + `)
      }),
      catchError(this.handleError<{{Structname}}DB>('post{{Structname}}'))
    );
  }

  /** DELETE: delete the {{structname}}db from the server */
  delete({{structname}}db: {{Structname}}DB | number, GONG__StackPath: string): Observable<{{Structname}}DB> {
    return this.delete{{Structname}}({{structname}}db, GONG__StackPath)
  }
  delete{{Structname}}({{structname}}db: {{Structname}}DB | number, GONG__StackPath: string): Observable<{{Structname}}DB> {
    const id = typeof {{structname}}db === 'number' ? {{structname}}db : {{structname}}db.ID;
    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;

    let params = new HttpParams().set("GONG__StackPath", GONG__StackPath)
    let httpOptions = {
      headers: new HttpHeaders({ 'Content-Type': 'application/json' }),
      params: params
    };

    return this.http.delete<{{Structname}}DB>(url, httpOptions).pipe(
      tap(_ => this.log(` + "`" + `deleted {{structname}}db id=${id}` + "`" + `)),
      catchError(this.handleError<{{Structname}}DB>('delete{{Structname}}'))
    );
  }

  /** PUT: update the {{structname}}db on the server */
  update({{structname}}db: {{Structname}}DB, GONG__StackPath: string): Observable<{{Structname}}DB> {
    return this.update{{Structname}}({{structname}}db, GONG__StackPath)
  }
  update{{Structname}}({{structname}}db: {{Structname}}DB, GONG__StackPath: string): Observable<{{Structname}}DB> {
    const id = typeof {{structname}}db === 'number' ? {{structname}}db : {{structname}}db.ID;
    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;

    // insertion point for reset of pointers and reverse pointers (to avoid circular JSON){{` + string(rune(NgServiceTsInsertionPointerReset)) + `}}

    let params = new HttpParams().set("GONG__StackPath", GONG__StackPath)
    let httpOptions = {
      headers: new HttpHeaders({ 'Content-Type': 'application/json' }),
      params: params
    };

    return this.http.put<{{Structname}}DB>(url, {{structname}}db, httpOptions).pipe(
      tap(_ => {
        // insertion point for restoration of reverse pointers{{` + string(rune(NgServiceTsInsertionPointerRestore)) + `}}
        // this.log(` + "`" + `updated {{structname}}db id=${{{structname}}db.ID}` + "`" + `)
      }),
      catchError(this.handleError<{{Structname}}DB>('update{{Structname}}'))
    );
  }

  /**
   * Handle Http operation that failed.
   * Let the app continue.
   * @param operation - name of the operation that failed
   * @param result - optional value to return as the observable result
   */
  private handleError<T>(operation = 'operation in {{Structname}}Service', result?: T) {
    return (error: any): Observable<T> => {

      // TODO: send the error to remote logging infrastructure
      console.error("{{Structname}}Service" + error); // log to console instead

      // TODO: better job of transforming error for user consumption
      this.log(` + "`" + `${operation} failed: ${error.message}` + "`" + `);

      // Let the app keep running by returning an empty result.
      return of(result as T);
    };
  }

  private log(message: string) {
      console.log(message)
  }
}
`

// Insertion points
// insertion points in the main template
type NgServiceTsInsertionPoint int

const (
	NgServiceTsInsertionPointerReset NgServiceTsInsertionPoint = iota
	NgServiceTsInsertionPointerRestore

	NgServiceTsInsertionImports

	NgServiceTsInsertionsNb
)

type NgServiceSubTemplate int

const (
	NgServiceTSPointerToGongStructImports NgServiceSubTemplate = iota
	NgServiceTSPointerToGongStructReset

	NgServiceTSSliceOfPointerToGongStructReset
	NgServiceTSSliceOfPointerToGongStructRestore
	NgServiceTSSliceOfPointerToGongStructReversePointerReset
	NgServiceTSSliceOfPointerToGongStructReversePointerRestore

	NgServiceTSReversePointerToSliceOfGongStructImports
)

var NgServiceSubTemplateCode map[NgServiceSubTemplate]string = map[NgServiceSubTemplate]string{

	NgServiceTSPointerToGongStructImports: `
import { {{AssocStructName}}DB } from './{{assocStructName}}-db'`,

	NgServiceTSPointerToGongStructReset: `
    let {{FieldName}} = {{structname}}db.{{FieldName}}
    {{structname}}db.{{FieldName}} = new {{AssocStructName}}DB`,

	NgServiceTSSliceOfPointerToGongStructReset: `
    let {{FieldName}} = {{structname}}db.{{FieldName}}
    {{structname}}db.{{FieldName}} = []`,

	NgServiceTSSliceOfPointerToGongStructRestore: `
	      {{structname}}db.{{FieldName}} = {{FieldName}}`,

	NgServiceTSSliceOfPointerToGongStructReversePointerReset: `
    let _{{AssocStructName}}_{{FieldName}}_reverse = {{structname}}db.{{Structname}}PointersEncoding.{{AssocStructName}}_{{FieldName}}_reverse
    {{structname}}db.{{Structname}}PointersEncoding.{{AssocStructName}}_{{FieldName}}_reverse = new {{AssocStructName}}DB`,

	NgServiceTSSliceOfPointerToGongStructReversePointerRestore: `
        {{structname}}db.{{Structname}}PointersEncoding.{{AssocStructName}}_{{FieldName}}_reverse = _{{AssocStructName}}_{{FieldName}}_reverse`,

	NgServiceTSReversePointerToSliceOfGongStructImports: `
import { {{AssocStructName}}DB } from './{{assocStructName}}-db'`,
}

// MultiCodeGeneratorNgService generates the code for the
// services
func MultiCodeGeneratorNgService(
	mdlPkg *models.ModelPkg,
	PkgName,
	MatTargetPath,
	PkgGoPath string,
	apiPath string) {

	// have alphabetical order generation
	structList := []*models.GongStruct{}
	for _, _struct := range mdlPkg.GongStructs {
		structList = append(structList, _struct)
	}
	sort.Slice(structList[:], func(i, j int) bool {
		return structList[i].Name < structList[j].Name
	})

	for _, _struct := range structList {

		if !_struct.HasNameField() || _struct.IsIgnoredForFront {
			continue
		}

		// generate the typescript file
		codeTS := NgServiceTmpl

		codeTS = strings.ReplaceAll(codeTS, "{{addr}}", apiPath)

		TSinsertions := make(map[NgServiceTsInsertionPoint]string)
		for insertion := NgServiceTsInsertionPoint(0); insertion < NgServiceTsInsertionsNb; insertion++ {
			TSinsertions[insertion] = ""
		}

		for _, field := range _struct.Fields {
			switch field := field.(type) {
			case *models.PointerToGongStructField:

				TSinsertions[NgServiceTsInsertionPointerReset] +=
					models.Replace2(NgServiceSubTemplateCode[NgServiceTSPointerToGongStructReset],
						"{{FieldName}}", field.Name,
						"{{AssocStructName}}", field.GongStruct.Name)

				var importToInsert = models.Replace2(NgServiceSubTemplateCode[NgServiceTSPointerToGongStructImports],
					"{{AssocStructName}}", field.GongStruct.Name,
					"{{assocStructName}}", strings.ToLower(field.GongStruct.Name))

				// cannot insert twice the same import
				// or import twice the DB
				if !strings.Contains(TSinsertions[NgServiceTsInsertionImports], importToInsert) &&
					_struct.Name != field.GongStruct.Name {
					TSinsertions[NgServiceTsInsertionImports] += importToInsert
				}

			case *models.SliceOfPointerToGongStructField:

				TSinsertions[NgServiceTsInsertionPointerReset] +=
					models.Replace1(NgServiceSubTemplateCode[NgServiceTSSliceOfPointerToGongStructReset],
						"{{FieldName}}", field.Name)

				TSinsertions[NgServiceTsInsertionPointerRestore] +=
					models.Replace1(NgServiceSubTemplateCode[NgServiceTSSliceOfPointerToGongStructRestore],
						"{{FieldName}}", field.Name)
			}
		}

		//
		// Parse all fields from other structs that points to this struct
		//
		for _, __struct := range structList {
			for _, field := range __struct.Fields {
				switch field := field.(type) {
				case *models.SliceOfPointerToGongStructField:

					if field.GongStruct == _struct {

						TSinsertions[NgServiceTsInsertionPointerReset] +=
							models.Replace2(NgServiceSubTemplateCode[NgServiceTSSliceOfPointerToGongStructReversePointerReset],
								"{{FieldName}}", field.Name,
								"{{AssocStructName}}", __struct.Name)

						TSinsertions[NgServiceTsInsertionPointerRestore] +=
							models.Replace2(NgServiceSubTemplateCode[NgServiceTSSliceOfPointerToGongStructReversePointerRestore],
								"{{FieldName}}", field.Name,
								"{{AssocStructName}}", __struct.Name)

						var importToInsert = models.Replace2(NgServiceSubTemplateCode[NgServiceTSReversePointerToSliceOfGongStructImports],
							"{{AssocStructName}}", __struct.Name,
							"{{assocStructName}}", strings.ToLower(__struct.Name))

						// cannot insert twice the same import
						if !strings.Contains(TSinsertions[NgServiceTsInsertionImports], importToInsert) &&
							__struct.Name != _struct.Name {
							TSinsertions[NgServiceTsInsertionImports] += importToInsert
						}
					}
				}
			}
		}

		for insertion := NgServiceTsInsertionPoint(0); insertion < NgServiceTsInsertionsNb; insertion++ {
			toReplace := "{{" + string(rune(insertion)) + "}}"
			codeTS = strings.ReplaceAll(codeTS, toReplace, TSinsertions[insertion])
		}
		// final replacement
		codeTS = models.Replace6(codeTS,
			"{{PkgName}}", PkgName,
			"{{TitlePkgName}}", strings.Title(PkgName),
			"{{pkgname}}", strings.ToLower(PkgName),
			"{{PkgPathRoot}}", strings.ReplaceAll(PkgGoPath, "/models", ""),
			"{{Structname}}", _struct.Name,
			"{{structname}}", strings.ToLower(_struct.Name))

		{
			file, err := os.Create(filepath.Join(MatTargetPath, strings.ToLower(_struct.Name)+".service.ts"))
			if err != nil {
				log.Panic(err)
			}
			defer file.Close()
			fmt.Fprint(file, codeTS)
		}
	}
}
