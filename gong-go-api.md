- [Gong back-end API and the repository pattern](#gong-back-end-api-and-the-repository-pattern)
	- [Rationale](#rationale)
	- [Staging gongstruct instances](#staging-gongstruct-instances)
	- [Commiting a unit of work of the stage](#commiting-a-unit-of-work-of-the-stage)
	- [Initializing a gong stack](#initializing-a-gong-stack)

## Gong back-end API and the repository pattern

### Rationale

Gong is a programming language that is a subset of the go language. When compiled, a gong program generates additional go code. The original go code and the generated go code coexist in the back-end and are arranged in a software architecture. 

*Program written in gong can invoke functions on gong object (`Stage()` for instance) that are later generated by the gong compiler (in a `gong.go` file).  This can be a problem when this generated code is not yet present (the go compiler will fails and the go language server will pinpoint error). However, the gong compiler is robust to this kind of go compiler errors.*

The Gong back-end architecture is close to the *repository* design pattern (which includes the *unit of work*, another design pattern). Thanks to this architecture, a set of *staged* object (the "unit of work") can be persisted to a database (the "repository") with a single "check in" operation. Conversely, objects can be retrieved from the database with a single "check out" operation. Moreover, once persisted, objects can be CRUD via a REST API.

This architecture presents two advantages:
- since gong generates the code implementing the repository pattern, it insulates the programmer from the the complexity of database management (pointer encoding, instances management, null values, ...) and of REST API implementation.
- It leverages a mental model that is familiar to all programmer. Indeed, "Stage", "Unstage", "Check in" an "Check out" are not trivial operation to understand but they are part of the knowledge of all programmers when they use git, the *de facto* standard tool of configuration management.

To implement the *repository* pattern, Gong divides programming objects into three sets (**memory**, **stage** and  **backRepo**) that falls in two packages (`models` and `orm`). A third package, `controllers`, provides a REST API to the **back repo** objects.

### Staging gongstruct instances

The first set of `go` instance is the **memory** set. It lives in the `models` package. With gong, the `models` package is where manual coding takes places. The rest of the backend code is generated by `gongc`, the gong compiler.

The second set is the **stage** set, a subset of the **memory** set (this is where it follows the *repository* design pattern). As with *git*, the programmer *stages* instances (or *unstages* them) of the *memory* set.

To be staged, `go` instances have to be instances of a special kind of `go` struct called *gongstruct*. A *gongstruct* is an a exported `go` `struct` with a `Name` field.

```go
package models

// Aclass is an example of gongstruct
// It has two association to Bclass, another gong struct
// - a pointer (a 0..1 relationship), 
// - an array of pointers (a 0..N relationship)
type Aclass struct {
	Name string
	Associationtob *Bclass
	Anarrayofb []*Bclass
}

type Bclass struct {
	Name string
}
```

In the same package, *gongc* will generate a `gong.go` file, that includes the generated functions `Stage()` and `Unstage` functions for each gongstruct.

```go

// Stage puts aclass to the model stage
func (aclass *Aclass) Stage() *Aclass {
        ....
	return aclass
}

// Unstage removes aclass off the model stage
func (aclass *Aclass) Unstage() *Aclass {
	....
        return aclass
}
```

Calling `Stage()` to an instance is straightforward.

```go
        // stage bclass1 instance
	bclass1 := (&models.Bclass{Name: "B1"}).Stage()

	aclass1 := (&models.Aclass{
		Name:                "A1",
		Associationtob:      bclass1,
		Anarrayofb: []*models.Bclass{
			bclass1,
		},
	}).Stage()

       // aclass1 and bclass1 form a "unit of work"
```

Only *gongstruct* instances can be *staged* or *unstaged*. It is interesting to *stage* a *gongstruct* instance for different reasons:
  - if the instance need to be persisted in a database
  - if the instance need to be seen in the front end 

### Commiting a unit of work of the stage

`Commit()` to a set of object is performed on the `Stage` object (a generated singloton in the `models` package).

The `stage` object can also serves as a in-memory datastore in the `models` package.

```go
// for a set implementation in  golang
type __void struct{}
var __member __void

type StageStruct struct { 
	Aclasss           map[*Aclass]struct{} // set of Aclass instances
	Aclasss_mapString map[string]*Aclass // map of Aclass by their Name
	....
}

// Stage puts aclass to the model stage
func (aclass *Aclass) Stage() *Aclass {
	Stage.Aclasss[aclass] = __member
	Stage.Aclasss_mapString[aclass.Name] = aclass

	return aclass
}

// Unstage puts aclass off the model stage
func (aclass *Aclass) Unstage() *Aclass {
	delete(Stage.Aclasss, aclass)
	delete(Stage.Aclasss_mapString, aclass.Name)
	return aclass
}

func (stage *StageStruct) Commit() {
	....
}

func (stage *StageStruct) Checkout() {
	....
}

var Stage StageStruct = StageStruct{ 
	....
}
```

The third set is the **backRepo**, it contains sister instances of instances of the *stage* set. The sister instances in the backRepo differ from the staged instance in two ways that make them fit for storage in a database:
- basic field are of type `sql`
- pointer fields are encoded into basic fields. Therefore, they are without pointers (acronym WOP). 

The sister instances of the **backRepo** are instances in the `orm`package.

```go
package orm

type AclassDB struct {
	gorm.Model

	Name_Data sql.NullString

	// encoding of pointers
	AclassPointersEnconding
}

type AclassPointersEnconding struct {
	// field Associationtob is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	AssociationtobID sql.NullInt64
}
```

Notice that the *stage* can be checked-out from the `backRepo`.

When a commit is performed, the WOP sister is created and it is persisted in the database.

### Initializing a gong stack

First, on need to import all tree packages

```go
import (

	"github.com/fullstack-lang/gong/test/go/models"
	"github.com/fullstack-lang/gong/test/go/orm"
	"github.com/fullstack-lang/gong/test/go/controllers"
)
```

Then, the first element to init is the back repository. The back repo leverages the [gorm](https://gorm.io/index.html) framework, to manages persistance into [sqlite](https://www.sqlite.org), a database. 

If you do not need to persist into a file database, the API provides the path to the database. Notice that the database is migrated if the data model has been changed.

```go
	// setup GORM
	db := orm.SetupModels(false, "./test.db")
```

If you do not need to persist into a file, sqlite provides a in memory database.

```go
	// setup GORM
	db := orm.SetupModels(false, ":memory:")
```

This operation hooks the stage to the orm.