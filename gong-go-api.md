# Gong API

- [Gong back-end API and the repository pattern](#gong-back-end-api-and-the-repository-pattern)
    - [Rationale](#rationale)
    - [Staging gongstruct instances](#staging-gongstruct-instances)
    - [Commiting a unit of work of the stage](#commiting-a-unit-of-work-of-the-stage)
    - [Initializing a gong stack](#initializing-a-gong-stack)

## Gong back-end API and the repository pattern

### Rationale

Gong is a programming language that is a subset of the go language. When a go program is compiled by `gongc`, the gong compiler, additional go code is generated. The original go code and the generated go code coexist in the back-end and are arranged in a software architecture.

*Program written in gong can invoke functions on gong object (`Stage()` for instance) that will be generated later by the gong compiler (in the `gong.go` file for instance).  This can be a problem when this generated code is not yet present (the go compiler will fails and the go language server will pinpoint error). However, the gong compiler is robust to this kind of go compiler errors.*

The Gong back-end architecture is based on the *repository* design pattern (which includes the *unit of work*, another design pattern). With the *repository*, a set of *staged* objects (the "unit of work") can be persisted to a database (the "repository") with a single "check in" operation. Conversely, objects can be retrievedto the *Stage* from the database with a single "check out" operation.

Persisted objects can be CRUD via a REST API (also generated by gong).

This architecture presents two advantages:

- since `gongc` generates the code implementing the repository pattern, it insulates the programmer from the the complexity of database management and REST API implementation. Database management includes pointer encoding, instances management, null values encoding, data migration and REST API implementation includes GET/POST/UPDATE/DELETE implementation and generation of the open api 2.0 specification of the API.

- It leverages the "repository pattern", a mental model that is familiar to all programmers.  `Stage()`, `Unstage()`, `Checkin()` an `Checkout()` are not trivial operations but they are part of the knowledge of all programmers who **git**, the *de facto* standard tool of configuration management.

### Repostory pattern from the programmer perspective

To implement the *repository* pattern, Gong divides programming objects into three sets (**memory**, **stage** and  **backRepo**) that falls in two packages (`models` and `orm`). A third package, `controllers`, provides a REST API to the **back repo** objects.

### Staging gongstruct instances

The first set of `go` instance is the **memory** set. It lives in the `models` package. With gong, the `models` package is where manual coding takes places. The rest of the backend code is generated by `gongc`, the gong compiler.

The second set is the **stage** set, a subset of the **memory** set (this is where it follows the *repository* design pattern). As with *git*, the programmer *stages* instances (or *unstages* them) of the *memory* set.

To be staged, `go` instances have to be instances of a special kind of `go` struct called *gongstruct*. A *gongstruct* is an a exported `go` `struct` with a `Name` field.

```go
package models

// Astruct is an example of gongstruct
// It has two association to Bstruct, another gong struct
// - a pointer (a 0..1 relationship), 
// - an array of pointers (a 0..N relationship)
type Astruct struct {
    Name string
    Associationtob *Bstruct
    Anarrayofb []*Bstruct
}

type Bstruct struct {
    Name string
}
```

In the same package, *gongc* will generate a `gong.go` file, that includes the generated functions `Stage()` and `Unstage` functions for each gongstruct.

```go

// Stage puts astruct to the model stage
func (astruct *Astruct) Stage() *Astruct {
        ....
    return astruct
}

// Unstage removes astruct off the model stage
func (astruct *Astruct) Unstage() *Astruct {
    ....
        return astruct
}
```

Calling `Stage()` to an instance is straightforward.

```go
    // the following code stages bstruct1 and astruct1
    // bstruct1 is associated to astruct1
    // therefore, they form an unit of work that have to be commited together
    bstruct1 := (&models.Bstruct{Name: "B1"}).Stage()

    astruct1 := (&models.Astruct{
        Name:                "A1",
        Associationtob:      bstruct1,
        Anarrayofb: []*models.Bstruct{
            bstruct1,
        },
    }).Stage()
```

Only *gongstruct* instances can be *staged* or *unstaged*. It is interesting to *stage* a *gongstruct* instance for different reasons:

- if the instance need to be persisted in a database

- if the instance need to be seen in the front end via the REST API

### Commiting a unit of work of the stage

`Commit()` to a set of object is performed on the `Stage` object (a generated singloton in the `models` package).

The `stage` object can also serves as a in-memory datastore in the `models` package.

```go
// for a set implementation in  golang
type __void struct{}
var __member __void

type StageStruct struct { 
    Astructs           map[*Astruct]struct{} // set of Astruct instances
    Astructs_mapString map[string]*Astruct // map of Astruct by their Name
    ....
}

// Stage puts astruct to the model stage
func (astruct *Astruct) Stage() *Astruct {
    Stage.Astructs[astruct] = __member
    Stage.Astructs_mapString[astruct.Name] = astruct

    return astruct
}

// Unstage puts astruct off the model stage
func (astruct *Astruct) Unstage() *Astruct {
    delete(Stage.Astructs, astruct)
    delete(Stage.Astructs_mapString, astruct.Name)
    return astruct
}

func (stage *StageStruct) Commit() {
    ....
}

func (stage *StageStruct) Checkout() {
    ....
}

var Stage StageStruct = StageStruct{ 
    ....
}
```

The third set is the **backRepo**, it contains sister instances of instances of the *stage* set. The sister instances in the backRepo differ from the staged instance in two ways that make them fit for storage in a database:

- basic field are of type `sql`

- pointer fields are encoded into basic fields. Therefore, they are without pointers (acronym WOP).

The sister instances of the **backRepo** are instances in the `orm`package.

```go
package orm

type AstructDB struct {
    gorm.Model

    Name_Data sql.NullString

    // encoding of pointers
    AstructPointersEnconding
}

type AstructPointersEnconding struct {
    // field Associationtob is a pointer to another Struct (optional or 0..1)
    // This field is generated into another field to enable AS ONE association
    AssociationtobID sql.NullInt64
}
```

Notice that the *stage* can be checked-out from the `backRepo`.

When a commit is performed, the WOP sister is created and it is persisted in the database.

## Initializing a gong stack

### Imports the 3 packages

First, on need to import all tree packages

```go
import (

    "github.com/fullstack-lang/gong/test/go/models"
    "github.com/fullstack-lang/gong/test/go/orm"
    "github.com/fullstack-lang/gong/test/go/controllers"
)
```

Then, the first element to init is the back repository. The back repo leverages the [gorm](https://gorm.io/index.html) framework, to manages persistance into [sqlite](https://www.sqlite.org), a database.

If you do not need to persist into a file database, the API provides the path to the database. Notice that the database is migrated if the data model has been changed.

```go
    // setup GORM
    db := orm.SetupModels(false, "./test.db")
```

If you do not need to persist into a file, sqlite provides a in memory database.

```go
    // setup GORM
    db := orm.SetupModels(false, ":memory:")
```

This operation hooks the stage to the orm.

### Registring controllers

