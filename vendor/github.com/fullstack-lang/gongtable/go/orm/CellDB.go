// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gongtable/go/db"
	"github.com/fullstack-lang/gongtable/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_Cell_sql sql.NullBool
var dummy_Cell_time time.Duration
var dummy_Cell_sort sort.Float64Slice

// CellAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model cellAPI
type CellAPI struct {
	gorm.Model

	models.Cell_WOP

	// encoding of pointers
	// for API, it cannot be embedded
	CellPointersEncoding CellPointersEncoding
}

// CellPointersEncoding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type CellPointersEncoding struct {
	// insertion for pointer fields encoding declaration

	// field CellString is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	CellStringID sql.NullInt64

	// field CellFloat64 is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	CellFloat64ID sql.NullInt64

	// field CellInt is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	CellIntID sql.NullInt64

	// field CellBool is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	CellBoolID sql.NullInt64

	// field CellIcon is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	CellIconID sql.NullInt64
}

// CellDB describes a cell in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model cellDB
type CellDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field cellDB.Name
	Name_Data sql.NullString

	// encoding of pointers
	// for GORM serialization, it is necessary to embed to Pointer Encoding declaration
	CellPointersEncoding
}

// CellDBs arrays cellDBs
// swagger:response cellDBsResponse
type CellDBs []CellDB

// CellDBResponse provides response
// swagger:response cellDBResponse
type CellDBResponse struct {
	CellDB
}

// CellWOP is a Cell without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type CellWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`
	// insertion for WOP pointer fields
}

var Cell_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
}

type BackRepoCellStruct struct {
	// stores CellDB according to their gorm ID
	Map_CellDBID_CellDB map[uint]*CellDB

	// stores CellDB ID according to Cell address
	Map_CellPtr_CellDBID map[*models.Cell]uint

	// stores Cell according to their gorm ID
	Map_CellDBID_CellPtr map[uint]*models.Cell

	db db.DBInterface

	stage *models.StageStruct
}

func (backRepoCell *BackRepoCellStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoCell.stage
	return
}

func (backRepoCell *BackRepoCellStruct) GetDB() db.DBInterface {
	return backRepoCell.db
}

// GetCellDBFromCellPtr is a handy function to access the back repo instance from the stage instance
func (backRepoCell *BackRepoCellStruct) GetCellDBFromCellPtr(cell *models.Cell) (cellDB *CellDB) {
	id := backRepoCell.Map_CellPtr_CellDBID[cell]
	cellDB = backRepoCell.Map_CellDBID_CellDB[id]
	return
}

// BackRepoCell.CommitPhaseOne commits all staged instances of Cell to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoCell *BackRepoCellStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for cell := range stage.Cells {
		backRepoCell.CommitPhaseOneInstance(cell)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, cell := range backRepoCell.Map_CellDBID_CellPtr {
		if _, ok := stage.Cells[cell]; !ok {
			backRepoCell.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoCell.CommitDeleteInstance commits deletion of Cell to the BackRepo
func (backRepoCell *BackRepoCellStruct) CommitDeleteInstance(id uint) (Error error) {

	cell := backRepoCell.Map_CellDBID_CellPtr[id]

	// cell is not staged anymore, remove cellDB
	cellDB := backRepoCell.Map_CellDBID_CellDB[id]
	db, _ := backRepoCell.db.Unscoped()
	_, err := db.Delete(cellDB)
	if err != nil {
		log.Fatal(err)
	}

	// update stores
	delete(backRepoCell.Map_CellPtr_CellDBID, cell)
	delete(backRepoCell.Map_CellDBID_CellPtr, id)
	delete(backRepoCell.Map_CellDBID_CellDB, id)

	return
}

// BackRepoCell.CommitPhaseOneInstance commits cell staged instances of Cell to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoCell *BackRepoCellStruct) CommitPhaseOneInstance(cell *models.Cell) (Error error) {

	// check if the cell is not commited yet
	if _, ok := backRepoCell.Map_CellPtr_CellDBID[cell]; ok {
		return
	}

	// initiate cell
	var cellDB CellDB
	cellDB.CopyBasicFieldsFromCell(cell)

	_, err := backRepoCell.db.Create(&cellDB)
	if err != nil {
		log.Fatal(err)
	}

	// update stores
	backRepoCell.Map_CellPtr_CellDBID[cell] = cellDB.ID
	backRepoCell.Map_CellDBID_CellPtr[cellDB.ID] = cell
	backRepoCell.Map_CellDBID_CellDB[cellDB.ID] = &cellDB

	return
}

// BackRepoCell.CommitPhaseTwo commits all staged instances of Cell to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoCell *BackRepoCellStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, cell := range backRepoCell.Map_CellDBID_CellPtr {
		backRepoCell.CommitPhaseTwoInstance(backRepo, idx, cell)
	}

	return
}

// BackRepoCell.CommitPhaseTwoInstance commits {{structname }} of models.Cell to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoCell *BackRepoCellStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, cell *models.Cell) (Error error) {

	// fetch matching cellDB
	if cellDB, ok := backRepoCell.Map_CellDBID_CellDB[idx]; ok {

		cellDB.CopyBasicFieldsFromCell(cell)

		// insertion point for translating pointers encodings into actual pointers
		// commit pointer value cell.CellString translates to updating the cell.CellStringID
		cellDB.CellStringID.Valid = true // allow for a 0 value (nil association)
		if cell.CellString != nil {
			if CellStringId, ok := backRepo.BackRepoCellString.Map_CellStringPtr_CellStringDBID[cell.CellString]; ok {
				cellDB.CellStringID.Int64 = int64(CellStringId)
				cellDB.CellStringID.Valid = true
			}
		} else {
			cellDB.CellStringID.Int64 = 0
			cellDB.CellStringID.Valid = true
		}

		// commit pointer value cell.CellFloat64 translates to updating the cell.CellFloat64ID
		cellDB.CellFloat64ID.Valid = true // allow for a 0 value (nil association)
		if cell.CellFloat64 != nil {
			if CellFloat64Id, ok := backRepo.BackRepoCellFloat64.Map_CellFloat64Ptr_CellFloat64DBID[cell.CellFloat64]; ok {
				cellDB.CellFloat64ID.Int64 = int64(CellFloat64Id)
				cellDB.CellFloat64ID.Valid = true
			}
		} else {
			cellDB.CellFloat64ID.Int64 = 0
			cellDB.CellFloat64ID.Valid = true
		}

		// commit pointer value cell.CellInt translates to updating the cell.CellIntID
		cellDB.CellIntID.Valid = true // allow for a 0 value (nil association)
		if cell.CellInt != nil {
			if CellIntId, ok := backRepo.BackRepoCellInt.Map_CellIntPtr_CellIntDBID[cell.CellInt]; ok {
				cellDB.CellIntID.Int64 = int64(CellIntId)
				cellDB.CellIntID.Valid = true
			}
		} else {
			cellDB.CellIntID.Int64 = 0
			cellDB.CellIntID.Valid = true
		}

		// commit pointer value cell.CellBool translates to updating the cell.CellBoolID
		cellDB.CellBoolID.Valid = true // allow for a 0 value (nil association)
		if cell.CellBool != nil {
			if CellBoolId, ok := backRepo.BackRepoCellBoolean.Map_CellBooleanPtr_CellBooleanDBID[cell.CellBool]; ok {
				cellDB.CellBoolID.Int64 = int64(CellBoolId)
				cellDB.CellBoolID.Valid = true
			}
		} else {
			cellDB.CellBoolID.Int64 = 0
			cellDB.CellBoolID.Valid = true
		}

		// commit pointer value cell.CellIcon translates to updating the cell.CellIconID
		cellDB.CellIconID.Valid = true // allow for a 0 value (nil association)
		if cell.CellIcon != nil {
			if CellIconId, ok := backRepo.BackRepoCellIcon.Map_CellIconPtr_CellIconDBID[cell.CellIcon]; ok {
				cellDB.CellIconID.Int64 = int64(CellIconId)
				cellDB.CellIconID.Valid = true
			}
		} else {
			cellDB.CellIconID.Int64 = 0
			cellDB.CellIconID.Valid = true
		}

		_, err := backRepoCell.db.Save(cellDB)
		if err != nil {
			log.Fatal(err)
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Cell intance %s", cell.Name))
		return err
	}

	return
}

// BackRepoCell.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoCell *BackRepoCellStruct) CheckoutPhaseOne() (Error error) {

	cellDBArray := make([]CellDB, 0)
	_, err := backRepoCell.db.Find(&cellDBArray)
	if err != nil {
		return err
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	cellInstancesToBeRemovedFromTheStage := make(map[*models.Cell]any)
	for key, value := range backRepoCell.stage.Cells {
		cellInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, cellDB := range cellDBArray {
		backRepoCell.CheckoutPhaseOneInstance(&cellDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		cell, ok := backRepoCell.Map_CellDBID_CellPtr[cellDB.ID]
		if ok {
			delete(cellInstancesToBeRemovedFromTheStage, cell)
		}
	}

	// remove from stage and back repo's 3 maps all cells that are not in the checkout
	for cell := range cellInstancesToBeRemovedFromTheStage {
		cell.Unstage(backRepoCell.GetStage())

		// remove instance from the back repo 3 maps
		cellID := backRepoCell.Map_CellPtr_CellDBID[cell]
		delete(backRepoCell.Map_CellPtr_CellDBID, cell)
		delete(backRepoCell.Map_CellDBID_CellDB, cellID)
		delete(backRepoCell.Map_CellDBID_CellPtr, cellID)
	}

	return
}

// CheckoutPhaseOneInstance takes a cellDB that has been found in the DB, updates the backRepo and stages the
// models version of the cellDB
func (backRepoCell *BackRepoCellStruct) CheckoutPhaseOneInstance(cellDB *CellDB) (Error error) {

	cell, ok := backRepoCell.Map_CellDBID_CellPtr[cellDB.ID]
	if !ok {
		cell = new(models.Cell)

		backRepoCell.Map_CellDBID_CellPtr[cellDB.ID] = cell
		backRepoCell.Map_CellPtr_CellDBID[cell] = cellDB.ID

		// append model store with the new element
		cell.Name = cellDB.Name_Data.String
		cell.Stage(backRepoCell.GetStage())
	}
	cellDB.CopyBasicFieldsToCell(cell)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	cell.Stage(backRepoCell.GetStage())

	// preserve pointer to cellDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_CellDBID_CellDB)[cellDB hold variable pointers
	cellDB_Data := *cellDB
	preservedPtrToCell := &cellDB_Data
	backRepoCell.Map_CellDBID_CellDB[cellDB.ID] = preservedPtrToCell

	return
}

// BackRepoCell.CheckoutPhaseTwo Checkouts all staged instances of Cell to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoCell *BackRepoCellStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, cellDB := range backRepoCell.Map_CellDBID_CellDB {
		backRepoCell.CheckoutPhaseTwoInstance(backRepo, cellDB)
	}
	return
}

// BackRepoCell.CheckoutPhaseTwoInstance Checkouts staged instances of Cell to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoCell *BackRepoCellStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, cellDB *CellDB) (Error error) {

	cell := backRepoCell.Map_CellDBID_CellPtr[cellDB.ID]

	cellDB.DecodePointers(backRepo, cell)

	return
}

func (cellDB *CellDB) DecodePointers(backRepo *BackRepoStruct, cell *models.Cell) {

	// insertion point for checkout of pointer encoding
	// CellString field	
	{
		id := cellDB.CellStringID.Int64
		if id != 0 {
			tmp, ok := backRepo.BackRepoCellString.Map_CellStringDBID_CellStringPtr[uint(id)]

			// if the pointer id is unknown, it is not a problem, maybe the target was removed from the front
			if !ok {
				log.Println("DecodePointers: cell.CellString, unknown pointer id", id)
				cell.CellString = nil
			} else {
				// updates only if field has changed
				if cell.CellString == nil || cell.CellString != tmp {
					cell.CellString = tmp
				}
			}
		} else {
			cell.CellString = nil
		}
	}
	
	// CellFloat64 field	
	{
		id := cellDB.CellFloat64ID.Int64
		if id != 0 {
			tmp, ok := backRepo.BackRepoCellFloat64.Map_CellFloat64DBID_CellFloat64Ptr[uint(id)]

			// if the pointer id is unknown, it is not a problem, maybe the target was removed from the front
			if !ok {
				log.Println("DecodePointers: cell.CellFloat64, unknown pointer id", id)
				cell.CellFloat64 = nil
			} else {
				// updates only if field has changed
				if cell.CellFloat64 == nil || cell.CellFloat64 != tmp {
					cell.CellFloat64 = tmp
				}
			}
		} else {
			cell.CellFloat64 = nil
		}
	}
	
	// CellInt field	
	{
		id := cellDB.CellIntID.Int64
		if id != 0 {
			tmp, ok := backRepo.BackRepoCellInt.Map_CellIntDBID_CellIntPtr[uint(id)]

			// if the pointer id is unknown, it is not a problem, maybe the target was removed from the front
			if !ok {
				log.Println("DecodePointers: cell.CellInt, unknown pointer id", id)
				cell.CellInt = nil
			} else {
				// updates only if field has changed
				if cell.CellInt == nil || cell.CellInt != tmp {
					cell.CellInt = tmp
				}
			}
		} else {
			cell.CellInt = nil
		}
	}
	
	// CellBool field	
	{
		id := cellDB.CellBoolID.Int64
		if id != 0 {
			tmp, ok := backRepo.BackRepoCellBoolean.Map_CellBooleanDBID_CellBooleanPtr[uint(id)]

			// if the pointer id is unknown, it is not a problem, maybe the target was removed from the front
			if !ok {
				log.Println("DecodePointers: cell.CellBool, unknown pointer id", id)
				cell.CellBool = nil
			} else {
				// updates only if field has changed
				if cell.CellBool == nil || cell.CellBool != tmp {
					cell.CellBool = tmp
				}
			}
		} else {
			cell.CellBool = nil
		}
	}
	
	// CellIcon field	
	{
		id := cellDB.CellIconID.Int64
		if id != 0 {
			tmp, ok := backRepo.BackRepoCellIcon.Map_CellIconDBID_CellIconPtr[uint(id)]

			// if the pointer id is unknown, it is not a problem, maybe the target was removed from the front
			if !ok {
				log.Println("DecodePointers: cell.CellIcon, unknown pointer id", id)
				cell.CellIcon = nil
			} else {
				// updates only if field has changed
				if cell.CellIcon == nil || cell.CellIcon != tmp {
					cell.CellIcon = tmp
				}
			}
		} else {
			cell.CellIcon = nil
		}
	}
	
	return
}

// CommitCell allows commit of a single cell (if already staged)
func (backRepo *BackRepoStruct) CommitCell(cell *models.Cell) {
	backRepo.BackRepoCell.CommitPhaseOneInstance(cell)
	if id, ok := backRepo.BackRepoCell.Map_CellPtr_CellDBID[cell]; ok {
		backRepo.BackRepoCell.CommitPhaseTwoInstance(backRepo, id, cell)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitCell allows checkout of a single cell (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutCell(cell *models.Cell) {
	// check if the cell is staged
	if _, ok := backRepo.BackRepoCell.Map_CellPtr_CellDBID[cell]; ok {

		if id, ok := backRepo.BackRepoCell.Map_CellPtr_CellDBID[cell]; ok {
			var cellDB CellDB
			cellDB.ID = id

			if _, err := backRepo.BackRepoCell.db.First(&cellDB, id); err != nil {
				log.Fatalln("CheckoutCell : Problem with getting object with id:", id)
			}
			backRepo.BackRepoCell.CheckoutPhaseOneInstance(&cellDB)
			backRepo.BackRepoCell.CheckoutPhaseTwoInstance(backRepo, &cellDB)
		}
	}
}

// CopyBasicFieldsFromCell
func (cellDB *CellDB) CopyBasicFieldsFromCell(cell *models.Cell) {
	// insertion point for fields commit

	cellDB.Name_Data.String = cell.Name
	cellDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromCell_WOP
func (cellDB *CellDB) CopyBasicFieldsFromCell_WOP(cell *models.Cell_WOP) {
	// insertion point for fields commit

	cellDB.Name_Data.String = cell.Name
	cellDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromCellWOP
func (cellDB *CellDB) CopyBasicFieldsFromCellWOP(cell *CellWOP) {
	// insertion point for fields commit

	cellDB.Name_Data.String = cell.Name
	cellDB.Name_Data.Valid = true
}

// CopyBasicFieldsToCell
func (cellDB *CellDB) CopyBasicFieldsToCell(cell *models.Cell) {
	// insertion point for checkout of basic fields (back repo to stage)
	cell.Name = cellDB.Name_Data.String
}

// CopyBasicFieldsToCell_WOP
func (cellDB *CellDB) CopyBasicFieldsToCell_WOP(cell *models.Cell_WOP) {
	// insertion point for checkout of basic fields (back repo to stage)
	cell.Name = cellDB.Name_Data.String
}

// CopyBasicFieldsToCellWOP
func (cellDB *CellDB) CopyBasicFieldsToCellWOP(cell *CellWOP) {
	cell.ID = int(cellDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	cell.Name = cellDB.Name_Data.String
}

// Backup generates a json file from a slice of all CellDB instances in the backrepo
func (backRepoCell *BackRepoCellStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "CellDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*CellDB, 0)
	for _, cellDB := range backRepoCell.Map_CellDBID_CellDB {
		forBackup = append(forBackup, cellDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Fatal("Cannot json Cell ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Fatal("Cannot write the json Cell file", err.Error())
	}
}

// Backup generates a json file from a slice of all CellDB instances in the backrepo
func (backRepoCell *BackRepoCellStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*CellDB, 0)
	for _, cellDB := range backRepoCell.Map_CellDBID_CellDB {
		forBackup = append(forBackup, cellDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("Cell")
	if err != nil {
		log.Fatal("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&Cell_Fields, -1)
	for _, cellDB := range forBackup {

		var cellWOP CellWOP
		cellDB.CopyBasicFieldsToCellWOP(&cellWOP)

		row := sh.AddRow()
		row.WriteStruct(&cellWOP, -1)
	}
}

// RestoreXL from the "Cell" sheet all CellDB instances
func (backRepoCell *BackRepoCellStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoCellid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["Cell"]
	_ = sh
	if !ok {
		log.Fatal(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoCell.rowVisitorCell)
	if err != nil {
		log.Fatal("Err=", err)
	}
}

func (backRepoCell *BackRepoCellStruct) rowVisitorCell(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var cellWOP CellWOP
		row.ReadStruct(&cellWOP)

		// add the unmarshalled struct to the stage
		cellDB := new(CellDB)
		cellDB.CopyBasicFieldsFromCellWOP(&cellWOP)

		cellDB_ID_atBackupTime := cellDB.ID
		cellDB.ID = 0
		_, err := backRepoCell.db.Create(cellDB)
		if err != nil {
			log.Fatal(err)
		}
		backRepoCell.Map_CellDBID_CellDB[cellDB.ID] = cellDB
		BackRepoCellid_atBckpTime_newID[cellDB_ID_atBackupTime] = cellDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "CellDB.json" in dirPath that stores an array
// of CellDB and stores it in the database
// the map BackRepoCellid_atBckpTime_newID is updated accordingly
func (backRepoCell *BackRepoCellStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoCellid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "CellDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal("Cannot restore/open the json Cell file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*CellDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_CellDBID_CellDB
	for _, cellDB := range forRestore {

		cellDB_ID_atBackupTime := cellDB.ID
		cellDB.ID = 0
		_, err := backRepoCell.db.Create(cellDB)
		if err != nil {
			log.Fatal(err)
		}
		backRepoCell.Map_CellDBID_CellDB[cellDB.ID] = cellDB
		BackRepoCellid_atBckpTime_newID[cellDB_ID_atBackupTime] = cellDB.ID
	}

	if err != nil {
		log.Fatal("Cannot restore/unmarshall json Cell file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<Cell>id_atBckpTime_newID
// to compute new index
func (backRepoCell *BackRepoCellStruct) RestorePhaseTwo() {

	for _, cellDB := range backRepoCell.Map_CellDBID_CellDB {

		// next line of code is to avert unused variable compilation error
		_ = cellDB

		// insertion point for reindexing pointers encoding
		// reindexing CellString field
		if cellDB.CellStringID.Int64 != 0 {
			cellDB.CellStringID.Int64 = int64(BackRepoCellStringid_atBckpTime_newID[uint(cellDB.CellStringID.Int64)])
			cellDB.CellStringID.Valid = true
		}

		// reindexing CellFloat64 field
		if cellDB.CellFloat64ID.Int64 != 0 {
			cellDB.CellFloat64ID.Int64 = int64(BackRepoCellFloat64id_atBckpTime_newID[uint(cellDB.CellFloat64ID.Int64)])
			cellDB.CellFloat64ID.Valid = true
		}

		// reindexing CellInt field
		if cellDB.CellIntID.Int64 != 0 {
			cellDB.CellIntID.Int64 = int64(BackRepoCellIntid_atBckpTime_newID[uint(cellDB.CellIntID.Int64)])
			cellDB.CellIntID.Valid = true
		}

		// reindexing CellBool field
		if cellDB.CellBoolID.Int64 != 0 {
			cellDB.CellBoolID.Int64 = int64(BackRepoCellBooleanid_atBckpTime_newID[uint(cellDB.CellBoolID.Int64)])
			cellDB.CellBoolID.Valid = true
		}

		// reindexing CellIcon field
		if cellDB.CellIconID.Int64 != 0 {
			cellDB.CellIconID.Int64 = int64(BackRepoCellIconid_atBckpTime_newID[uint(cellDB.CellIconID.Int64)])
			cellDB.CellIconID.Valid = true
		}

		// update databse with new index encoding
		db, _ := backRepoCell.db.Model(cellDB)
		_, err := db.Updates(*cellDB)
		if err != nil {
			log.Fatal(err)
		}
	}

}

// BackRepoCell.ResetReversePointers commits all staged instances of Cell to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoCell *BackRepoCellStruct) ResetReversePointers(backRepo *BackRepoStruct) (Error error) {

	for idx, cell := range backRepoCell.Map_CellDBID_CellPtr {
		backRepoCell.ResetReversePointersInstance(backRepo, idx, cell)
	}

	return
}

func (backRepoCell *BackRepoCellStruct) ResetReversePointersInstance(backRepo *BackRepoStruct, idx uint, cell *models.Cell) (Error error) {

	// fetch matching cellDB
	if cellDB, ok := backRepoCell.Map_CellDBID_CellDB[idx]; ok {
		_ = cellDB // to avoid unused variable error if there are no reverse to reset

		// insertion point for reverse pointers reset
		// end of insertion point for reverse pointers reset
	}

	return
}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoCellid_atBckpTime_newID map[uint]uint
