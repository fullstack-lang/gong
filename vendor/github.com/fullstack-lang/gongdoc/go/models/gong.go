// generated by ModelGongFileTemplate
package models

import (
	"fmt"
	"log"
	"os"
	"path"
	"regexp"
	"sort"
	"strings"
)

// swagger:ignore
type __void struct{}

// needed for creating set of instances in the stage
var __member __void

// StageStruct enables storage of staged instances
// swagger:ignore
type StageStruct struct { // insertion point for definition of arrays registering instances
	Classdiagrams           map[*Classdiagram]struct{}
	Classdiagrams_mapString map[string]*Classdiagram

	Classshapes           map[*Classshape]struct{}
	Classshapes_mapString map[string]*Classshape

	Fields           map[*Field]struct{}
	Fields_mapString map[string]*Field

	GongStructs           map[*GongStruct]struct{}
	GongStructs_mapString map[string]*GongStruct

	GongdocCommands           map[*GongdocCommand]struct{}
	GongdocCommands_mapString map[string]*GongdocCommand

	GongdocStatuss           map[*GongdocStatus]struct{}
	GongdocStatuss_mapString map[string]*GongdocStatus

	Links           map[*Link]struct{}
	Links_mapString map[string]*Link

	Pkgelts           map[*Pkgelt]struct{}
	Pkgelts_mapString map[string]*Pkgelt

	Positions           map[*Position]struct{}
	Positions_mapString map[string]*Position

	UmlStates           map[*UmlState]struct{}
	UmlStates_mapString map[string]*UmlState

	Umlscs           map[*Umlsc]struct{}
	Umlscs_mapString map[string]*Umlsc

	Vertices           map[*Vertice]struct{}
	Vertices_mapString map[string]*Vertice

	AllModelsStructCreateCallback AllModelsStructCreateInterface

	AllModelsStructDeleteCallback AllModelsStructDeleteInterface

	BackRepo BackRepoInterface

	// if set will be called before each commit to the back repo
	OnInitCommitCallback          OnInitCommitInterface
	OnInitCommitFromFrontCallback OnInitCommitInterface
	OnInitCommitFromBackCallback  OnInitCommitInterface

	// store the number of instance per gongstruct
	Map_GongStructName_InstancesNb map[string]int
}

type OnInitCommitInterface interface {
	BeforeCommit(stage *StageStruct)
}

type BackRepoInterface interface {
	Commit(stage *StageStruct)
	Checkout(stage *StageStruct)
	Backup(stage *StageStruct, dirPath string)
	Restore(stage *StageStruct, dirPath string)
	BackupXL(stage *StageStruct, dirPath string)
	RestoreXL(stage *StageStruct, dirPath string)
	// insertion point for Commit and Checkout signatures
	CommitClassdiagram(classdiagram *Classdiagram)
	CheckoutClassdiagram(classdiagram *Classdiagram)
	CommitClassshape(classshape *Classshape)
	CheckoutClassshape(classshape *Classshape)
	CommitField(field *Field)
	CheckoutField(field *Field)
	CommitGongStruct(gongstruct *GongStruct)
	CheckoutGongStruct(gongstruct *GongStruct)
	CommitGongdocCommand(gongdoccommand *GongdocCommand)
	CheckoutGongdocCommand(gongdoccommand *GongdocCommand)
	CommitGongdocStatus(gongdocstatus *GongdocStatus)
	CheckoutGongdocStatus(gongdocstatus *GongdocStatus)
	CommitLink(link *Link)
	CheckoutLink(link *Link)
	CommitPkgelt(pkgelt *Pkgelt)
	CheckoutPkgelt(pkgelt *Pkgelt)
	CommitPosition(position *Position)
	CheckoutPosition(position *Position)
	CommitUmlState(umlstate *UmlState)
	CheckoutUmlState(umlstate *UmlState)
	CommitUmlsc(umlsc *Umlsc)
	CheckoutUmlsc(umlsc *Umlsc)
	CommitVertice(vertice *Vertice)
	CheckoutVertice(vertice *Vertice)
	GetLastCommitFromBackNb() uint
	GetLastPushFromFrontNb() uint
}

// swagger:ignore instructs the gong compiler (gongc) to avoid this particular struct
var Stage StageStruct = StageStruct{ // insertion point for array initiatialisation
	Classdiagrams:           make(map[*Classdiagram]struct{}),
	Classdiagrams_mapString: make(map[string]*Classdiagram),

	Classshapes:           make(map[*Classshape]struct{}),
	Classshapes_mapString: make(map[string]*Classshape),

	Fields:           make(map[*Field]struct{}),
	Fields_mapString: make(map[string]*Field),

	GongStructs:           make(map[*GongStruct]struct{}),
	GongStructs_mapString: make(map[string]*GongStruct),

	GongdocCommands:           make(map[*GongdocCommand]struct{}),
	GongdocCommands_mapString: make(map[string]*GongdocCommand),

	GongdocStatuss:           make(map[*GongdocStatus]struct{}),
	GongdocStatuss_mapString: make(map[string]*GongdocStatus),

	Links:           make(map[*Link]struct{}),
	Links_mapString: make(map[string]*Link),

	Pkgelts:           make(map[*Pkgelt]struct{}),
	Pkgelts_mapString: make(map[string]*Pkgelt),

	Positions:           make(map[*Position]struct{}),
	Positions_mapString: make(map[string]*Position),

	UmlStates:           make(map[*UmlState]struct{}),
	UmlStates_mapString: make(map[string]*UmlState),

	Umlscs:           make(map[*Umlsc]struct{}),
	Umlscs_mapString: make(map[string]*Umlsc),

	Vertices:           make(map[*Vertice]struct{}),
	Vertices_mapString: make(map[string]*Vertice),

	// end of insertion point
	Map_GongStructName_InstancesNb: make(map[string]int),
}

func (stage *StageStruct) Commit() {
	if stage.BackRepo != nil {
		stage.BackRepo.Commit(stage)
	}

	// insertion point for computing the map of number of instances per gongstruct
	stage.Map_GongStructName_InstancesNb["Classdiagram"] = len(stage.Classdiagrams)
	stage.Map_GongStructName_InstancesNb["Classshape"] = len(stage.Classshapes)
	stage.Map_GongStructName_InstancesNb["Field"] = len(stage.Fields)
	stage.Map_GongStructName_InstancesNb["GongStruct"] = len(stage.GongStructs)
	stage.Map_GongStructName_InstancesNb["GongdocCommand"] = len(stage.GongdocCommands)
	stage.Map_GongStructName_InstancesNb["GongdocStatus"] = len(stage.GongdocStatuss)
	stage.Map_GongStructName_InstancesNb["Link"] = len(stage.Links)
	stage.Map_GongStructName_InstancesNb["Pkgelt"] = len(stage.Pkgelts)
	stage.Map_GongStructName_InstancesNb["Position"] = len(stage.Positions)
	stage.Map_GongStructName_InstancesNb["UmlState"] = len(stage.UmlStates)
	stage.Map_GongStructName_InstancesNb["Umlsc"] = len(stage.Umlscs)
	stage.Map_GongStructName_InstancesNb["Vertice"] = len(stage.Vertices)

}

func (stage *StageStruct) Checkout() {
	if stage.BackRepo != nil {
		stage.BackRepo.Checkout(stage)
	}
}

// backup generates backup files in the dirPath
func (stage *StageStruct) Backup(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.Backup(stage, dirPath)
	}
}

// Restore resets Stage & BackRepo and restores their content from the restore files in dirPath
func (stage *StageStruct) Restore(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.Restore(stage, dirPath)
	}
}

// backup generates backup files in the dirPath
func (stage *StageStruct) BackupXL(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.BackupXL(stage, dirPath)
	}
}

// Restore resets Stage & BackRepo and restores their content from the restore files in dirPath
func (stage *StageStruct) RestoreXL(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.RestoreXL(stage, dirPath)
	}
}

// insertion point for cumulative sub template with model space calls
func (stage *StageStruct) getClassdiagramOrderedStructWithNameField() []*Classdiagram {
	// have alphabetical order generation
	classdiagramOrdered := []*Classdiagram{}
	for classdiagram := range stage.Classdiagrams {
		classdiagramOrdered = append(classdiagramOrdered, classdiagram)
	}
	sort.Slice(classdiagramOrdered[:], func(i, j int) bool {
		return classdiagramOrdered[i].Name < classdiagramOrdered[j].Name
	})
	return classdiagramOrdered
}

// Stage puts classdiagram to the model stage
func (classdiagram *Classdiagram) Stage() *Classdiagram {
	Stage.Classdiagrams[classdiagram] = __member
	Stage.Classdiagrams_mapString[classdiagram.Name] = classdiagram

	return classdiagram
}

// Unstage removes classdiagram off the model stage
func (classdiagram *Classdiagram) Unstage() *Classdiagram {
	delete(Stage.Classdiagrams, classdiagram)
	delete(Stage.Classdiagrams_mapString, classdiagram.Name)
	return classdiagram
}

// commit classdiagram to the back repo (if it is already staged)
func (classdiagram *Classdiagram) Commit() *Classdiagram {
	if _, ok := Stage.Classdiagrams[classdiagram]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitClassdiagram(classdiagram)
		}
	}
	return classdiagram
}

// Checkout classdiagram to the back repo (if it is already staged)
func (classdiagram *Classdiagram) Checkout() *Classdiagram {
	if _, ok := Stage.Classdiagrams[classdiagram]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutClassdiagram(classdiagram)
		}
	}
	return classdiagram
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of classdiagram to the model stage
func (classdiagram *Classdiagram) StageCopy() *Classdiagram {
	_classdiagram := new(Classdiagram)
	*_classdiagram = *classdiagram
	_classdiagram.Stage()
	return _classdiagram
}

// StageAndCommit appends classdiagram to the model stage and commit to the orm repo
func (classdiagram *Classdiagram) StageAndCommit() *Classdiagram {
	classdiagram.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassdiagram(classdiagram)
	}
	return classdiagram
}

// DeleteStageAndCommit appends classdiagram to the model stage and commit to the orm repo
func (classdiagram *Classdiagram) DeleteStageAndCommit() *Classdiagram {
	classdiagram.Unstage()
	DeleteORMClassdiagram(classdiagram)
	return classdiagram
}

// StageCopyAndCommit appends a copy of classdiagram to the model stage and commit to the orm repo
func (classdiagram *Classdiagram) StageCopyAndCommit() *Classdiagram {
	_classdiagram := new(Classdiagram)
	*_classdiagram = *classdiagram
	_classdiagram.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassdiagram(classdiagram)
	}
	return _classdiagram
}

// CreateORMClassdiagram enables dynamic staging of a Classdiagram instance
func CreateORMClassdiagram(classdiagram *Classdiagram) {
	classdiagram.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassdiagram(classdiagram)
	}
}

// DeleteORMClassdiagram enables dynamic staging of a Classdiagram instance
func DeleteORMClassdiagram(classdiagram *Classdiagram) {
	classdiagram.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMClassdiagram(classdiagram)
	}
}

func (stage *StageStruct) getClassshapeOrderedStructWithNameField() []*Classshape {
	// have alphabetical order generation
	classshapeOrdered := []*Classshape{}
	for classshape := range stage.Classshapes {
		classshapeOrdered = append(classshapeOrdered, classshape)
	}
	sort.Slice(classshapeOrdered[:], func(i, j int) bool {
		return classshapeOrdered[i].Name < classshapeOrdered[j].Name
	})
	return classshapeOrdered
}

// Stage puts classshape to the model stage
func (classshape *Classshape) Stage() *Classshape {
	Stage.Classshapes[classshape] = __member
	Stage.Classshapes_mapString[classshape.Name] = classshape

	return classshape
}

// Unstage removes classshape off the model stage
func (classshape *Classshape) Unstage() *Classshape {
	delete(Stage.Classshapes, classshape)
	delete(Stage.Classshapes_mapString, classshape.Name)
	return classshape
}

// commit classshape to the back repo (if it is already staged)
func (classshape *Classshape) Commit() *Classshape {
	if _, ok := Stage.Classshapes[classshape]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitClassshape(classshape)
		}
	}
	return classshape
}

// Checkout classshape to the back repo (if it is already staged)
func (classshape *Classshape) Checkout() *Classshape {
	if _, ok := Stage.Classshapes[classshape]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutClassshape(classshape)
		}
	}
	return classshape
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of classshape to the model stage
func (classshape *Classshape) StageCopy() *Classshape {
	_classshape := new(Classshape)
	*_classshape = *classshape
	_classshape.Stage()
	return _classshape
}

// StageAndCommit appends classshape to the model stage and commit to the orm repo
func (classshape *Classshape) StageAndCommit() *Classshape {
	classshape.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassshape(classshape)
	}
	return classshape
}

// DeleteStageAndCommit appends classshape to the model stage and commit to the orm repo
func (classshape *Classshape) DeleteStageAndCommit() *Classshape {
	classshape.Unstage()
	DeleteORMClassshape(classshape)
	return classshape
}

// StageCopyAndCommit appends a copy of classshape to the model stage and commit to the orm repo
func (classshape *Classshape) StageCopyAndCommit() *Classshape {
	_classshape := new(Classshape)
	*_classshape = *classshape
	_classshape.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassshape(classshape)
	}
	return _classshape
}

// CreateORMClassshape enables dynamic staging of a Classshape instance
func CreateORMClassshape(classshape *Classshape) {
	classshape.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassshape(classshape)
	}
}

// DeleteORMClassshape enables dynamic staging of a Classshape instance
func DeleteORMClassshape(classshape *Classshape) {
	classshape.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMClassshape(classshape)
	}
}

func (stage *StageStruct) getFieldOrderedStructWithNameField() []*Field {
	// have alphabetical order generation
	fieldOrdered := []*Field{}
	for field := range stage.Fields {
		fieldOrdered = append(fieldOrdered, field)
	}
	sort.Slice(fieldOrdered[:], func(i, j int) bool {
		return fieldOrdered[i].Name < fieldOrdered[j].Name
	})
	return fieldOrdered
}

// Stage puts field to the model stage
func (field *Field) Stage() *Field {
	Stage.Fields[field] = __member
	Stage.Fields_mapString[field.Name] = field

	return field
}

// Unstage removes field off the model stage
func (field *Field) Unstage() *Field {
	delete(Stage.Fields, field)
	delete(Stage.Fields_mapString, field.Name)
	return field
}

// commit field to the back repo (if it is already staged)
func (field *Field) Commit() *Field {
	if _, ok := Stage.Fields[field]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitField(field)
		}
	}
	return field
}

// Checkout field to the back repo (if it is already staged)
func (field *Field) Checkout() *Field {
	if _, ok := Stage.Fields[field]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutField(field)
		}
	}
	return field
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of field to the model stage
func (field *Field) StageCopy() *Field {
	_field := new(Field)
	*_field = *field
	_field.Stage()
	return _field
}

// StageAndCommit appends field to the model stage and commit to the orm repo
func (field *Field) StageAndCommit() *Field {
	field.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMField(field)
	}
	return field
}

// DeleteStageAndCommit appends field to the model stage and commit to the orm repo
func (field *Field) DeleteStageAndCommit() *Field {
	field.Unstage()
	DeleteORMField(field)
	return field
}

// StageCopyAndCommit appends a copy of field to the model stage and commit to the orm repo
func (field *Field) StageCopyAndCommit() *Field {
	_field := new(Field)
	*_field = *field
	_field.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMField(field)
	}
	return _field
}

// CreateORMField enables dynamic staging of a Field instance
func CreateORMField(field *Field) {
	field.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMField(field)
	}
}

// DeleteORMField enables dynamic staging of a Field instance
func DeleteORMField(field *Field) {
	field.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMField(field)
	}
}

func (stage *StageStruct) getGongStructOrderedStructWithNameField() []*GongStruct {
	// have alphabetical order generation
	gongstructOrdered := []*GongStruct{}
	for gongstruct := range stage.GongStructs {
		gongstructOrdered = append(gongstructOrdered, gongstruct)
	}
	sort.Slice(gongstructOrdered[:], func(i, j int) bool {
		return gongstructOrdered[i].Name < gongstructOrdered[j].Name
	})
	return gongstructOrdered
}

// Stage puts gongstruct to the model stage
func (gongstruct *GongStruct) Stage() *GongStruct {
	Stage.GongStructs[gongstruct] = __member
	Stage.GongStructs_mapString[gongstruct.Name] = gongstruct

	return gongstruct
}

// Unstage removes gongstruct off the model stage
func (gongstruct *GongStruct) Unstage() *GongStruct {
	delete(Stage.GongStructs, gongstruct)
	delete(Stage.GongStructs_mapString, gongstruct.Name)
	return gongstruct
}

// commit gongstruct to the back repo (if it is already staged)
func (gongstruct *GongStruct) Commit() *GongStruct {
	if _, ok := Stage.GongStructs[gongstruct]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitGongStruct(gongstruct)
		}
	}
	return gongstruct
}

// Checkout gongstruct to the back repo (if it is already staged)
func (gongstruct *GongStruct) Checkout() *GongStruct {
	if _, ok := Stage.GongStructs[gongstruct]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutGongStruct(gongstruct)
		}
	}
	return gongstruct
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of gongstruct to the model stage
func (gongstruct *GongStruct) StageCopy() *GongStruct {
	_gongstruct := new(GongStruct)
	*_gongstruct = *gongstruct
	_gongstruct.Stage()
	return _gongstruct
}

// StageAndCommit appends gongstruct to the model stage and commit to the orm repo
func (gongstruct *GongStruct) StageAndCommit() *GongStruct {
	gongstruct.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongStruct(gongstruct)
	}
	return gongstruct
}

// DeleteStageAndCommit appends gongstruct to the model stage and commit to the orm repo
func (gongstruct *GongStruct) DeleteStageAndCommit() *GongStruct {
	gongstruct.Unstage()
	DeleteORMGongStruct(gongstruct)
	return gongstruct
}

// StageCopyAndCommit appends a copy of gongstruct to the model stage and commit to the orm repo
func (gongstruct *GongStruct) StageCopyAndCommit() *GongStruct {
	_gongstruct := new(GongStruct)
	*_gongstruct = *gongstruct
	_gongstruct.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongStruct(gongstruct)
	}
	return _gongstruct
}

// CreateORMGongStruct enables dynamic staging of a GongStruct instance
func CreateORMGongStruct(gongstruct *GongStruct) {
	gongstruct.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongStruct(gongstruct)
	}
}

// DeleteORMGongStruct enables dynamic staging of a GongStruct instance
func DeleteORMGongStruct(gongstruct *GongStruct) {
	gongstruct.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMGongStruct(gongstruct)
	}
}

func (stage *StageStruct) getGongdocCommandOrderedStructWithNameField() []*GongdocCommand {
	// have alphabetical order generation
	gongdoccommandOrdered := []*GongdocCommand{}
	for gongdoccommand := range stage.GongdocCommands {
		gongdoccommandOrdered = append(gongdoccommandOrdered, gongdoccommand)
	}
	sort.Slice(gongdoccommandOrdered[:], func(i, j int) bool {
		return gongdoccommandOrdered[i].Name < gongdoccommandOrdered[j].Name
	})
	return gongdoccommandOrdered
}

// Stage puts gongdoccommand to the model stage
func (gongdoccommand *GongdocCommand) Stage() *GongdocCommand {
	Stage.GongdocCommands[gongdoccommand] = __member
	Stage.GongdocCommands_mapString[gongdoccommand.Name] = gongdoccommand

	return gongdoccommand
}

// Unstage removes gongdoccommand off the model stage
func (gongdoccommand *GongdocCommand) Unstage() *GongdocCommand {
	delete(Stage.GongdocCommands, gongdoccommand)
	delete(Stage.GongdocCommands_mapString, gongdoccommand.Name)
	return gongdoccommand
}

// commit gongdoccommand to the back repo (if it is already staged)
func (gongdoccommand *GongdocCommand) Commit() *GongdocCommand {
	if _, ok := Stage.GongdocCommands[gongdoccommand]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitGongdocCommand(gongdoccommand)
		}
	}
	return gongdoccommand
}

// Checkout gongdoccommand to the back repo (if it is already staged)
func (gongdoccommand *GongdocCommand) Checkout() *GongdocCommand {
	if _, ok := Stage.GongdocCommands[gongdoccommand]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutGongdocCommand(gongdoccommand)
		}
	}
	return gongdoccommand
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of gongdoccommand to the model stage
func (gongdoccommand *GongdocCommand) StageCopy() *GongdocCommand {
	_gongdoccommand := new(GongdocCommand)
	*_gongdoccommand = *gongdoccommand
	_gongdoccommand.Stage()
	return _gongdoccommand
}

// StageAndCommit appends gongdoccommand to the model stage and commit to the orm repo
func (gongdoccommand *GongdocCommand) StageAndCommit() *GongdocCommand {
	gongdoccommand.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocCommand(gongdoccommand)
	}
	return gongdoccommand
}

// DeleteStageAndCommit appends gongdoccommand to the model stage and commit to the orm repo
func (gongdoccommand *GongdocCommand) DeleteStageAndCommit() *GongdocCommand {
	gongdoccommand.Unstage()
	DeleteORMGongdocCommand(gongdoccommand)
	return gongdoccommand
}

// StageCopyAndCommit appends a copy of gongdoccommand to the model stage and commit to the orm repo
func (gongdoccommand *GongdocCommand) StageCopyAndCommit() *GongdocCommand {
	_gongdoccommand := new(GongdocCommand)
	*_gongdoccommand = *gongdoccommand
	_gongdoccommand.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocCommand(gongdoccommand)
	}
	return _gongdoccommand
}

// CreateORMGongdocCommand enables dynamic staging of a GongdocCommand instance
func CreateORMGongdocCommand(gongdoccommand *GongdocCommand) {
	gongdoccommand.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocCommand(gongdoccommand)
	}
}

// DeleteORMGongdocCommand enables dynamic staging of a GongdocCommand instance
func DeleteORMGongdocCommand(gongdoccommand *GongdocCommand) {
	gongdoccommand.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMGongdocCommand(gongdoccommand)
	}
}

func (stage *StageStruct) getGongdocStatusOrderedStructWithNameField() []*GongdocStatus {
	// have alphabetical order generation
	gongdocstatusOrdered := []*GongdocStatus{}
	for gongdocstatus := range stage.GongdocStatuss {
		gongdocstatusOrdered = append(gongdocstatusOrdered, gongdocstatus)
	}
	sort.Slice(gongdocstatusOrdered[:], func(i, j int) bool {
		return gongdocstatusOrdered[i].Name < gongdocstatusOrdered[j].Name
	})
	return gongdocstatusOrdered
}

// Stage puts gongdocstatus to the model stage
func (gongdocstatus *GongdocStatus) Stage() *GongdocStatus {
	Stage.GongdocStatuss[gongdocstatus] = __member
	Stage.GongdocStatuss_mapString[gongdocstatus.Name] = gongdocstatus

	return gongdocstatus
}

// Unstage removes gongdocstatus off the model stage
func (gongdocstatus *GongdocStatus) Unstage() *GongdocStatus {
	delete(Stage.GongdocStatuss, gongdocstatus)
	delete(Stage.GongdocStatuss_mapString, gongdocstatus.Name)
	return gongdocstatus
}

// commit gongdocstatus to the back repo (if it is already staged)
func (gongdocstatus *GongdocStatus) Commit() *GongdocStatus {
	if _, ok := Stage.GongdocStatuss[gongdocstatus]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitGongdocStatus(gongdocstatus)
		}
	}
	return gongdocstatus
}

// Checkout gongdocstatus to the back repo (if it is already staged)
func (gongdocstatus *GongdocStatus) Checkout() *GongdocStatus {
	if _, ok := Stage.GongdocStatuss[gongdocstatus]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutGongdocStatus(gongdocstatus)
		}
	}
	return gongdocstatus
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of gongdocstatus to the model stage
func (gongdocstatus *GongdocStatus) StageCopy() *GongdocStatus {
	_gongdocstatus := new(GongdocStatus)
	*_gongdocstatus = *gongdocstatus
	_gongdocstatus.Stage()
	return _gongdocstatus
}

// StageAndCommit appends gongdocstatus to the model stage and commit to the orm repo
func (gongdocstatus *GongdocStatus) StageAndCommit() *GongdocStatus {
	gongdocstatus.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocStatus(gongdocstatus)
	}
	return gongdocstatus
}

// DeleteStageAndCommit appends gongdocstatus to the model stage and commit to the orm repo
func (gongdocstatus *GongdocStatus) DeleteStageAndCommit() *GongdocStatus {
	gongdocstatus.Unstage()
	DeleteORMGongdocStatus(gongdocstatus)
	return gongdocstatus
}

// StageCopyAndCommit appends a copy of gongdocstatus to the model stage and commit to the orm repo
func (gongdocstatus *GongdocStatus) StageCopyAndCommit() *GongdocStatus {
	_gongdocstatus := new(GongdocStatus)
	*_gongdocstatus = *gongdocstatus
	_gongdocstatus.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocStatus(gongdocstatus)
	}
	return _gongdocstatus
}

// CreateORMGongdocStatus enables dynamic staging of a GongdocStatus instance
func CreateORMGongdocStatus(gongdocstatus *GongdocStatus) {
	gongdocstatus.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocStatus(gongdocstatus)
	}
}

// DeleteORMGongdocStatus enables dynamic staging of a GongdocStatus instance
func DeleteORMGongdocStatus(gongdocstatus *GongdocStatus) {
	gongdocstatus.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMGongdocStatus(gongdocstatus)
	}
}

func (stage *StageStruct) getLinkOrderedStructWithNameField() []*Link {
	// have alphabetical order generation
	linkOrdered := []*Link{}
	for link := range stage.Links {
		linkOrdered = append(linkOrdered, link)
	}
	sort.Slice(linkOrdered[:], func(i, j int) bool {
		return linkOrdered[i].Name < linkOrdered[j].Name
	})
	return linkOrdered
}

// Stage puts link to the model stage
func (link *Link) Stage() *Link {
	Stage.Links[link] = __member
	Stage.Links_mapString[link.Name] = link

	return link
}

// Unstage removes link off the model stage
func (link *Link) Unstage() *Link {
	delete(Stage.Links, link)
	delete(Stage.Links_mapString, link.Name)
	return link
}

// commit link to the back repo (if it is already staged)
func (link *Link) Commit() *Link {
	if _, ok := Stage.Links[link]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitLink(link)
		}
	}
	return link
}

// Checkout link to the back repo (if it is already staged)
func (link *Link) Checkout() *Link {
	if _, ok := Stage.Links[link]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutLink(link)
		}
	}
	return link
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of link to the model stage
func (link *Link) StageCopy() *Link {
	_link := new(Link)
	*_link = *link
	_link.Stage()
	return _link
}

// StageAndCommit appends link to the model stage and commit to the orm repo
func (link *Link) StageAndCommit() *Link {
	link.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLink(link)
	}
	return link
}

// DeleteStageAndCommit appends link to the model stage and commit to the orm repo
func (link *Link) DeleteStageAndCommit() *Link {
	link.Unstage()
	DeleteORMLink(link)
	return link
}

// StageCopyAndCommit appends a copy of link to the model stage and commit to the orm repo
func (link *Link) StageCopyAndCommit() *Link {
	_link := new(Link)
	*_link = *link
	_link.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLink(link)
	}
	return _link
}

// CreateORMLink enables dynamic staging of a Link instance
func CreateORMLink(link *Link) {
	link.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLink(link)
	}
}

// DeleteORMLink enables dynamic staging of a Link instance
func DeleteORMLink(link *Link) {
	link.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMLink(link)
	}
}

func (stage *StageStruct) getPkgeltOrderedStructWithNameField() []*Pkgelt {
	// have alphabetical order generation
	pkgeltOrdered := []*Pkgelt{}
	for pkgelt := range stage.Pkgelts {
		pkgeltOrdered = append(pkgeltOrdered, pkgelt)
	}
	sort.Slice(pkgeltOrdered[:], func(i, j int) bool {
		return pkgeltOrdered[i].Name < pkgeltOrdered[j].Name
	})
	return pkgeltOrdered
}

// Stage puts pkgelt to the model stage
func (pkgelt *Pkgelt) Stage() *Pkgelt {
	Stage.Pkgelts[pkgelt] = __member
	Stage.Pkgelts_mapString[pkgelt.Name] = pkgelt

	return pkgelt
}

// Unstage removes pkgelt off the model stage
func (pkgelt *Pkgelt) Unstage() *Pkgelt {
	delete(Stage.Pkgelts, pkgelt)
	delete(Stage.Pkgelts_mapString, pkgelt.Name)
	return pkgelt
}

// commit pkgelt to the back repo (if it is already staged)
func (pkgelt *Pkgelt) Commit() *Pkgelt {
	if _, ok := Stage.Pkgelts[pkgelt]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitPkgelt(pkgelt)
		}
	}
	return pkgelt
}

// Checkout pkgelt to the back repo (if it is already staged)
func (pkgelt *Pkgelt) Checkout() *Pkgelt {
	if _, ok := Stage.Pkgelts[pkgelt]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutPkgelt(pkgelt)
		}
	}
	return pkgelt
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of pkgelt to the model stage
func (pkgelt *Pkgelt) StageCopy() *Pkgelt {
	_pkgelt := new(Pkgelt)
	*_pkgelt = *pkgelt
	_pkgelt.Stage()
	return _pkgelt
}

// StageAndCommit appends pkgelt to the model stage and commit to the orm repo
func (pkgelt *Pkgelt) StageAndCommit() *Pkgelt {
	pkgelt.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPkgelt(pkgelt)
	}
	return pkgelt
}

// DeleteStageAndCommit appends pkgelt to the model stage and commit to the orm repo
func (pkgelt *Pkgelt) DeleteStageAndCommit() *Pkgelt {
	pkgelt.Unstage()
	DeleteORMPkgelt(pkgelt)
	return pkgelt
}

// StageCopyAndCommit appends a copy of pkgelt to the model stage and commit to the orm repo
func (pkgelt *Pkgelt) StageCopyAndCommit() *Pkgelt {
	_pkgelt := new(Pkgelt)
	*_pkgelt = *pkgelt
	_pkgelt.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPkgelt(pkgelt)
	}
	return _pkgelt
}

// CreateORMPkgelt enables dynamic staging of a Pkgelt instance
func CreateORMPkgelt(pkgelt *Pkgelt) {
	pkgelt.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPkgelt(pkgelt)
	}
}

// DeleteORMPkgelt enables dynamic staging of a Pkgelt instance
func DeleteORMPkgelt(pkgelt *Pkgelt) {
	pkgelt.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMPkgelt(pkgelt)
	}
}

func (stage *StageStruct) getPositionOrderedStructWithNameField() []*Position {
	// have alphabetical order generation
	positionOrdered := []*Position{}
	for position := range stage.Positions {
		positionOrdered = append(positionOrdered, position)
	}
	sort.Slice(positionOrdered[:], func(i, j int) bool {
		return positionOrdered[i].Name < positionOrdered[j].Name
	})
	return positionOrdered
}

// Stage puts position to the model stage
func (position *Position) Stage() *Position {
	Stage.Positions[position] = __member
	Stage.Positions_mapString[position.Name] = position

	return position
}

// Unstage removes position off the model stage
func (position *Position) Unstage() *Position {
	delete(Stage.Positions, position)
	delete(Stage.Positions_mapString, position.Name)
	return position
}

// commit position to the back repo (if it is already staged)
func (position *Position) Commit() *Position {
	if _, ok := Stage.Positions[position]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitPosition(position)
		}
	}
	return position
}

// Checkout position to the back repo (if it is already staged)
func (position *Position) Checkout() *Position {
	if _, ok := Stage.Positions[position]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutPosition(position)
		}
	}
	return position
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of position to the model stage
func (position *Position) StageCopy() *Position {
	_position := new(Position)
	*_position = *position
	_position.Stage()
	return _position
}

// StageAndCommit appends position to the model stage and commit to the orm repo
func (position *Position) StageAndCommit() *Position {
	position.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPosition(position)
	}
	return position
}

// DeleteStageAndCommit appends position to the model stage and commit to the orm repo
func (position *Position) DeleteStageAndCommit() *Position {
	position.Unstage()
	DeleteORMPosition(position)
	return position
}

// StageCopyAndCommit appends a copy of position to the model stage and commit to the orm repo
func (position *Position) StageCopyAndCommit() *Position {
	_position := new(Position)
	*_position = *position
	_position.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPosition(position)
	}
	return _position
}

// CreateORMPosition enables dynamic staging of a Position instance
func CreateORMPosition(position *Position) {
	position.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPosition(position)
	}
}

// DeleteORMPosition enables dynamic staging of a Position instance
func DeleteORMPosition(position *Position) {
	position.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMPosition(position)
	}
}

func (stage *StageStruct) getUmlStateOrderedStructWithNameField() []*UmlState {
	// have alphabetical order generation
	umlstateOrdered := []*UmlState{}
	for umlstate := range stage.UmlStates {
		umlstateOrdered = append(umlstateOrdered, umlstate)
	}
	sort.Slice(umlstateOrdered[:], func(i, j int) bool {
		return umlstateOrdered[i].Name < umlstateOrdered[j].Name
	})
	return umlstateOrdered
}

// Stage puts umlstate to the model stage
func (umlstate *UmlState) Stage() *UmlState {
	Stage.UmlStates[umlstate] = __member
	Stage.UmlStates_mapString[umlstate.Name] = umlstate

	return umlstate
}

// Unstage removes umlstate off the model stage
func (umlstate *UmlState) Unstage() *UmlState {
	delete(Stage.UmlStates, umlstate)
	delete(Stage.UmlStates_mapString, umlstate.Name)
	return umlstate
}

// commit umlstate to the back repo (if it is already staged)
func (umlstate *UmlState) Commit() *UmlState {
	if _, ok := Stage.UmlStates[umlstate]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitUmlState(umlstate)
		}
	}
	return umlstate
}

// Checkout umlstate to the back repo (if it is already staged)
func (umlstate *UmlState) Checkout() *UmlState {
	if _, ok := Stage.UmlStates[umlstate]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutUmlState(umlstate)
		}
	}
	return umlstate
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of umlstate to the model stage
func (umlstate *UmlState) StageCopy() *UmlState {
	_umlstate := new(UmlState)
	*_umlstate = *umlstate
	_umlstate.Stage()
	return _umlstate
}

// StageAndCommit appends umlstate to the model stage and commit to the orm repo
func (umlstate *UmlState) StageAndCommit() *UmlState {
	umlstate.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlState(umlstate)
	}
	return umlstate
}

// DeleteStageAndCommit appends umlstate to the model stage and commit to the orm repo
func (umlstate *UmlState) DeleteStageAndCommit() *UmlState {
	umlstate.Unstage()
	DeleteORMUmlState(umlstate)
	return umlstate
}

// StageCopyAndCommit appends a copy of umlstate to the model stage and commit to the orm repo
func (umlstate *UmlState) StageCopyAndCommit() *UmlState {
	_umlstate := new(UmlState)
	*_umlstate = *umlstate
	_umlstate.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlState(umlstate)
	}
	return _umlstate
}

// CreateORMUmlState enables dynamic staging of a UmlState instance
func CreateORMUmlState(umlstate *UmlState) {
	umlstate.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlState(umlstate)
	}
}

// DeleteORMUmlState enables dynamic staging of a UmlState instance
func DeleteORMUmlState(umlstate *UmlState) {
	umlstate.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMUmlState(umlstate)
	}
}

func (stage *StageStruct) getUmlscOrderedStructWithNameField() []*Umlsc {
	// have alphabetical order generation
	umlscOrdered := []*Umlsc{}
	for umlsc := range stage.Umlscs {
		umlscOrdered = append(umlscOrdered, umlsc)
	}
	sort.Slice(umlscOrdered[:], func(i, j int) bool {
		return umlscOrdered[i].Name < umlscOrdered[j].Name
	})
	return umlscOrdered
}

// Stage puts umlsc to the model stage
func (umlsc *Umlsc) Stage() *Umlsc {
	Stage.Umlscs[umlsc] = __member
	Stage.Umlscs_mapString[umlsc.Name] = umlsc

	return umlsc
}

// Unstage removes umlsc off the model stage
func (umlsc *Umlsc) Unstage() *Umlsc {
	delete(Stage.Umlscs, umlsc)
	delete(Stage.Umlscs_mapString, umlsc.Name)
	return umlsc
}

// commit umlsc to the back repo (if it is already staged)
func (umlsc *Umlsc) Commit() *Umlsc {
	if _, ok := Stage.Umlscs[umlsc]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitUmlsc(umlsc)
		}
	}
	return umlsc
}

// Checkout umlsc to the back repo (if it is already staged)
func (umlsc *Umlsc) Checkout() *Umlsc {
	if _, ok := Stage.Umlscs[umlsc]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutUmlsc(umlsc)
		}
	}
	return umlsc
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of umlsc to the model stage
func (umlsc *Umlsc) StageCopy() *Umlsc {
	_umlsc := new(Umlsc)
	*_umlsc = *umlsc
	_umlsc.Stage()
	return _umlsc
}

// StageAndCommit appends umlsc to the model stage and commit to the orm repo
func (umlsc *Umlsc) StageAndCommit() *Umlsc {
	umlsc.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlsc(umlsc)
	}
	return umlsc
}

// DeleteStageAndCommit appends umlsc to the model stage and commit to the orm repo
func (umlsc *Umlsc) DeleteStageAndCommit() *Umlsc {
	umlsc.Unstage()
	DeleteORMUmlsc(umlsc)
	return umlsc
}

// StageCopyAndCommit appends a copy of umlsc to the model stage and commit to the orm repo
func (umlsc *Umlsc) StageCopyAndCommit() *Umlsc {
	_umlsc := new(Umlsc)
	*_umlsc = *umlsc
	_umlsc.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlsc(umlsc)
	}
	return _umlsc
}

// CreateORMUmlsc enables dynamic staging of a Umlsc instance
func CreateORMUmlsc(umlsc *Umlsc) {
	umlsc.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlsc(umlsc)
	}
}

// DeleteORMUmlsc enables dynamic staging of a Umlsc instance
func DeleteORMUmlsc(umlsc *Umlsc) {
	umlsc.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMUmlsc(umlsc)
	}
}

func (stage *StageStruct) getVerticeOrderedStructWithNameField() []*Vertice {
	// have alphabetical order generation
	verticeOrdered := []*Vertice{}
	for vertice := range stage.Vertices {
		verticeOrdered = append(verticeOrdered, vertice)
	}
	sort.Slice(verticeOrdered[:], func(i, j int) bool {
		return verticeOrdered[i].Name < verticeOrdered[j].Name
	})
	return verticeOrdered
}

// Stage puts vertice to the model stage
func (vertice *Vertice) Stage() *Vertice {
	Stage.Vertices[vertice] = __member
	Stage.Vertices_mapString[vertice.Name] = vertice

	return vertice
}

// Unstage removes vertice off the model stage
func (vertice *Vertice) Unstage() *Vertice {
	delete(Stage.Vertices, vertice)
	delete(Stage.Vertices_mapString, vertice.Name)
	return vertice
}

// commit vertice to the back repo (if it is already staged)
func (vertice *Vertice) Commit() *Vertice {
	if _, ok := Stage.Vertices[vertice]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitVertice(vertice)
		}
	}
	return vertice
}

// Checkout vertice to the back repo (if it is already staged)
func (vertice *Vertice) Checkout() *Vertice {
	if _, ok := Stage.Vertices[vertice]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutVertice(vertice)
		}
	}
	return vertice
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of vertice to the model stage
func (vertice *Vertice) StageCopy() *Vertice {
	_vertice := new(Vertice)
	*_vertice = *vertice
	_vertice.Stage()
	return _vertice
}

// StageAndCommit appends vertice to the model stage and commit to the orm repo
func (vertice *Vertice) StageAndCommit() *Vertice {
	vertice.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVertice(vertice)
	}
	return vertice
}

// DeleteStageAndCommit appends vertice to the model stage and commit to the orm repo
func (vertice *Vertice) DeleteStageAndCommit() *Vertice {
	vertice.Unstage()
	DeleteORMVertice(vertice)
	return vertice
}

// StageCopyAndCommit appends a copy of vertice to the model stage and commit to the orm repo
func (vertice *Vertice) StageCopyAndCommit() *Vertice {
	_vertice := new(Vertice)
	*_vertice = *vertice
	_vertice.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVertice(vertice)
	}
	return _vertice
}

// CreateORMVertice enables dynamic staging of a Vertice instance
func CreateORMVertice(vertice *Vertice) {
	vertice.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVertice(vertice)
	}
}

// DeleteORMVertice enables dynamic staging of a Vertice instance
func DeleteORMVertice(vertice *Vertice) {
	vertice.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMVertice(vertice)
	}
}

// swagger:ignore
type AllModelsStructCreateInterface interface { // insertion point for Callbacks on creation
	CreateORMClassdiagram(Classdiagram *Classdiagram)
	CreateORMClassshape(Classshape *Classshape)
	CreateORMField(Field *Field)
	CreateORMGongStruct(GongStruct *GongStruct)
	CreateORMGongdocCommand(GongdocCommand *GongdocCommand)
	CreateORMGongdocStatus(GongdocStatus *GongdocStatus)
	CreateORMLink(Link *Link)
	CreateORMPkgelt(Pkgelt *Pkgelt)
	CreateORMPosition(Position *Position)
	CreateORMUmlState(UmlState *UmlState)
	CreateORMUmlsc(Umlsc *Umlsc)
	CreateORMVertice(Vertice *Vertice)
}

type AllModelsStructDeleteInterface interface { // insertion point for Callbacks on deletion
	DeleteORMClassdiagram(Classdiagram *Classdiagram)
	DeleteORMClassshape(Classshape *Classshape)
	DeleteORMField(Field *Field)
	DeleteORMGongStruct(GongStruct *GongStruct)
	DeleteORMGongdocCommand(GongdocCommand *GongdocCommand)
	DeleteORMGongdocStatus(GongdocStatus *GongdocStatus)
	DeleteORMLink(Link *Link)
	DeleteORMPkgelt(Pkgelt *Pkgelt)
	DeleteORMPosition(Position *Position)
	DeleteORMUmlState(UmlState *UmlState)
	DeleteORMUmlsc(Umlsc *Umlsc)
	DeleteORMVertice(Vertice *Vertice)
}

func (stage *StageStruct) Reset() { // insertion point for array reset
	stage.Classdiagrams = make(map[*Classdiagram]struct{})
	stage.Classdiagrams_mapString = make(map[string]*Classdiagram)

	stage.Classshapes = make(map[*Classshape]struct{})
	stage.Classshapes_mapString = make(map[string]*Classshape)

	stage.Fields = make(map[*Field]struct{})
	stage.Fields_mapString = make(map[string]*Field)

	stage.GongStructs = make(map[*GongStruct]struct{})
	stage.GongStructs_mapString = make(map[string]*GongStruct)

	stage.GongdocCommands = make(map[*GongdocCommand]struct{})
	stage.GongdocCommands_mapString = make(map[string]*GongdocCommand)

	stage.GongdocStatuss = make(map[*GongdocStatus]struct{})
	stage.GongdocStatuss_mapString = make(map[string]*GongdocStatus)

	stage.Links = make(map[*Link]struct{})
	stage.Links_mapString = make(map[string]*Link)

	stage.Pkgelts = make(map[*Pkgelt]struct{})
	stage.Pkgelts_mapString = make(map[string]*Pkgelt)

	stage.Positions = make(map[*Position]struct{})
	stage.Positions_mapString = make(map[string]*Position)

	stage.UmlStates = make(map[*UmlState]struct{})
	stage.UmlStates_mapString = make(map[string]*UmlState)

	stage.Umlscs = make(map[*Umlsc]struct{})
	stage.Umlscs_mapString = make(map[string]*Umlsc)

	stage.Vertices = make(map[*Vertice]struct{})
	stage.Vertices_mapString = make(map[string]*Vertice)

}

func (stage *StageStruct) Nil() { // insertion point for array nil
	stage.Classdiagrams = nil
	stage.Classdiagrams_mapString = nil

	stage.Classshapes = nil
	stage.Classshapes_mapString = nil

	stage.Fields = nil
	stage.Fields_mapString = nil

	stage.GongStructs = nil
	stage.GongStructs_mapString = nil

	stage.GongdocCommands = nil
	stage.GongdocCommands_mapString = nil

	stage.GongdocStatuss = nil
	stage.GongdocStatuss_mapString = nil

	stage.Links = nil
	stage.Links_mapString = nil

	stage.Pkgelts = nil
	stage.Pkgelts_mapString = nil

	stage.Positions = nil
	stage.Positions_mapString = nil

	stage.UmlStates = nil
	stage.UmlStates_mapString = nil

	stage.Umlscs = nil
	stage.Umlscs_mapString = nil

	stage.Vertices = nil
	stage.Vertices_mapString = nil

}

const marshallRes = `package {{PackageName}}

import (
	"time"

	"{{ModelsPackageName}}"
)

func init() {
	var __Dummy_time_variable time.Time
	_ = __Dummy_time_variable
	InjectionGateway["{{databaseName}}"] = {{databaseName}}Injection
}

// {{databaseName}}Injection will stage objects of database "{{databaseName}}"
func {{databaseName}}Injection() {

	// Declaration of instances to stage{{Identifiers}}

	// Setup of values{{ValueInitializers}}

	// Setup of pointers{{PointersInitializers}}
}

`

const IdentifiersDecls = `
	{{Identifier}} := (&models.{{GeneratedStructName}}{Name: "{{GeneratedFieldNameValue}}"}).Stage()`

const StringInitStatement = `
	{{Identifier}}.{{GeneratedFieldName}} = "{{GeneratedFieldNameValue}}"`

const NumberInitStatement = `
	{{Identifier}}.{{GeneratedFieldName}} = {{GeneratedFieldNameValue}}`

const PointerFieldInitStatement = `
	{{Identifier}}.{{GeneratedFieldName}} = {{GeneratedFieldNameValue}}`

const SliceOfPointersFieldInitStatement = `
	{{Identifier}}.{{GeneratedFieldName}} = append({{Identifier}}.{{GeneratedFieldName}}, {{GeneratedFieldNameValue}})`

const TimeInitStatement = `
	{{Identifier}}.{{GeneratedFieldName}}, _ = time.Parse("2006-01-02 15:04:05.999999999 -0700 MST", "{{GeneratedFieldNameValue}}")`

// Marshall marshall the stage content into the file as an instanciation into a stage
func (stage *StageStruct) Marshall(file *os.File, modelsPackageName, packageName string) {

	name := file.Name()

	if !strings.HasSuffix(name, ".go") {
		log.Fatalln(name + " is not a go filename")
	}

	log.Println("filename of marshall output  is " + name)

	res := marshallRes
	res = strings.ReplaceAll(res, "{{databaseName}}", strings.ReplaceAll(path.Base(name), ".go", ""))
	res = strings.ReplaceAll(res, "{{PackageName}}", packageName)
	res = strings.ReplaceAll(res, "{{ModelsPackageName}}", modelsPackageName)

	// map of identifiers
	// var StageMapDstructIds map[*Dstruct]string
	identifiersDecl := ""
	initializerStatements := ""
	pointersInitializesStatements := ""

	id := ""
	decl := ""
	setValueField := ""

	// insertion initialization of objects to stage
	map_Classdiagram_Identifiers := make(map[*Classdiagram]string)
	_ = map_Classdiagram_Identifiers

	classdiagramOrdered := []*Classdiagram{}
	for classdiagram := range stage.Classdiagrams {
		classdiagramOrdered = append(classdiagramOrdered, classdiagram)
	}
	sort.Slice(classdiagramOrdered[:], func(i, j int) bool {
		return classdiagramOrdered[i].Name < classdiagramOrdered[j].Name
	})
	identifiersDecl += fmt.Sprintf("\n\n	// Declarations of staged instances of Classdiagram")
	for idx, classdiagram := range classdiagramOrdered {

		id = generatesIdentifier("Classdiagram", idx, classdiagram.Name)
		map_Classdiagram_Identifiers[classdiagram] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Classdiagram")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", classdiagram.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Classdiagram %s values setup", classdiagram.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(classdiagram.Name))
		initializerStatements += setValueField

	}

	map_Classshape_Identifiers := make(map[*Classshape]string)
	_ = map_Classshape_Identifiers

	classshapeOrdered := []*Classshape{}
	for classshape := range stage.Classshapes {
		classshapeOrdered = append(classshapeOrdered, classshape)
	}
	sort.Slice(classshapeOrdered[:], func(i, j int) bool {
		return classshapeOrdered[i].Name < classshapeOrdered[j].Name
	})
	identifiersDecl += fmt.Sprintf("\n\n	// Declarations of staged instances of Classshape")
	for idx, classshape := range classshapeOrdered {

		id = generatesIdentifier("Classshape", idx, classshape.Name)
		map_Classshape_Identifiers[classshape] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Classshape")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", classshape.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Classshape %s values setup", classshape.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(classshape.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Structname")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(classshape.Structname))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "ShowNbInstances")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%t", classshape.ShowNbInstances))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "NbInstances")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%d", classshape.NbInstances))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Width")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", classshape.Width))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Heigth")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", classshape.Heigth))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "ClassshapeTargetType")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(classshape.ClassshapeTargetType))
		initializerStatements += setValueField

	}

	map_Field_Identifiers := make(map[*Field]string)
	_ = map_Field_Identifiers

	fieldOrdered := []*Field{}
	for field := range stage.Fields {
		fieldOrdered = append(fieldOrdered, field)
	}
	sort.Slice(fieldOrdered[:], func(i, j int) bool {
		return fieldOrdered[i].Name < fieldOrdered[j].Name
	})
	identifiersDecl += fmt.Sprintf("\n\n	// Declarations of staged instances of Field")
	for idx, field := range fieldOrdered {

		id = generatesIdentifier("Field", idx, field.Name)
		map_Field_Identifiers[field] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Field")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", field.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Field %s values setup", field.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(field.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Fieldname")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(field.Fieldname))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "FieldTypeAsString")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(field.FieldTypeAsString))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Structname")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(field.Structname))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Fieldtypename")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(field.Fieldtypename))
		initializerStatements += setValueField

	}

	map_GongStruct_Identifiers := make(map[*GongStruct]string)
	_ = map_GongStruct_Identifiers

	gongstructOrdered := []*GongStruct{}
	for gongstruct := range stage.GongStructs {
		gongstructOrdered = append(gongstructOrdered, gongstruct)
	}
	sort.Slice(gongstructOrdered[:], func(i, j int) bool {
		return gongstructOrdered[i].Name < gongstructOrdered[j].Name
	})
	identifiersDecl += fmt.Sprintf("\n\n	// Declarations of staged instances of GongStruct")
	for idx, gongstruct := range gongstructOrdered {

		id = generatesIdentifier("GongStruct", idx, gongstruct.Name)
		map_GongStruct_Identifiers[gongstruct] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "GongStruct")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", gongstruct.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// GongStruct %s values setup", gongstruct.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongstruct.Name))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "NbInstances")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%d", gongstruct.NbInstances))
		initializerStatements += setValueField

	}

	map_GongdocCommand_Identifiers := make(map[*GongdocCommand]string)
	_ = map_GongdocCommand_Identifiers

	gongdoccommandOrdered := []*GongdocCommand{}
	for gongdoccommand := range stage.GongdocCommands {
		gongdoccommandOrdered = append(gongdoccommandOrdered, gongdoccommand)
	}
	sort.Slice(gongdoccommandOrdered[:], func(i, j int) bool {
		return gongdoccommandOrdered[i].Name < gongdoccommandOrdered[j].Name
	})
	identifiersDecl += fmt.Sprintf("\n\n	// Declarations of staged instances of GongdocCommand")
	for idx, gongdoccommand := range gongdoccommandOrdered {

		id = generatesIdentifier("GongdocCommand", idx, gongdoccommand.Name)
		map_GongdocCommand_Identifiers[gongdoccommand] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "GongdocCommand")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", gongdoccommand.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// GongdocCommand %s values setup", gongdoccommand.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Command")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.Command))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "DiagramName")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.DiagramName))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Date")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.Date))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "GongdocNodeType")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.GongdocNodeType))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "StructName")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.StructName))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "FieldName")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.FieldName))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "FieldTypeName")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.FieldTypeName))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "PositionX")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%d", gongdoccommand.PositionX))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "PositionY")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%d", gongdoccommand.PositionY))
		initializerStatements += setValueField

	}

	map_GongdocStatus_Identifiers := make(map[*GongdocStatus]string)
	_ = map_GongdocStatus_Identifiers

	gongdocstatusOrdered := []*GongdocStatus{}
	for gongdocstatus := range stage.GongdocStatuss {
		gongdocstatusOrdered = append(gongdocstatusOrdered, gongdocstatus)
	}
	sort.Slice(gongdocstatusOrdered[:], func(i, j int) bool {
		return gongdocstatusOrdered[i].Name < gongdocstatusOrdered[j].Name
	})
	identifiersDecl += fmt.Sprintf("\n\n	// Declarations of staged instances of GongdocStatus")
	for idx, gongdocstatus := range gongdocstatusOrdered {

		id = generatesIdentifier("GongdocStatus", idx, gongdocstatus.Name)
		map_GongdocStatus_Identifiers[gongdocstatus] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "GongdocStatus")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", gongdocstatus.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// GongdocStatus %s values setup", gongdocstatus.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdocstatus.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Status")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdocstatus.Status))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "CommandCompletionDate")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdocstatus.CommandCompletionDate))
		initializerStatements += setValueField

	}

	map_Link_Identifiers := make(map[*Link]string)
	_ = map_Link_Identifiers

	linkOrdered := []*Link{}
	for link := range stage.Links {
		linkOrdered = append(linkOrdered, link)
	}
	sort.Slice(linkOrdered[:], func(i, j int) bool {
		return linkOrdered[i].Name < linkOrdered[j].Name
	})
	identifiersDecl += fmt.Sprintf("\n\n	// Declarations of staged instances of Link")
	for idx, link := range linkOrdered {

		id = generatesIdentifier("Link", idx, link.Name)
		map_Link_Identifiers[link] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Link")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", link.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Link %s values setup", link.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(link.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Fieldname")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(link.Fieldname))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Structname")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(link.Structname))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Fieldtypename")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(link.Fieldtypename))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Multiplicity")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(link.Multiplicity))
		initializerStatements += setValueField

	}

	map_Pkgelt_Identifiers := make(map[*Pkgelt]string)
	_ = map_Pkgelt_Identifiers

	pkgeltOrdered := []*Pkgelt{}
	for pkgelt := range stage.Pkgelts {
		pkgeltOrdered = append(pkgeltOrdered, pkgelt)
	}
	sort.Slice(pkgeltOrdered[:], func(i, j int) bool {
		return pkgeltOrdered[i].Name < pkgeltOrdered[j].Name
	})
	identifiersDecl += fmt.Sprintf("\n\n	// Declarations of staged instances of Pkgelt")
	for idx, pkgelt := range pkgeltOrdered {

		id = generatesIdentifier("Pkgelt", idx, pkgelt.Name)
		map_Pkgelt_Identifiers[pkgelt] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Pkgelt")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", pkgelt.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Pkgelt %s values setup", pkgelt.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(pkgelt.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Path")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(pkgelt.Path))
		initializerStatements += setValueField

	}

	map_Position_Identifiers := make(map[*Position]string)
	_ = map_Position_Identifiers

	positionOrdered := []*Position{}
	for position := range stage.Positions {
		positionOrdered = append(positionOrdered, position)
	}
	sort.Slice(positionOrdered[:], func(i, j int) bool {
		return positionOrdered[i].Name < positionOrdered[j].Name
	})
	identifiersDecl += fmt.Sprintf("\n\n	// Declarations of staged instances of Position")
	for idx, position := range positionOrdered {

		id = generatesIdentifier("Position", idx, position.Name)
		map_Position_Identifiers[position] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Position")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", position.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Position %s values setup", position.Name)
		// Initialisation of values
		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "X")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", position.X))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Y")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", position.Y))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(position.Name))
		initializerStatements += setValueField

	}

	map_UmlState_Identifiers := make(map[*UmlState]string)
	_ = map_UmlState_Identifiers

	umlstateOrdered := []*UmlState{}
	for umlstate := range stage.UmlStates {
		umlstateOrdered = append(umlstateOrdered, umlstate)
	}
	sort.Slice(umlstateOrdered[:], func(i, j int) bool {
		return umlstateOrdered[i].Name < umlstateOrdered[j].Name
	})
	identifiersDecl += fmt.Sprintf("\n\n	// Declarations of staged instances of UmlState")
	for idx, umlstate := range umlstateOrdered {

		id = generatesIdentifier("UmlState", idx, umlstate.Name)
		map_UmlState_Identifiers[umlstate] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "UmlState")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", umlstate.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// UmlState %s values setup", umlstate.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(umlstate.Name))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "X")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", umlstate.X))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Y")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", umlstate.Y))
		initializerStatements += setValueField

	}

	map_Umlsc_Identifiers := make(map[*Umlsc]string)
	_ = map_Umlsc_Identifiers

	umlscOrdered := []*Umlsc{}
	for umlsc := range stage.Umlscs {
		umlscOrdered = append(umlscOrdered, umlsc)
	}
	sort.Slice(umlscOrdered[:], func(i, j int) bool {
		return umlscOrdered[i].Name < umlscOrdered[j].Name
	})
	identifiersDecl += fmt.Sprintf("\n\n	// Declarations of staged instances of Umlsc")
	for idx, umlsc := range umlscOrdered {

		id = generatesIdentifier("Umlsc", idx, umlsc.Name)
		map_Umlsc_Identifiers[umlsc] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Umlsc")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", umlsc.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Umlsc %s values setup", umlsc.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(umlsc.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Activestate")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(umlsc.Activestate))
		initializerStatements += setValueField

	}

	map_Vertice_Identifiers := make(map[*Vertice]string)
	_ = map_Vertice_Identifiers

	verticeOrdered := []*Vertice{}
	for vertice := range stage.Vertices {
		verticeOrdered = append(verticeOrdered, vertice)
	}
	sort.Slice(verticeOrdered[:], func(i, j int) bool {
		return verticeOrdered[i].Name < verticeOrdered[j].Name
	})
	identifiersDecl += fmt.Sprintf("\n\n	// Declarations of staged instances of Vertice")
	for idx, vertice := range verticeOrdered {

		id = generatesIdentifier("Vertice", idx, vertice.Name)
		map_Vertice_Identifiers[vertice] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Vertice")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", vertice.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Vertice %s values setup", vertice.Name)
		// Initialisation of values
		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "X")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", vertice.X))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Y")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", vertice.Y))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(vertice.Name))
		initializerStatements += setValueField

	}


	// insertion initialization of objects to stage
	for idx, classdiagram := range classdiagramOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Classdiagram", idx, classdiagram.Name)
		map_Classdiagram_Identifiers[classdiagram] = id

		// Initialisation of values
		for _, _classshape := range classdiagram.Classshapes {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Classshapes")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Classshape_Identifiers[_classshape])
			pointersInitializesStatements += setPointerField
		}

	}

	for idx, classshape := range classshapeOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Classshape", idx, classshape.Name)
		map_Classshape_Identifiers[classshape] = id

		// Initialisation of values
		if classshape.Position != nil {
			setPointerField = PointerFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Position")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Position_Identifiers[classshape.Position])
			pointersInitializesStatements += setPointerField
		}

		if classshape.GongStruct != nil {
			setPointerField = PointerFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "GongStruct")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_GongStruct_Identifiers[classshape.GongStruct])
			pointersInitializesStatements += setPointerField
		}

		for _, _field := range classshape.Fields {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Fields")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Field_Identifiers[_field])
			pointersInitializesStatements += setPointerField
		}

		for _, _link := range classshape.Links {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Links")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Link_Identifiers[_link])
			pointersInitializesStatements += setPointerField
		}

	}

	for idx, field := range fieldOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Field", idx, field.Name)
		map_Field_Identifiers[field] = id

		// Initialisation of values
	}

	for idx, gongstruct := range gongstructOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("GongStruct", idx, gongstruct.Name)
		map_GongStruct_Identifiers[gongstruct] = id

		// Initialisation of values
	}

	for idx, gongdoccommand := range gongdoccommandOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("GongdocCommand", idx, gongdoccommand.Name)
		map_GongdocCommand_Identifiers[gongdoccommand] = id

		// Initialisation of values
	}

	for idx, gongdocstatus := range gongdocstatusOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("GongdocStatus", idx, gongdocstatus.Name)
		map_GongdocStatus_Identifiers[gongdocstatus] = id

		// Initialisation of values
	}

	for idx, link := range linkOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Link", idx, link.Name)
		map_Link_Identifiers[link] = id

		// Initialisation of values
		if link.Middlevertice != nil {
			setPointerField = PointerFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Middlevertice")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Vertice_Identifiers[link.Middlevertice])
			pointersInitializesStatements += setPointerField
		}

	}

	for idx, pkgelt := range pkgeltOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Pkgelt", idx, pkgelt.Name)
		map_Pkgelt_Identifiers[pkgelt] = id

		// Initialisation of values
		for _, _classdiagram := range pkgelt.Classdiagrams {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Classdiagrams")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Classdiagram_Identifiers[_classdiagram])
			pointersInitializesStatements += setPointerField
		}

		for _, _umlsc := range pkgelt.Umlscs {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Umlscs")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Umlsc_Identifiers[_umlsc])
			pointersInitializesStatements += setPointerField
		}

	}

	for idx, position := range positionOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Position", idx, position.Name)
		map_Position_Identifiers[position] = id

		// Initialisation of values
	}

	for idx, umlstate := range umlstateOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("UmlState", idx, umlstate.Name)
		map_UmlState_Identifiers[umlstate] = id

		// Initialisation of values
	}

	for idx, umlsc := range umlscOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Umlsc", idx, umlsc.Name)
		map_Umlsc_Identifiers[umlsc] = id

		// Initialisation of values
		for _, _umlstate := range umlsc.States {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "States")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_UmlState_Identifiers[_umlstate])
			pointersInitializesStatements += setPointerField
		}

	}

	for idx, vertice := range verticeOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Vertice", idx, vertice.Name)
		map_Vertice_Identifiers[vertice] = id

		// Initialisation of values
	}


	res = strings.ReplaceAll(res, "{{Identifiers}}", identifiersDecl)
	res = strings.ReplaceAll(res, "{{ValueInitializers}}", initializerStatements)
	res = strings.ReplaceAll(res, "{{PointersInitializers}}", pointersInitializesStatements)

	fmt.Fprintln(file, res)
}

// unique identifier per struct
func generatesIdentifier(gongStructName string, idx int, instanceName string) (identifier string) {

	identifier = instanceName
	// Make a Regex to say we only want letters and numbers
	reg, err := regexp.Compile("[^a-zA-Z0-9]+")
	if err != nil {
		log.Fatal(err)
	}
	processedString := reg.ReplaceAllString(instanceName, "_")

	identifier = fmt.Sprintf("__%s__%06d_%s", gongStructName, idx, processedString)

	return
}
