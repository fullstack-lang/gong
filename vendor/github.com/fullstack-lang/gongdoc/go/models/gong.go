// generated by ModelGongFileTemplate
package models

import (
	"fmt"
	"log"
	"os"
	"path"
	"regexp"
	"sort"
	"strings"
)

// swagger:ignore
type __void any

// needed for creating set of instances in the stage
var __member __void

// GongStructInterface is the interface met by GongStructs
// It allows runtime reflexion of instances (without the hassle of the "reflect" package)
type GongStructInterface interface {
	GetName() (res string)
	GetFields() (res []string)
	GetFieldStringValue(fieldName string) (res string)
}

// StageStruct enables storage of staged instances
// swagger:ignore
type StageStruct struct { // insertion point for definition of arrays registering instances
	Classdiagrams           map[*Classdiagram]any
	Classdiagrams_mapString map[string]*Classdiagram

	Classshapes           map[*Classshape]any
	Classshapes_mapString map[string]*Classshape

	Fields           map[*Field]any
	Fields_mapString map[string]*Field

	GongStructs           map[*GongStruct]any
	GongStructs_mapString map[string]*GongStruct

	GongdocCommands           map[*GongdocCommand]any
	GongdocCommands_mapString map[string]*GongdocCommand

	GongdocStatuss           map[*GongdocStatus]any
	GongdocStatuss_mapString map[string]*GongdocStatus

	Links           map[*Link]any
	Links_mapString map[string]*Link

	Notes           map[*Note]any
	Notes_mapString map[string]*Note

	Pkgelts           map[*Pkgelt]any
	Pkgelts_mapString map[string]*Pkgelt

	Positions           map[*Position]any
	Positions_mapString map[string]*Position

	UmlStates           map[*UmlState]any
	UmlStates_mapString map[string]*UmlState

	Umlscs           map[*Umlsc]any
	Umlscs_mapString map[string]*Umlsc

	Vertices           map[*Vertice]any
	Vertices_mapString map[string]*Vertice

	AllModelsStructCreateCallback AllModelsStructCreateInterface

	AllModelsStructDeleteCallback AllModelsStructDeleteInterface

	BackRepo BackRepoInterface

	// if set will be called before each commit to the back repo
	OnInitCommitCallback          OnInitCommitInterface
	OnInitCommitFromFrontCallback OnInitCommitInterface
	OnInitCommitFromBackCallback  OnInitCommitInterface

	// store the number of instance per gongstruct
	Map_GongStructName_InstancesNb map[string]int
}

type OnInitCommitInterface interface {
	BeforeCommit(stage *StageStruct)
}

type BackRepoInterface interface {
	Commit(stage *StageStruct)
	Checkout(stage *StageStruct)
	Backup(stage *StageStruct, dirPath string)
	Restore(stage *StageStruct, dirPath string)
	BackupXL(stage *StageStruct, dirPath string)
	RestoreXL(stage *StageStruct, dirPath string)
	// insertion point for Commit and Checkout signatures
	CommitClassdiagram(classdiagram *Classdiagram)
	CheckoutClassdiagram(classdiagram *Classdiagram)
	CommitClassshape(classshape *Classshape)
	CheckoutClassshape(classshape *Classshape)
	CommitField(field *Field)
	CheckoutField(field *Field)
	CommitGongStruct(gongstruct *GongStruct)
	CheckoutGongStruct(gongstruct *GongStruct)
	CommitGongdocCommand(gongdoccommand *GongdocCommand)
	CheckoutGongdocCommand(gongdoccommand *GongdocCommand)
	CommitGongdocStatus(gongdocstatus *GongdocStatus)
	CheckoutGongdocStatus(gongdocstatus *GongdocStatus)
	CommitLink(link *Link)
	CheckoutLink(link *Link)
	CommitNote(note *Note)
	CheckoutNote(note *Note)
	CommitPkgelt(pkgelt *Pkgelt)
	CheckoutPkgelt(pkgelt *Pkgelt)
	CommitPosition(position *Position)
	CheckoutPosition(position *Position)
	CommitUmlState(umlstate *UmlState)
	CheckoutUmlState(umlstate *UmlState)
	CommitUmlsc(umlsc *Umlsc)
	CheckoutUmlsc(umlsc *Umlsc)
	CommitVertice(vertice *Vertice)
	CheckoutVertice(vertice *Vertice)
	GetLastCommitFromBackNb() uint
	GetLastPushFromFrontNb() uint
}

// swagger:ignore instructs the gong compiler (gongc) to avoid this particular struct
var Stage StageStruct = StageStruct{ // insertion point for array initiatialisation
	Classdiagrams:           make(map[*Classdiagram]any),
	Classdiagrams_mapString: make(map[string]*Classdiagram),

	Classshapes:           make(map[*Classshape]any),
	Classshapes_mapString: make(map[string]*Classshape),

	Fields:           make(map[*Field]any),
	Fields_mapString: make(map[string]*Field),

	GongStructs:           make(map[*GongStruct]any),
	GongStructs_mapString: make(map[string]*GongStruct),

	GongdocCommands:           make(map[*GongdocCommand]any),
	GongdocCommands_mapString: make(map[string]*GongdocCommand),

	GongdocStatuss:           make(map[*GongdocStatus]any),
	GongdocStatuss_mapString: make(map[string]*GongdocStatus),

	Links:           make(map[*Link]any),
	Links_mapString: make(map[string]*Link),

	Notes:           make(map[*Note]any),
	Notes_mapString: make(map[string]*Note),

	Pkgelts:           make(map[*Pkgelt]any),
	Pkgelts_mapString: make(map[string]*Pkgelt),

	Positions:           make(map[*Position]any),
	Positions_mapString: make(map[string]*Position),

	UmlStates:           make(map[*UmlState]any),
	UmlStates_mapString: make(map[string]*UmlState),

	Umlscs:           make(map[*Umlsc]any),
	Umlscs_mapString: make(map[string]*Umlsc),

	Vertices:           make(map[*Vertice]any),
	Vertices_mapString: make(map[string]*Vertice),

	// end of insertion point
	Map_GongStructName_InstancesNb: make(map[string]int),
}

func (stage *StageStruct) Commit() {
	if stage.BackRepo != nil {
		stage.BackRepo.Commit(stage)
	}

	// insertion point for computing the map of number of instances per gongstruct
	stage.Map_GongStructName_InstancesNb["Classdiagram"] = len(stage.Classdiagrams)
	stage.Map_GongStructName_InstancesNb["Classshape"] = len(stage.Classshapes)
	stage.Map_GongStructName_InstancesNb["Field"] = len(stage.Fields)
	stage.Map_GongStructName_InstancesNb["GongStruct"] = len(stage.GongStructs)
	stage.Map_GongStructName_InstancesNb["GongdocCommand"] = len(stage.GongdocCommands)
	stage.Map_GongStructName_InstancesNb["GongdocStatus"] = len(stage.GongdocStatuss)
	stage.Map_GongStructName_InstancesNb["Link"] = len(stage.Links)
	stage.Map_GongStructName_InstancesNb["Note"] = len(stage.Notes)
	stage.Map_GongStructName_InstancesNb["Pkgelt"] = len(stage.Pkgelts)
	stage.Map_GongStructName_InstancesNb["Position"] = len(stage.Positions)
	stage.Map_GongStructName_InstancesNb["UmlState"] = len(stage.UmlStates)
	stage.Map_GongStructName_InstancesNb["Umlsc"] = len(stage.Umlscs)
	stage.Map_GongStructName_InstancesNb["Vertice"] = len(stage.Vertices)

}

func (stage *StageStruct) Checkout() {
	if stage.BackRepo != nil {
		stage.BackRepo.Checkout(stage)
	}

	// insertion point for computing the map of number of instances per gongstruct
	stage.Map_GongStructName_InstancesNb["Classdiagram"] = len(stage.Classdiagrams)
	stage.Map_GongStructName_InstancesNb["Classshape"] = len(stage.Classshapes)
	stage.Map_GongStructName_InstancesNb["Field"] = len(stage.Fields)
	stage.Map_GongStructName_InstancesNb["GongStruct"] = len(stage.GongStructs)
	stage.Map_GongStructName_InstancesNb["GongdocCommand"] = len(stage.GongdocCommands)
	stage.Map_GongStructName_InstancesNb["GongdocStatus"] = len(stage.GongdocStatuss)
	stage.Map_GongStructName_InstancesNb["Link"] = len(stage.Links)
	stage.Map_GongStructName_InstancesNb["Note"] = len(stage.Notes)
	stage.Map_GongStructName_InstancesNb["Pkgelt"] = len(stage.Pkgelts)
	stage.Map_GongStructName_InstancesNb["Position"] = len(stage.Positions)
	stage.Map_GongStructName_InstancesNb["UmlState"] = len(stage.UmlStates)
	stage.Map_GongStructName_InstancesNb["Umlsc"] = len(stage.Umlscs)
	stage.Map_GongStructName_InstancesNb["Vertice"] = len(stage.Vertices)

}

// backup generates backup files in the dirPath
func (stage *StageStruct) Backup(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.Backup(stage, dirPath)
	}
}

// Restore resets Stage & BackRepo and restores their content from the restore files in dirPath
func (stage *StageStruct) Restore(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.Restore(stage, dirPath)
	}
}

// backup generates backup files in the dirPath
func (stage *StageStruct) BackupXL(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.BackupXL(stage, dirPath)
	}
}

// Restore resets Stage & BackRepo and restores their content from the restore files in dirPath
func (stage *StageStruct) RestoreXL(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.RestoreXL(stage, dirPath)
	}
}

// insertion point for cumulative sub template with model space calls
// Stage puts classdiagram to the model stage
func (classdiagram *Classdiagram) Stage() *Classdiagram {
	Stage.Classdiagrams[classdiagram] = __member
	Stage.Classdiagrams_mapString[classdiagram.Name] = classdiagram

	return classdiagram
}

// Unstage removes classdiagram off the model stage
func (classdiagram *Classdiagram) Unstage() *Classdiagram {
	delete(Stage.Classdiagrams, classdiagram)
	delete(Stage.Classdiagrams_mapString, classdiagram.Name)
	return classdiagram
}

// commit classdiagram to the back repo (if it is already staged)
func (classdiagram *Classdiagram) Commit() *Classdiagram {
	if _, ok := Stage.Classdiagrams[classdiagram]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitClassdiagram(classdiagram)
		}
	}
	return classdiagram
}

// Checkout classdiagram to the back repo (if it is already staged)
func (classdiagram *Classdiagram) Checkout() *Classdiagram {
	if _, ok := Stage.Classdiagrams[classdiagram]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutClassdiagram(classdiagram)
		}
	}
	return classdiagram
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of classdiagram to the model stage
func (classdiagram *Classdiagram) StageCopy() *Classdiagram {
	_classdiagram := new(Classdiagram)
	*_classdiagram = *classdiagram
	_classdiagram.Stage()
	return _classdiagram
}

// StageAndCommit appends classdiagram to the model stage and commit to the orm repo
func (classdiagram *Classdiagram) StageAndCommit() *Classdiagram {
	classdiagram.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassdiagram(classdiagram)
	}
	return classdiagram
}

// DeleteStageAndCommit appends classdiagram to the model stage and commit to the orm repo
func (classdiagram *Classdiagram) DeleteStageAndCommit() *Classdiagram {
	classdiagram.Unstage()
	DeleteORMClassdiagram(classdiagram)
	return classdiagram
}

// StageCopyAndCommit appends a copy of classdiagram to the model stage and commit to the orm repo
func (classdiagram *Classdiagram) StageCopyAndCommit() *Classdiagram {
	_classdiagram := new(Classdiagram)
	*_classdiagram = *classdiagram
	_classdiagram.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassdiagram(classdiagram)
	}
	return _classdiagram
}

// CreateORMClassdiagram enables dynamic staging of a Classdiagram instance
func CreateORMClassdiagram(classdiagram *Classdiagram) {
	classdiagram.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassdiagram(classdiagram)
	}
}

// DeleteORMClassdiagram enables dynamic staging of a Classdiagram instance
func DeleteORMClassdiagram(classdiagram *Classdiagram) {
	classdiagram.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMClassdiagram(classdiagram)
	}
}

// for satisfaction of GongStruct interface
func (classdiagram *Classdiagram) GetName() (res string) {
	return classdiagram.Name
}

// Stage puts classshape to the model stage
func (classshape *Classshape) Stage() *Classshape {
	Stage.Classshapes[classshape] = __member
	Stage.Classshapes_mapString[classshape.Name] = classshape

	return classshape
}

// Unstage removes classshape off the model stage
func (classshape *Classshape) Unstage() *Classshape {
	delete(Stage.Classshapes, classshape)
	delete(Stage.Classshapes_mapString, classshape.Name)
	return classshape
}

// commit classshape to the back repo (if it is already staged)
func (classshape *Classshape) Commit() *Classshape {
	if _, ok := Stage.Classshapes[classshape]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitClassshape(classshape)
		}
	}
	return classshape
}

// Checkout classshape to the back repo (if it is already staged)
func (classshape *Classshape) Checkout() *Classshape {
	if _, ok := Stage.Classshapes[classshape]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutClassshape(classshape)
		}
	}
	return classshape
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of classshape to the model stage
func (classshape *Classshape) StageCopy() *Classshape {
	_classshape := new(Classshape)
	*_classshape = *classshape
	_classshape.Stage()
	return _classshape
}

// StageAndCommit appends classshape to the model stage and commit to the orm repo
func (classshape *Classshape) StageAndCommit() *Classshape {
	classshape.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassshape(classshape)
	}
	return classshape
}

// DeleteStageAndCommit appends classshape to the model stage and commit to the orm repo
func (classshape *Classshape) DeleteStageAndCommit() *Classshape {
	classshape.Unstage()
	DeleteORMClassshape(classshape)
	return classshape
}

// StageCopyAndCommit appends a copy of classshape to the model stage and commit to the orm repo
func (classshape *Classshape) StageCopyAndCommit() *Classshape {
	_classshape := new(Classshape)
	*_classshape = *classshape
	_classshape.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassshape(classshape)
	}
	return _classshape
}

// CreateORMClassshape enables dynamic staging of a Classshape instance
func CreateORMClassshape(classshape *Classshape) {
	classshape.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMClassshape(classshape)
	}
}

// DeleteORMClassshape enables dynamic staging of a Classshape instance
func DeleteORMClassshape(classshape *Classshape) {
	classshape.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMClassshape(classshape)
	}
}

// for satisfaction of GongStruct interface
func (classshape *Classshape) GetName() (res string) {
	return classshape.Name
}

// Stage puts field to the model stage
func (field *Field) Stage() *Field {
	Stage.Fields[field] = __member
	Stage.Fields_mapString[field.Name] = field

	return field
}

// Unstage removes field off the model stage
func (field *Field) Unstage() *Field {
	delete(Stage.Fields, field)
	delete(Stage.Fields_mapString, field.Name)
	return field
}

// commit field to the back repo (if it is already staged)
func (field *Field) Commit() *Field {
	if _, ok := Stage.Fields[field]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitField(field)
		}
	}
	return field
}

// Checkout field to the back repo (if it is already staged)
func (field *Field) Checkout() *Field {
	if _, ok := Stage.Fields[field]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutField(field)
		}
	}
	return field
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of field to the model stage
func (field *Field) StageCopy() *Field {
	_field := new(Field)
	*_field = *field
	_field.Stage()
	return _field
}

// StageAndCommit appends field to the model stage and commit to the orm repo
func (field *Field) StageAndCommit() *Field {
	field.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMField(field)
	}
	return field
}

// DeleteStageAndCommit appends field to the model stage and commit to the orm repo
func (field *Field) DeleteStageAndCommit() *Field {
	field.Unstage()
	DeleteORMField(field)
	return field
}

// StageCopyAndCommit appends a copy of field to the model stage and commit to the orm repo
func (field *Field) StageCopyAndCommit() *Field {
	_field := new(Field)
	*_field = *field
	_field.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMField(field)
	}
	return _field
}

// CreateORMField enables dynamic staging of a Field instance
func CreateORMField(field *Field) {
	field.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMField(field)
	}
}

// DeleteORMField enables dynamic staging of a Field instance
func DeleteORMField(field *Field) {
	field.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMField(field)
	}
}

// for satisfaction of GongStruct interface
func (field *Field) GetName() (res string) {
	return field.Name
}

// Stage puts gongstruct to the model stage
func (gongstruct *GongStruct) Stage() *GongStruct {
	Stage.GongStructs[gongstruct] = __member
	Stage.GongStructs_mapString[gongstruct.Name] = gongstruct

	return gongstruct
}

// Unstage removes gongstruct off the model stage
func (gongstruct *GongStruct) Unstage() *GongStruct {
	delete(Stage.GongStructs, gongstruct)
	delete(Stage.GongStructs_mapString, gongstruct.Name)
	return gongstruct
}

// commit gongstruct to the back repo (if it is already staged)
func (gongstruct *GongStruct) Commit() *GongStruct {
	if _, ok := Stage.GongStructs[gongstruct]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitGongStruct(gongstruct)
		}
	}
	return gongstruct
}

// Checkout gongstruct to the back repo (if it is already staged)
func (gongstruct *GongStruct) Checkout() *GongStruct {
	if _, ok := Stage.GongStructs[gongstruct]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutGongStruct(gongstruct)
		}
	}
	return gongstruct
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of gongstruct to the model stage
func (gongstruct *GongStruct) StageCopy() *GongStruct {
	_gongstruct := new(GongStruct)
	*_gongstruct = *gongstruct
	_gongstruct.Stage()
	return _gongstruct
}

// StageAndCommit appends gongstruct to the model stage and commit to the orm repo
func (gongstruct *GongStruct) StageAndCommit() *GongStruct {
	gongstruct.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongStruct(gongstruct)
	}
	return gongstruct
}

// DeleteStageAndCommit appends gongstruct to the model stage and commit to the orm repo
func (gongstruct *GongStruct) DeleteStageAndCommit() *GongStruct {
	gongstruct.Unstage()
	DeleteORMGongStruct(gongstruct)
	return gongstruct
}

// StageCopyAndCommit appends a copy of gongstruct to the model stage and commit to the orm repo
func (gongstruct *GongStruct) StageCopyAndCommit() *GongStruct {
	_gongstruct := new(GongStruct)
	*_gongstruct = *gongstruct
	_gongstruct.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongStruct(gongstruct)
	}
	return _gongstruct
}

// CreateORMGongStruct enables dynamic staging of a GongStruct instance
func CreateORMGongStruct(gongstruct *GongStruct) {
	gongstruct.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongStruct(gongstruct)
	}
}

// DeleteORMGongStruct enables dynamic staging of a GongStruct instance
func DeleteORMGongStruct(gongstruct *GongStruct) {
	gongstruct.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMGongStruct(gongstruct)
	}
}

// for satisfaction of GongStruct interface
func (gongstruct *GongStruct) GetName() (res string) {
	return gongstruct.Name
}

// Stage puts gongdoccommand to the model stage
func (gongdoccommand *GongdocCommand) Stage() *GongdocCommand {
	Stage.GongdocCommands[gongdoccommand] = __member
	Stage.GongdocCommands_mapString[gongdoccommand.Name] = gongdoccommand

	return gongdoccommand
}

// Unstage removes gongdoccommand off the model stage
func (gongdoccommand *GongdocCommand) Unstage() *GongdocCommand {
	delete(Stage.GongdocCommands, gongdoccommand)
	delete(Stage.GongdocCommands_mapString, gongdoccommand.Name)
	return gongdoccommand
}

// commit gongdoccommand to the back repo (if it is already staged)
func (gongdoccommand *GongdocCommand) Commit() *GongdocCommand {
	if _, ok := Stage.GongdocCommands[gongdoccommand]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitGongdocCommand(gongdoccommand)
		}
	}
	return gongdoccommand
}

// Checkout gongdoccommand to the back repo (if it is already staged)
func (gongdoccommand *GongdocCommand) Checkout() *GongdocCommand {
	if _, ok := Stage.GongdocCommands[gongdoccommand]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutGongdocCommand(gongdoccommand)
		}
	}
	return gongdoccommand
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of gongdoccommand to the model stage
func (gongdoccommand *GongdocCommand) StageCopy() *GongdocCommand {
	_gongdoccommand := new(GongdocCommand)
	*_gongdoccommand = *gongdoccommand
	_gongdoccommand.Stage()
	return _gongdoccommand
}

// StageAndCommit appends gongdoccommand to the model stage and commit to the orm repo
func (gongdoccommand *GongdocCommand) StageAndCommit() *GongdocCommand {
	gongdoccommand.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocCommand(gongdoccommand)
	}
	return gongdoccommand
}

// DeleteStageAndCommit appends gongdoccommand to the model stage and commit to the orm repo
func (gongdoccommand *GongdocCommand) DeleteStageAndCommit() *GongdocCommand {
	gongdoccommand.Unstage()
	DeleteORMGongdocCommand(gongdoccommand)
	return gongdoccommand
}

// StageCopyAndCommit appends a copy of gongdoccommand to the model stage and commit to the orm repo
func (gongdoccommand *GongdocCommand) StageCopyAndCommit() *GongdocCommand {
	_gongdoccommand := new(GongdocCommand)
	*_gongdoccommand = *gongdoccommand
	_gongdoccommand.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocCommand(gongdoccommand)
	}
	return _gongdoccommand
}

// CreateORMGongdocCommand enables dynamic staging of a GongdocCommand instance
func CreateORMGongdocCommand(gongdoccommand *GongdocCommand) {
	gongdoccommand.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocCommand(gongdoccommand)
	}
}

// DeleteORMGongdocCommand enables dynamic staging of a GongdocCommand instance
func DeleteORMGongdocCommand(gongdoccommand *GongdocCommand) {
	gongdoccommand.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMGongdocCommand(gongdoccommand)
	}
}

// for satisfaction of GongStruct interface
func (gongdoccommand *GongdocCommand) GetName() (res string) {
	return gongdoccommand.Name
}

// Stage puts gongdocstatus to the model stage
func (gongdocstatus *GongdocStatus) Stage() *GongdocStatus {
	Stage.GongdocStatuss[gongdocstatus] = __member
	Stage.GongdocStatuss_mapString[gongdocstatus.Name] = gongdocstatus

	return gongdocstatus
}

// Unstage removes gongdocstatus off the model stage
func (gongdocstatus *GongdocStatus) Unstage() *GongdocStatus {
	delete(Stage.GongdocStatuss, gongdocstatus)
	delete(Stage.GongdocStatuss_mapString, gongdocstatus.Name)
	return gongdocstatus
}

// commit gongdocstatus to the back repo (if it is already staged)
func (gongdocstatus *GongdocStatus) Commit() *GongdocStatus {
	if _, ok := Stage.GongdocStatuss[gongdocstatus]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitGongdocStatus(gongdocstatus)
		}
	}
	return gongdocstatus
}

// Checkout gongdocstatus to the back repo (if it is already staged)
func (gongdocstatus *GongdocStatus) Checkout() *GongdocStatus {
	if _, ok := Stage.GongdocStatuss[gongdocstatus]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutGongdocStatus(gongdocstatus)
		}
	}
	return gongdocstatus
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of gongdocstatus to the model stage
func (gongdocstatus *GongdocStatus) StageCopy() *GongdocStatus {
	_gongdocstatus := new(GongdocStatus)
	*_gongdocstatus = *gongdocstatus
	_gongdocstatus.Stage()
	return _gongdocstatus
}

// StageAndCommit appends gongdocstatus to the model stage and commit to the orm repo
func (gongdocstatus *GongdocStatus) StageAndCommit() *GongdocStatus {
	gongdocstatus.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocStatus(gongdocstatus)
	}
	return gongdocstatus
}

// DeleteStageAndCommit appends gongdocstatus to the model stage and commit to the orm repo
func (gongdocstatus *GongdocStatus) DeleteStageAndCommit() *GongdocStatus {
	gongdocstatus.Unstage()
	DeleteORMGongdocStatus(gongdocstatus)
	return gongdocstatus
}

// StageCopyAndCommit appends a copy of gongdocstatus to the model stage and commit to the orm repo
func (gongdocstatus *GongdocStatus) StageCopyAndCommit() *GongdocStatus {
	_gongdocstatus := new(GongdocStatus)
	*_gongdocstatus = *gongdocstatus
	_gongdocstatus.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocStatus(gongdocstatus)
	}
	return _gongdocstatus
}

// CreateORMGongdocStatus enables dynamic staging of a GongdocStatus instance
func CreateORMGongdocStatus(gongdocstatus *GongdocStatus) {
	gongdocstatus.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMGongdocStatus(gongdocstatus)
	}
}

// DeleteORMGongdocStatus enables dynamic staging of a GongdocStatus instance
func DeleteORMGongdocStatus(gongdocstatus *GongdocStatus) {
	gongdocstatus.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMGongdocStatus(gongdocstatus)
	}
}

// for satisfaction of GongStruct interface
func (gongdocstatus *GongdocStatus) GetName() (res string) {
	return gongdocstatus.Name
}

// Stage puts link to the model stage
func (link *Link) Stage() *Link {
	Stage.Links[link] = __member
	Stage.Links_mapString[link.Name] = link

	return link
}

// Unstage removes link off the model stage
func (link *Link) Unstage() *Link {
	delete(Stage.Links, link)
	delete(Stage.Links_mapString, link.Name)
	return link
}

// commit link to the back repo (if it is already staged)
func (link *Link) Commit() *Link {
	if _, ok := Stage.Links[link]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitLink(link)
		}
	}
	return link
}

// Checkout link to the back repo (if it is already staged)
func (link *Link) Checkout() *Link {
	if _, ok := Stage.Links[link]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutLink(link)
		}
	}
	return link
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of link to the model stage
func (link *Link) StageCopy() *Link {
	_link := new(Link)
	*_link = *link
	_link.Stage()
	return _link
}

// StageAndCommit appends link to the model stage and commit to the orm repo
func (link *Link) StageAndCommit() *Link {
	link.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLink(link)
	}
	return link
}

// DeleteStageAndCommit appends link to the model stage and commit to the orm repo
func (link *Link) DeleteStageAndCommit() *Link {
	link.Unstage()
	DeleteORMLink(link)
	return link
}

// StageCopyAndCommit appends a copy of link to the model stage and commit to the orm repo
func (link *Link) StageCopyAndCommit() *Link {
	_link := new(Link)
	*_link = *link
	_link.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLink(link)
	}
	return _link
}

// CreateORMLink enables dynamic staging of a Link instance
func CreateORMLink(link *Link) {
	link.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMLink(link)
	}
}

// DeleteORMLink enables dynamic staging of a Link instance
func DeleteORMLink(link *Link) {
	link.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMLink(link)
	}
}

// for satisfaction of GongStruct interface
func (link *Link) GetName() (res string) {
	return link.Name
}

// Stage puts note to the model stage
func (note *Note) Stage() *Note {
	Stage.Notes[note] = __member
	Stage.Notes_mapString[note.Name] = note

	return note
}

// Unstage removes note off the model stage
func (note *Note) Unstage() *Note {
	delete(Stage.Notes, note)
	delete(Stage.Notes_mapString, note.Name)
	return note
}

// commit note to the back repo (if it is already staged)
func (note *Note) Commit() *Note {
	if _, ok := Stage.Notes[note]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitNote(note)
		}
	}
	return note
}

// Checkout note to the back repo (if it is already staged)
func (note *Note) Checkout() *Note {
	if _, ok := Stage.Notes[note]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutNote(note)
		}
	}
	return note
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of note to the model stage
func (note *Note) StageCopy() *Note {
	_note := new(Note)
	*_note = *note
	_note.Stage()
	return _note
}

// StageAndCommit appends note to the model stage and commit to the orm repo
func (note *Note) StageAndCommit() *Note {
	note.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMNote(note)
	}
	return note
}

// DeleteStageAndCommit appends note to the model stage and commit to the orm repo
func (note *Note) DeleteStageAndCommit() *Note {
	note.Unstage()
	DeleteORMNote(note)
	return note
}

// StageCopyAndCommit appends a copy of note to the model stage and commit to the orm repo
func (note *Note) StageCopyAndCommit() *Note {
	_note := new(Note)
	*_note = *note
	_note.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMNote(note)
	}
	return _note
}

// CreateORMNote enables dynamic staging of a Note instance
func CreateORMNote(note *Note) {
	note.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMNote(note)
	}
}

// DeleteORMNote enables dynamic staging of a Note instance
func DeleteORMNote(note *Note) {
	note.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMNote(note)
	}
}

// for satisfaction of GongStruct interface
func (note *Note) GetName() (res string) {
	return note.Name
}

// Stage puts pkgelt to the model stage
func (pkgelt *Pkgelt) Stage() *Pkgelt {
	Stage.Pkgelts[pkgelt] = __member
	Stage.Pkgelts_mapString[pkgelt.Name] = pkgelt

	return pkgelt
}

// Unstage removes pkgelt off the model stage
func (pkgelt *Pkgelt) Unstage() *Pkgelt {
	delete(Stage.Pkgelts, pkgelt)
	delete(Stage.Pkgelts_mapString, pkgelt.Name)
	return pkgelt
}

// commit pkgelt to the back repo (if it is already staged)
func (pkgelt *Pkgelt) Commit() *Pkgelt {
	if _, ok := Stage.Pkgelts[pkgelt]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitPkgelt(pkgelt)
		}
	}
	return pkgelt
}

// Checkout pkgelt to the back repo (if it is already staged)
func (pkgelt *Pkgelt) Checkout() *Pkgelt {
	if _, ok := Stage.Pkgelts[pkgelt]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutPkgelt(pkgelt)
		}
	}
	return pkgelt
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of pkgelt to the model stage
func (pkgelt *Pkgelt) StageCopy() *Pkgelt {
	_pkgelt := new(Pkgelt)
	*_pkgelt = *pkgelt
	_pkgelt.Stage()
	return _pkgelt
}

// StageAndCommit appends pkgelt to the model stage and commit to the orm repo
func (pkgelt *Pkgelt) StageAndCommit() *Pkgelt {
	pkgelt.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPkgelt(pkgelt)
	}
	return pkgelt
}

// DeleteStageAndCommit appends pkgelt to the model stage and commit to the orm repo
func (pkgelt *Pkgelt) DeleteStageAndCommit() *Pkgelt {
	pkgelt.Unstage()
	DeleteORMPkgelt(pkgelt)
	return pkgelt
}

// StageCopyAndCommit appends a copy of pkgelt to the model stage and commit to the orm repo
func (pkgelt *Pkgelt) StageCopyAndCommit() *Pkgelt {
	_pkgelt := new(Pkgelt)
	*_pkgelt = *pkgelt
	_pkgelt.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPkgelt(pkgelt)
	}
	return _pkgelt
}

// CreateORMPkgelt enables dynamic staging of a Pkgelt instance
func CreateORMPkgelt(pkgelt *Pkgelt) {
	pkgelt.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPkgelt(pkgelt)
	}
}

// DeleteORMPkgelt enables dynamic staging of a Pkgelt instance
func DeleteORMPkgelt(pkgelt *Pkgelt) {
	pkgelt.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMPkgelt(pkgelt)
	}
}

// for satisfaction of GongStruct interface
func (pkgelt *Pkgelt) GetName() (res string) {
	return pkgelt.Name
}

// Stage puts position to the model stage
func (position *Position) Stage() *Position {
	Stage.Positions[position] = __member
	Stage.Positions_mapString[position.Name] = position

	return position
}

// Unstage removes position off the model stage
func (position *Position) Unstage() *Position {
	delete(Stage.Positions, position)
	delete(Stage.Positions_mapString, position.Name)
	return position
}

// commit position to the back repo (if it is already staged)
func (position *Position) Commit() *Position {
	if _, ok := Stage.Positions[position]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitPosition(position)
		}
	}
	return position
}

// Checkout position to the back repo (if it is already staged)
func (position *Position) Checkout() *Position {
	if _, ok := Stage.Positions[position]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutPosition(position)
		}
	}
	return position
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of position to the model stage
func (position *Position) StageCopy() *Position {
	_position := new(Position)
	*_position = *position
	_position.Stage()
	return _position
}

// StageAndCommit appends position to the model stage and commit to the orm repo
func (position *Position) StageAndCommit() *Position {
	position.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPosition(position)
	}
	return position
}

// DeleteStageAndCommit appends position to the model stage and commit to the orm repo
func (position *Position) DeleteStageAndCommit() *Position {
	position.Unstage()
	DeleteORMPosition(position)
	return position
}

// StageCopyAndCommit appends a copy of position to the model stage and commit to the orm repo
func (position *Position) StageCopyAndCommit() *Position {
	_position := new(Position)
	*_position = *position
	_position.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPosition(position)
	}
	return _position
}

// CreateORMPosition enables dynamic staging of a Position instance
func CreateORMPosition(position *Position) {
	position.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMPosition(position)
	}
}

// DeleteORMPosition enables dynamic staging of a Position instance
func DeleteORMPosition(position *Position) {
	position.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMPosition(position)
	}
}

// for satisfaction of GongStruct interface
func (position *Position) GetName() (res string) {
	return position.Name
}

// Stage puts umlstate to the model stage
func (umlstate *UmlState) Stage() *UmlState {
	Stage.UmlStates[umlstate] = __member
	Stage.UmlStates_mapString[umlstate.Name] = umlstate

	return umlstate
}

// Unstage removes umlstate off the model stage
func (umlstate *UmlState) Unstage() *UmlState {
	delete(Stage.UmlStates, umlstate)
	delete(Stage.UmlStates_mapString, umlstate.Name)
	return umlstate
}

// commit umlstate to the back repo (if it is already staged)
func (umlstate *UmlState) Commit() *UmlState {
	if _, ok := Stage.UmlStates[umlstate]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitUmlState(umlstate)
		}
	}
	return umlstate
}

// Checkout umlstate to the back repo (if it is already staged)
func (umlstate *UmlState) Checkout() *UmlState {
	if _, ok := Stage.UmlStates[umlstate]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutUmlState(umlstate)
		}
	}
	return umlstate
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of umlstate to the model stage
func (umlstate *UmlState) StageCopy() *UmlState {
	_umlstate := new(UmlState)
	*_umlstate = *umlstate
	_umlstate.Stage()
	return _umlstate
}

// StageAndCommit appends umlstate to the model stage and commit to the orm repo
func (umlstate *UmlState) StageAndCommit() *UmlState {
	umlstate.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlState(umlstate)
	}
	return umlstate
}

// DeleteStageAndCommit appends umlstate to the model stage and commit to the orm repo
func (umlstate *UmlState) DeleteStageAndCommit() *UmlState {
	umlstate.Unstage()
	DeleteORMUmlState(umlstate)
	return umlstate
}

// StageCopyAndCommit appends a copy of umlstate to the model stage and commit to the orm repo
func (umlstate *UmlState) StageCopyAndCommit() *UmlState {
	_umlstate := new(UmlState)
	*_umlstate = *umlstate
	_umlstate.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlState(umlstate)
	}
	return _umlstate
}

// CreateORMUmlState enables dynamic staging of a UmlState instance
func CreateORMUmlState(umlstate *UmlState) {
	umlstate.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlState(umlstate)
	}
}

// DeleteORMUmlState enables dynamic staging of a UmlState instance
func DeleteORMUmlState(umlstate *UmlState) {
	umlstate.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMUmlState(umlstate)
	}
}

// for satisfaction of GongStruct interface
func (umlstate *UmlState) GetName() (res string) {
	return umlstate.Name
}

// Stage puts umlsc to the model stage
func (umlsc *Umlsc) Stage() *Umlsc {
	Stage.Umlscs[umlsc] = __member
	Stage.Umlscs_mapString[umlsc.Name] = umlsc

	return umlsc
}

// Unstage removes umlsc off the model stage
func (umlsc *Umlsc) Unstage() *Umlsc {
	delete(Stage.Umlscs, umlsc)
	delete(Stage.Umlscs_mapString, umlsc.Name)
	return umlsc
}

// commit umlsc to the back repo (if it is already staged)
func (umlsc *Umlsc) Commit() *Umlsc {
	if _, ok := Stage.Umlscs[umlsc]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitUmlsc(umlsc)
		}
	}
	return umlsc
}

// Checkout umlsc to the back repo (if it is already staged)
func (umlsc *Umlsc) Checkout() *Umlsc {
	if _, ok := Stage.Umlscs[umlsc]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutUmlsc(umlsc)
		}
	}
	return umlsc
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of umlsc to the model stage
func (umlsc *Umlsc) StageCopy() *Umlsc {
	_umlsc := new(Umlsc)
	*_umlsc = *umlsc
	_umlsc.Stage()
	return _umlsc
}

// StageAndCommit appends umlsc to the model stage and commit to the orm repo
func (umlsc *Umlsc) StageAndCommit() *Umlsc {
	umlsc.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlsc(umlsc)
	}
	return umlsc
}

// DeleteStageAndCommit appends umlsc to the model stage and commit to the orm repo
func (umlsc *Umlsc) DeleteStageAndCommit() *Umlsc {
	umlsc.Unstage()
	DeleteORMUmlsc(umlsc)
	return umlsc
}

// StageCopyAndCommit appends a copy of umlsc to the model stage and commit to the orm repo
func (umlsc *Umlsc) StageCopyAndCommit() *Umlsc {
	_umlsc := new(Umlsc)
	*_umlsc = *umlsc
	_umlsc.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlsc(umlsc)
	}
	return _umlsc
}

// CreateORMUmlsc enables dynamic staging of a Umlsc instance
func CreateORMUmlsc(umlsc *Umlsc) {
	umlsc.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMUmlsc(umlsc)
	}
}

// DeleteORMUmlsc enables dynamic staging of a Umlsc instance
func DeleteORMUmlsc(umlsc *Umlsc) {
	umlsc.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMUmlsc(umlsc)
	}
}

// for satisfaction of GongStruct interface
func (umlsc *Umlsc) GetName() (res string) {
	return umlsc.Name
}

// Stage puts vertice to the model stage
func (vertice *Vertice) Stage() *Vertice {
	Stage.Vertices[vertice] = __member
	Stage.Vertices_mapString[vertice.Name] = vertice

	return vertice
}

// Unstage removes vertice off the model stage
func (vertice *Vertice) Unstage() *Vertice {
	delete(Stage.Vertices, vertice)
	delete(Stage.Vertices_mapString, vertice.Name)
	return vertice
}

// commit vertice to the back repo (if it is already staged)
func (vertice *Vertice) Commit() *Vertice {
	if _, ok := Stage.Vertices[vertice]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitVertice(vertice)
		}
	}
	return vertice
}

// Checkout vertice to the back repo (if it is already staged)
func (vertice *Vertice) Checkout() *Vertice {
	if _, ok := Stage.Vertices[vertice]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutVertice(vertice)
		}
	}
	return vertice
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of vertice to the model stage
func (vertice *Vertice) StageCopy() *Vertice {
	_vertice := new(Vertice)
	*_vertice = *vertice
	_vertice.Stage()
	return _vertice
}

// StageAndCommit appends vertice to the model stage and commit to the orm repo
func (vertice *Vertice) StageAndCommit() *Vertice {
	vertice.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVertice(vertice)
	}
	return vertice
}

// DeleteStageAndCommit appends vertice to the model stage and commit to the orm repo
func (vertice *Vertice) DeleteStageAndCommit() *Vertice {
	vertice.Unstage()
	DeleteORMVertice(vertice)
	return vertice
}

// StageCopyAndCommit appends a copy of vertice to the model stage and commit to the orm repo
func (vertice *Vertice) StageCopyAndCommit() *Vertice {
	_vertice := new(Vertice)
	*_vertice = *vertice
	_vertice.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVertice(vertice)
	}
	return _vertice
}

// CreateORMVertice enables dynamic staging of a Vertice instance
func CreateORMVertice(vertice *Vertice) {
	vertice.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVertice(vertice)
	}
}

// DeleteORMVertice enables dynamic staging of a Vertice instance
func DeleteORMVertice(vertice *Vertice) {
	vertice.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMVertice(vertice)
	}
}

// for satisfaction of GongStruct interface
func (vertice *Vertice) GetName() (res string) {
	return vertice.Name
}

// swagger:ignore
type AllModelsStructCreateInterface interface { // insertion point for Callbacks on creation
	CreateORMClassdiagram(Classdiagram *Classdiagram)
	CreateORMClassshape(Classshape *Classshape)
	CreateORMField(Field *Field)
	CreateORMGongStruct(GongStruct *GongStruct)
	CreateORMGongdocCommand(GongdocCommand *GongdocCommand)
	CreateORMGongdocStatus(GongdocStatus *GongdocStatus)
	CreateORMLink(Link *Link)
	CreateORMNote(Note *Note)
	CreateORMPkgelt(Pkgelt *Pkgelt)
	CreateORMPosition(Position *Position)
	CreateORMUmlState(UmlState *UmlState)
	CreateORMUmlsc(Umlsc *Umlsc)
	CreateORMVertice(Vertice *Vertice)
}

type AllModelsStructDeleteInterface interface { // insertion point for Callbacks on deletion
	DeleteORMClassdiagram(Classdiagram *Classdiagram)
	DeleteORMClassshape(Classshape *Classshape)
	DeleteORMField(Field *Field)
	DeleteORMGongStruct(GongStruct *GongStruct)
	DeleteORMGongdocCommand(GongdocCommand *GongdocCommand)
	DeleteORMGongdocStatus(GongdocStatus *GongdocStatus)
	DeleteORMLink(Link *Link)
	DeleteORMNote(Note *Note)
	DeleteORMPkgelt(Pkgelt *Pkgelt)
	DeleteORMPosition(Position *Position)
	DeleteORMUmlState(UmlState *UmlState)
	DeleteORMUmlsc(Umlsc *Umlsc)
	DeleteORMVertice(Vertice *Vertice)
}

func (stage *StageStruct) Reset() { // insertion point for array reset
	stage.Classdiagrams = make(map[*Classdiagram]any)
	stage.Classdiagrams_mapString = make(map[string]*Classdiagram)

	stage.Classshapes = make(map[*Classshape]any)
	stage.Classshapes_mapString = make(map[string]*Classshape)

	stage.Fields = make(map[*Field]any)
	stage.Fields_mapString = make(map[string]*Field)

	stage.GongStructs = make(map[*GongStruct]any)
	stage.GongStructs_mapString = make(map[string]*GongStruct)

	stage.GongdocCommands = make(map[*GongdocCommand]any)
	stage.GongdocCommands_mapString = make(map[string]*GongdocCommand)

	stage.GongdocStatuss = make(map[*GongdocStatus]any)
	stage.GongdocStatuss_mapString = make(map[string]*GongdocStatus)

	stage.Links = make(map[*Link]any)
	stage.Links_mapString = make(map[string]*Link)

	stage.Notes = make(map[*Note]any)
	stage.Notes_mapString = make(map[string]*Note)

	stage.Pkgelts = make(map[*Pkgelt]any)
	stage.Pkgelts_mapString = make(map[string]*Pkgelt)

	stage.Positions = make(map[*Position]any)
	stage.Positions_mapString = make(map[string]*Position)

	stage.UmlStates = make(map[*UmlState]any)
	stage.UmlStates_mapString = make(map[string]*UmlState)

	stage.Umlscs = make(map[*Umlsc]any)
	stage.Umlscs_mapString = make(map[string]*Umlsc)

	stage.Vertices = make(map[*Vertice]any)
	stage.Vertices_mapString = make(map[string]*Vertice)

}

func (stage *StageStruct) Nil() { // insertion point for array nil
	stage.Classdiagrams = nil
	stage.Classdiagrams_mapString = nil

	stage.Classshapes = nil
	stage.Classshapes_mapString = nil

	stage.Fields = nil
	stage.Fields_mapString = nil

	stage.GongStructs = nil
	stage.GongStructs_mapString = nil

	stage.GongdocCommands = nil
	stage.GongdocCommands_mapString = nil

	stage.GongdocStatuss = nil
	stage.GongdocStatuss_mapString = nil

	stage.Links = nil
	stage.Links_mapString = nil

	stage.Notes = nil
	stage.Notes_mapString = nil

	stage.Pkgelts = nil
	stage.Pkgelts_mapString = nil

	stage.Positions = nil
	stage.Positions_mapString = nil

	stage.UmlStates = nil
	stage.UmlStates_mapString = nil

	stage.Umlscs = nil
	stage.Umlscs_mapString = nil

	stage.Vertices = nil
	stage.Vertices_mapString = nil

}

const marshallRes = `package {{PackageName}}

import (
	"time"

	"{{ModelsPackageName}}"
)

func init() {
	var __Dummy_time_variable time.Time
	_ = __Dummy_time_variable
	InjectionGateway["{{databaseName}}"] = {{databaseName}}Injection
}

// {{databaseName}}Injection will stage objects of database "{{databaseName}}"
func {{databaseName}}Injection() {

	// Declaration of instances to stage{{Identifiers}}

	// Setup of values{{ValueInitializers}}

	// Setup of pointers{{PointersInitializers}}
}

`

const IdentifiersDecls = `
	{{Identifier}} := (&models.{{GeneratedStructName}}{Name: "{{GeneratedFieldNameValue}}"}).Stage()`

const StringInitStatement = `
	{{Identifier}}.{{GeneratedFieldName}} = ` + "`" + `{{GeneratedFieldNameValue}}` + "`"

const StringEnumInitStatement = `
	{{Identifier}}.{{GeneratedFieldName}} = {{GeneratedFieldNameValue}}`

const NumberInitStatement = `
	{{Identifier}}.{{GeneratedFieldName}} = {{GeneratedFieldNameValue}}`

const PointerFieldInitStatement = `
	{{Identifier}}.{{GeneratedFieldName}} = {{GeneratedFieldNameValue}}`

const SliceOfPointersFieldInitStatement = `
	{{Identifier}}.{{GeneratedFieldName}} = append({{Identifier}}.{{GeneratedFieldName}}, {{GeneratedFieldNameValue}})`

const TimeInitStatement = `
	{{Identifier}}.{{GeneratedFieldName}}, _ = time.Parse("2006-01-02 15:04:05.999999999 -0700 MST", "{{GeneratedFieldNameValue}}")`

// Marshall marshall the stage content into the file as an instanciation into a stage
func (stage *StageStruct) Marshall(file *os.File, modelsPackageName, packageName string) {

	name := file.Name()

	if !strings.HasSuffix(name, ".go") {
		log.Fatalln(name + " is not a go filename")
	}

	log.Println("filename of marshall output  is " + name)

	res := marshallRes
	res = strings.ReplaceAll(res, "{{databaseName}}", strings.ReplaceAll(path.Base(name), ".go", ""))
	res = strings.ReplaceAll(res, "{{PackageName}}", packageName)
	res = strings.ReplaceAll(res, "{{ModelsPackageName}}", modelsPackageName)

	// map of identifiers
	// var StageMapDstructIds map[*Dstruct]string
	identifiersDecl := ""
	initializerStatements := ""
	pointersInitializesStatements := ""

	id := ""
	decl := ""
	setValueField := ""

	// insertion initialization of objects to stage
	map_Classdiagram_Identifiers := make(map[*Classdiagram]string)
	_ = map_Classdiagram_Identifiers

	classdiagramOrdered := []*Classdiagram{}
	for classdiagram := range stage.Classdiagrams {
		classdiagramOrdered = append(classdiagramOrdered, classdiagram)
	}
	sort.Slice(classdiagramOrdered[:], func(i, j int) bool {
		return classdiagramOrdered[i].Name < classdiagramOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of Classdiagram"
	for idx, classdiagram := range classdiagramOrdered {

		id = generatesIdentifier("Classdiagram", idx, classdiagram.Name)
		map_Classdiagram_Identifiers[classdiagram] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Classdiagram")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", classdiagram.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Classdiagram %s values setup", classdiagram.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(classdiagram.Name))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "IsEditable")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%t", classdiagram.IsEditable))
		initializerStatements += setValueField

	}

	map_Classshape_Identifiers := make(map[*Classshape]string)
	_ = map_Classshape_Identifiers

	classshapeOrdered := []*Classshape{}
	for classshape := range stage.Classshapes {
		classshapeOrdered = append(classshapeOrdered, classshape)
	}
	sort.Slice(classshapeOrdered[:], func(i, j int) bool {
		return classshapeOrdered[i].Name < classshapeOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of Classshape"
	for idx, classshape := range classshapeOrdered {

		id = generatesIdentifier("Classshape", idx, classshape.Name)
		map_Classshape_Identifiers[classshape] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Classshape")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", classshape.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Classshape %s values setup", classshape.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(classshape.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Structname")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(classshape.Structname))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "ShowNbInstances")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%t", classshape.ShowNbInstances))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "NbInstances")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%d", classshape.NbInstances))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Width")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", classshape.Width))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Heigth")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", classshape.Heigth))
		initializerStatements += setValueField

		if classshape.ClassshapeTargetType != "" {
			setValueField = StringEnumInitStatement
			setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
			setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "ClassshapeTargetType")
			setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", "models."+classshape.ClassshapeTargetType.ToCodeString())
			initializerStatements += setValueField
		}

	}

	map_Field_Identifiers := make(map[*Field]string)
	_ = map_Field_Identifiers

	fieldOrdered := []*Field{}
	for field := range stage.Fields {
		fieldOrdered = append(fieldOrdered, field)
	}
	sort.Slice(fieldOrdered[:], func(i, j int) bool {
		return fieldOrdered[i].Name < fieldOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of Field"
	for idx, field := range fieldOrdered {

		id = generatesIdentifier("Field", idx, field.Name)
		map_Field_Identifiers[field] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Field")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", field.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Field %s values setup", field.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(field.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Fieldname")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(field.Fieldname))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "FieldTypeAsString")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(field.FieldTypeAsString))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Structname")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(field.Structname))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Fieldtypename")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(field.Fieldtypename))
		initializerStatements += setValueField

	}

	map_GongStruct_Identifiers := make(map[*GongStruct]string)
	_ = map_GongStruct_Identifiers

	gongstructOrdered := []*GongStruct{}
	for gongstruct := range stage.GongStructs {
		gongstructOrdered = append(gongstructOrdered, gongstruct)
	}
	sort.Slice(gongstructOrdered[:], func(i, j int) bool {
		return gongstructOrdered[i].Name < gongstructOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of GongStruct"
	for idx, gongstruct := range gongstructOrdered {

		id = generatesIdentifier("GongStruct", idx, gongstruct.Name)
		map_GongStruct_Identifiers[gongstruct] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "GongStruct")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", gongstruct.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// GongStruct %s values setup", gongstruct.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongstruct.Name))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "NbInstances")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%d", gongstruct.NbInstances))
		initializerStatements += setValueField

	}

	map_GongdocCommand_Identifiers := make(map[*GongdocCommand]string)
	_ = map_GongdocCommand_Identifiers

	gongdoccommandOrdered := []*GongdocCommand{}
	for gongdoccommand := range stage.GongdocCommands {
		gongdoccommandOrdered = append(gongdoccommandOrdered, gongdoccommand)
	}
	sort.Slice(gongdoccommandOrdered[:], func(i, j int) bool {
		return gongdoccommandOrdered[i].Name < gongdoccommandOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of GongdocCommand"
	for idx, gongdoccommand := range gongdoccommandOrdered {

		id = generatesIdentifier("GongdocCommand", idx, gongdoccommand.Name)
		map_GongdocCommand_Identifiers[gongdoccommand] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "GongdocCommand")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", gongdoccommand.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// GongdocCommand %s values setup", gongdoccommand.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.Name))
		initializerStatements += setValueField

		if gongdoccommand.Command != "" {
			setValueField = StringEnumInitStatement
			setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
			setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Command")
			setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", "models."+gongdoccommand.Command.ToCodeString())
			initializerStatements += setValueField
		}

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "DiagramName")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.DiagramName))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Date")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.Date))
		initializerStatements += setValueField

		if gongdoccommand.GongdocNodeType != "" {
			setValueField = StringEnumInitStatement
			setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
			setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "GongdocNodeType")
			setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", "models."+gongdoccommand.GongdocNodeType.ToCodeString())
			initializerStatements += setValueField
		}

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "StructName")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.StructName))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "FieldName")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.FieldName))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "FieldTypeName")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.FieldTypeName))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "PositionX")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%d", gongdoccommand.PositionX))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "PositionY")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%d", gongdoccommand.PositionY))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "NoteName")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdoccommand.NoteName))
		initializerStatements += setValueField

	}

	map_GongdocStatus_Identifiers := make(map[*GongdocStatus]string)
	_ = map_GongdocStatus_Identifiers

	gongdocstatusOrdered := []*GongdocStatus{}
	for gongdocstatus := range stage.GongdocStatuss {
		gongdocstatusOrdered = append(gongdocstatusOrdered, gongdocstatus)
	}
	sort.Slice(gongdocstatusOrdered[:], func(i, j int) bool {
		return gongdocstatusOrdered[i].Name < gongdocstatusOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of GongdocStatus"
	for idx, gongdocstatus := range gongdocstatusOrdered {

		id = generatesIdentifier("GongdocStatus", idx, gongdocstatus.Name)
		map_GongdocStatus_Identifiers[gongdocstatus] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "GongdocStatus")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", gongdocstatus.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// GongdocStatus %s values setup", gongdocstatus.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdocstatus.Name))
		initializerStatements += setValueField

		if gongdocstatus.Status != "" {
			setValueField = StringEnumInitStatement
			setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
			setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Status")
			setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", "models."+gongdocstatus.Status.ToCodeString())
			initializerStatements += setValueField
		}

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "CommandCompletionDate")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(gongdocstatus.CommandCompletionDate))
		initializerStatements += setValueField

	}

	map_Link_Identifiers := make(map[*Link]string)
	_ = map_Link_Identifiers

	linkOrdered := []*Link{}
	for link := range stage.Links {
		linkOrdered = append(linkOrdered, link)
	}
	sort.Slice(linkOrdered[:], func(i, j int) bool {
		return linkOrdered[i].Name < linkOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of Link"
	for idx, link := range linkOrdered {

		id = generatesIdentifier("Link", idx, link.Name)
		map_Link_Identifiers[link] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Link")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", link.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Link %s values setup", link.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(link.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Fieldname")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(link.Fieldname))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Structname")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(link.Structname))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Fieldtypename")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(link.Fieldtypename))
		initializerStatements += setValueField

		if link.TargetMultiplicity != "" {
			setValueField = StringEnumInitStatement
			setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
			setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "TargetMultiplicity")
			setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", "models."+link.TargetMultiplicity.ToCodeString())
			initializerStatements += setValueField
		}

		if link.SourceMultiplicity != "" {
			setValueField = StringEnumInitStatement
			setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
			setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "SourceMultiplicity")
			setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", "models."+link.SourceMultiplicity.ToCodeString())
			initializerStatements += setValueField
		}

	}

	map_Note_Identifiers := make(map[*Note]string)
	_ = map_Note_Identifiers

	noteOrdered := []*Note{}
	for note := range stage.Notes {
		noteOrdered = append(noteOrdered, note)
	}
	sort.Slice(noteOrdered[:], func(i, j int) bool {
		return noteOrdered[i].Name < noteOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of Note"
	for idx, note := range noteOrdered {

		id = generatesIdentifier("Note", idx, note.Name)
		map_Note_Identifiers[note] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Note")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", note.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Note %s values setup", note.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(note.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Body")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(note.Body))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "X")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", note.X))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Y")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", note.Y))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Width")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", note.Width))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Heigth")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", note.Heigth))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Matched")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%t", note.Matched))
		initializerStatements += setValueField

	}

	map_Pkgelt_Identifiers := make(map[*Pkgelt]string)
	_ = map_Pkgelt_Identifiers

	pkgeltOrdered := []*Pkgelt{}
	for pkgelt := range stage.Pkgelts {
		pkgeltOrdered = append(pkgeltOrdered, pkgelt)
	}
	sort.Slice(pkgeltOrdered[:], func(i, j int) bool {
		return pkgeltOrdered[i].Name < pkgeltOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of Pkgelt"
	for idx, pkgelt := range pkgeltOrdered {

		id = generatesIdentifier("Pkgelt", idx, pkgelt.Name)
		map_Pkgelt_Identifiers[pkgelt] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Pkgelt")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", pkgelt.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Pkgelt %s values setup", pkgelt.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(pkgelt.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Path")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(pkgelt.Path))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "GongModelPath")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(pkgelt.GongModelPath))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Editable")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%t", pkgelt.Editable))
		initializerStatements += setValueField

	}

	map_Position_Identifiers := make(map[*Position]string)
	_ = map_Position_Identifiers

	positionOrdered := []*Position{}
	for position := range stage.Positions {
		positionOrdered = append(positionOrdered, position)
	}
	sort.Slice(positionOrdered[:], func(i, j int) bool {
		return positionOrdered[i].Name < positionOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of Position"
	for idx, position := range positionOrdered {

		id = generatesIdentifier("Position", idx, position.Name)
		map_Position_Identifiers[position] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Position")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", position.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Position %s values setup", position.Name)
		// Initialisation of values
		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "X")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", position.X))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Y")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", position.Y))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(position.Name))
		initializerStatements += setValueField

	}

	map_UmlState_Identifiers := make(map[*UmlState]string)
	_ = map_UmlState_Identifiers

	umlstateOrdered := []*UmlState{}
	for umlstate := range stage.UmlStates {
		umlstateOrdered = append(umlstateOrdered, umlstate)
	}
	sort.Slice(umlstateOrdered[:], func(i, j int) bool {
		return umlstateOrdered[i].Name < umlstateOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of UmlState"
	for idx, umlstate := range umlstateOrdered {

		id = generatesIdentifier("UmlState", idx, umlstate.Name)
		map_UmlState_Identifiers[umlstate] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "UmlState")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", umlstate.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// UmlState %s values setup", umlstate.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(umlstate.Name))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "X")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", umlstate.X))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Y")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", umlstate.Y))
		initializerStatements += setValueField

	}

	map_Umlsc_Identifiers := make(map[*Umlsc]string)
	_ = map_Umlsc_Identifiers

	umlscOrdered := []*Umlsc{}
	for umlsc := range stage.Umlscs {
		umlscOrdered = append(umlscOrdered, umlsc)
	}
	sort.Slice(umlscOrdered[:], func(i, j int) bool {
		return umlscOrdered[i].Name < umlscOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of Umlsc"
	for idx, umlsc := range umlscOrdered {

		id = generatesIdentifier("Umlsc", idx, umlsc.Name)
		map_Umlsc_Identifiers[umlsc] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Umlsc")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", umlsc.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Umlsc %s values setup", umlsc.Name)
		// Initialisation of values
		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(umlsc.Name))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Activestate")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(umlsc.Activestate))
		initializerStatements += setValueField

	}

	map_Vertice_Identifiers := make(map[*Vertice]string)
	_ = map_Vertice_Identifiers

	verticeOrdered := []*Vertice{}
	for vertice := range stage.Vertices {
		verticeOrdered = append(verticeOrdered, vertice)
	}
	sort.Slice(verticeOrdered[:], func(i, j int) bool {
		return verticeOrdered[i].Name < verticeOrdered[j].Name
	})
	identifiersDecl += "\n\n	// Declarations of staged instances of Vertice"
	for idx, vertice := range verticeOrdered {

		id = generatesIdentifier("Vertice", idx, vertice.Name)
		map_Vertice_Identifiers[vertice] = id

		decl = IdentifiersDecls
		decl = strings.ReplaceAll(decl, "{{Identifier}}", id)
		decl = strings.ReplaceAll(decl, "{{GeneratedStructName}}", "Vertice")
		decl = strings.ReplaceAll(decl, "{{GeneratedFieldNameValue}}", vertice.Name)
		identifiersDecl += decl

		initializerStatements += fmt.Sprintf("\n\n	// Vertice %s values setup", vertice.Name)
		// Initialisation of values
		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "X")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", vertice.X))
		initializerStatements += setValueField

		setValueField = NumberInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Y")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", fmt.Sprintf("%f", vertice.Y))
		initializerStatements += setValueField

		setValueField = StringInitStatement
		setValueField = strings.ReplaceAll(setValueField, "{{Identifier}}", id)
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldName}}", "Name")
		setValueField = strings.ReplaceAll(setValueField, "{{GeneratedFieldNameValue}}", string(vertice.Name))
		initializerStatements += setValueField

	}

	// insertion initialization of objects to stage
	for idx, classdiagram := range classdiagramOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Classdiagram", idx, classdiagram.Name)
		map_Classdiagram_Identifiers[classdiagram] = id

		// Initialisation of values
		for _, _classshape := range classdiagram.Classshapes {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Classshapes")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Classshape_Identifiers[_classshape])
			pointersInitializesStatements += setPointerField
		}

		for _, _note := range classdiagram.Notes {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Notes")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Note_Identifiers[_note])
			pointersInitializesStatements += setPointerField
		}

	}

	for idx, classshape := range classshapeOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Classshape", idx, classshape.Name)
		map_Classshape_Identifiers[classshape] = id

		// Initialisation of values
		if classshape.Position != nil {
			setPointerField = PointerFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Position")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Position_Identifiers[classshape.Position])
			pointersInitializesStatements += setPointerField
		}

		if classshape.GongStruct != nil {
			setPointerField = PointerFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "GongStruct")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_GongStruct_Identifiers[classshape.GongStruct])
			pointersInitializesStatements += setPointerField
		}

		for _, _field := range classshape.Fields {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Fields")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Field_Identifiers[_field])
			pointersInitializesStatements += setPointerField
		}

		for _, _link := range classshape.Links {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Links")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Link_Identifiers[_link])
			pointersInitializesStatements += setPointerField
		}

	}

	for idx, field := range fieldOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Field", idx, field.Name)
		map_Field_Identifiers[field] = id

		// Initialisation of values
	}

	for idx, gongstruct := range gongstructOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("GongStruct", idx, gongstruct.Name)
		map_GongStruct_Identifiers[gongstruct] = id

		// Initialisation of values
	}

	for idx, gongdoccommand := range gongdoccommandOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("GongdocCommand", idx, gongdoccommand.Name)
		map_GongdocCommand_Identifiers[gongdoccommand] = id

		// Initialisation of values
	}

	for idx, gongdocstatus := range gongdocstatusOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("GongdocStatus", idx, gongdocstatus.Name)
		map_GongdocStatus_Identifiers[gongdocstatus] = id

		// Initialisation of values
	}

	for idx, link := range linkOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Link", idx, link.Name)
		map_Link_Identifiers[link] = id

		// Initialisation of values
		if link.Middlevertice != nil {
			setPointerField = PointerFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Middlevertice")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Vertice_Identifiers[link.Middlevertice])
			pointersInitializesStatements += setPointerField
		}

	}

	for idx, note := range noteOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Note", idx, note.Name)
		map_Note_Identifiers[note] = id

		// Initialisation of values
	}

	for idx, pkgelt := range pkgeltOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Pkgelt", idx, pkgelt.Name)
		map_Pkgelt_Identifiers[pkgelt] = id

		// Initialisation of values
		for _, _classdiagram := range pkgelt.Classdiagrams {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Classdiagrams")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Classdiagram_Identifiers[_classdiagram])
			pointersInitializesStatements += setPointerField
		}

		for _, _umlsc := range pkgelt.Umlscs {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "Umlscs")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_Umlsc_Identifiers[_umlsc])
			pointersInitializesStatements += setPointerField
		}

	}

	for idx, position := range positionOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Position", idx, position.Name)
		map_Position_Identifiers[position] = id

		// Initialisation of values
	}

	for idx, umlstate := range umlstateOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("UmlState", idx, umlstate.Name)
		map_UmlState_Identifiers[umlstate] = id

		// Initialisation of values
	}

	for idx, umlsc := range umlscOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Umlsc", idx, umlsc.Name)
		map_Umlsc_Identifiers[umlsc] = id

		// Initialisation of values
		for _, _umlstate := range umlsc.States {
			setPointerField = SliceOfPointersFieldInitStatement
			setPointerField = strings.ReplaceAll(setPointerField, "{{Identifier}}", id)
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldName}}", "States")
			setPointerField = strings.ReplaceAll(setPointerField, "{{GeneratedFieldNameValue}}", map_UmlState_Identifiers[_umlstate])
			pointersInitializesStatements += setPointerField
		}

	}

	for idx, vertice := range verticeOrdered {
		var setPointerField string
		_ = setPointerField

		id = generatesIdentifier("Vertice", idx, vertice.Name)
		map_Vertice_Identifiers[vertice] = id

		// Initialisation of values
	}

	res = strings.ReplaceAll(res, "{{Identifiers}}", identifiersDecl)
	res = strings.ReplaceAll(res, "{{ValueInitializers}}", initializerStatements)
	res = strings.ReplaceAll(res, "{{PointersInitializers}}", pointersInitializesStatements)

	fmt.Fprintln(file, res)
}

// unique identifier per struct
func generatesIdentifier(gongStructName string, idx int, instanceName string) (identifier string) {

	identifier = instanceName
	// Make a Regex to say we only want letters and numbers
	reg, err := regexp.Compile("[^a-zA-Z0-9]+")
	if err != nil {
		log.Fatal(err)
	}
	processedString := reg.ReplaceAllString(instanceName, "_")

	identifier = fmt.Sprintf("__%s__%06d_%s", gongStructName, idx, processedString)

	return
}

// insertion point of functions that provide maps for reverse associations

// generate function for reverse association maps of Classdiagram
func (stageStruct *StageStruct) CreateReverseMap_Classdiagram_Classshapes() (res map[*Classshape]*Classdiagram) {
	res = make(map[*Classshape]*Classdiagram)

	for classdiagram := range stageStruct.Classdiagrams {
		for _, classshape_ := range classdiagram.Classshapes {
			res[classshape_] = classdiagram
		}
	}

	return
}

func (stageStruct *StageStruct) CreateReverseMap_Classdiagram_Notes() (res map[*Note]*Classdiagram) {
	res = make(map[*Note]*Classdiagram)

	for classdiagram := range stageStruct.Classdiagrams {
		for _, note_ := range classdiagram.Notes {
			res[note_] = classdiagram
		}
	}

	return
}


// generate function for reverse association maps of Classshape
func (stageStruct *StageStruct) CreateReverseMap_Classshape_Position() (res map[*Position][]*Classshape) {
	res = make(map[*Position][]*Classshape)

	for classshape := range stageStruct.Classshapes {
		if classshape.Position != nil {
			position_ := classshape.Position
			var classshapes []*Classshape
			_, ok := res[position_]
			if ok {
				classshapes = res[position_]
			} else {
				classshapes = make([]*Classshape, 0)
			}
			classshapes = append(classshapes, classshape)
			res[position_] = classshapes
		}
	}

	return
}
func (stageStruct *StageStruct) CreateReverseMap_Classshape_GongStruct() (res map[*GongStruct][]*Classshape) {
	res = make(map[*GongStruct][]*Classshape)

	for classshape := range stageStruct.Classshapes {
		if classshape.GongStruct != nil {
			gongstruct_ := classshape.GongStruct
			var classshapes []*Classshape
			_, ok := res[gongstruct_]
			if ok {
				classshapes = res[gongstruct_]
			} else {
				classshapes = make([]*Classshape, 0)
			}
			classshapes = append(classshapes, classshape)
			res[gongstruct_] = classshapes
		}
	}

	return
}
func (stageStruct *StageStruct) CreateReverseMap_Classshape_Fields() (res map[*Field]*Classshape) {
	res = make(map[*Field]*Classshape)

	for classshape := range stageStruct.Classshapes {
		for _, field_ := range classshape.Fields {
			res[field_] = classshape
		}
	}

	return
}

func (stageStruct *StageStruct) CreateReverseMap_Classshape_Links() (res map[*Link]*Classshape) {
	res = make(map[*Link]*Classshape)

	for classshape := range stageStruct.Classshapes {
		for _, link_ := range classshape.Links {
			res[link_] = classshape
		}
	}

	return
}


// generate function for reverse association maps of Field

// generate function for reverse association maps of GongStruct

// generate function for reverse association maps of GongdocCommand

// generate function for reverse association maps of GongdocStatus

// generate function for reverse association maps of Link
func (stageStruct *StageStruct) CreateReverseMap_Link_Middlevertice() (res map[*Vertice][]*Link) {
	res = make(map[*Vertice][]*Link)

	for link := range stageStruct.Links {
		if link.Middlevertice != nil {
			vertice_ := link.Middlevertice
			var links []*Link
			_, ok := res[vertice_]
			if ok {
				links = res[vertice_]
			} else {
				links = make([]*Link, 0)
			}
			links = append(links, link)
			res[vertice_] = links
		}
	}

	return
}

// generate function for reverse association maps of Note

// generate function for reverse association maps of Pkgelt
func (stageStruct *StageStruct) CreateReverseMap_Pkgelt_Classdiagrams() (res map[*Classdiagram]*Pkgelt) {
	res = make(map[*Classdiagram]*Pkgelt)

	for pkgelt := range stageStruct.Pkgelts {
		for _, classdiagram_ := range pkgelt.Classdiagrams {
			res[classdiagram_] = pkgelt
		}
	}

	return
}

func (stageStruct *StageStruct) CreateReverseMap_Pkgelt_Umlscs() (res map[*Umlsc]*Pkgelt) {
	res = make(map[*Umlsc]*Pkgelt)

	for pkgelt := range stageStruct.Pkgelts {
		for _, umlsc_ := range pkgelt.Umlscs {
			res[umlsc_] = pkgelt
		}
	}

	return
}


// generate function for reverse association maps of Position

// generate function for reverse association maps of UmlState

// generate function for reverse association maps of Umlsc
func (stageStruct *StageStruct) CreateReverseMap_Umlsc_States() (res map[*UmlState]*Umlsc) {
	res = make(map[*UmlState]*Umlsc)

	for umlsc := range stageStruct.Umlscs {
		for _, umlstate_ := range umlsc.States {
			res[umlstate_] = umlsc
		}
	}

	return
}


// generate function for reverse association maps of Vertice

// Gongstruct is the type parameter for generated generic function that allows
// - access to staged instances
// - navigation between staged instances by going backward association links between gongstruct
// - full refactoring of Gongstruct identifiers / fields
type Gongstruct interface {
	// insertion point for generic types
	Classdiagram | Classshape | Field | GongStruct | GongdocCommand | GongdocStatus | Link | Note | Pkgelt | Position | UmlState | Umlsc | Vertice
}

// Gongstruct is the type parameter for generated generic function that allows
// - access to staged instances
// - navigation between staged instances by going backward association links between gongstruct
// - full refactoring of Gongstruct identifiers / fields
type PointerToGongstruct interface {
	// insertion point for generic types
	*Classdiagram | *Classshape | *Field | *GongStruct | *GongdocCommand | *GongdocStatus | *Link | *Note | *Pkgelt | *Position | *UmlState | *Umlsc | *Vertice
	GetName() string
}

type GongstructSet interface {
	map[any]any |
		// insertion point for generic types
		map[*Classdiagram]any |
		map[*Classshape]any |
		map[*Field]any |
		map[*GongStruct]any |
		map[*GongdocCommand]any |
		map[*GongdocStatus]any |
		map[*Link]any |
		map[*Note]any |
		map[*Pkgelt]any |
		map[*Position]any |
		map[*UmlState]any |
		map[*Umlsc]any |
		map[*Vertice]any |
		map[*any]any // because go does not support an extra "|" at the end of type specifications
}

type GongstructMapString interface {
	map[any]any |
		// insertion point for generic types
		map[string]*Classdiagram |
		map[string]*Classshape |
		map[string]*Field |
		map[string]*GongStruct |
		map[string]*GongdocCommand |
		map[string]*GongdocStatus |
		map[string]*Link |
		map[string]*Note |
		map[string]*Pkgelt |
		map[string]*Position |
		map[string]*UmlState |
		map[string]*Umlsc |
		map[string]*Vertice |
		map[*any]any // because go does not support an extra "|" at the end of type specifications
}

// GongGetSet returns the set staged GongstructType instances
// it is usefull because it allows refactoring of gong struct identifier
func GongGetSet[Type GongstructSet]() *Type {
	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get functions
	case map[*Classdiagram]any:
		return any(&Stage.Classdiagrams).(*Type)
	case map[*Classshape]any:
		return any(&Stage.Classshapes).(*Type)
	case map[*Field]any:
		return any(&Stage.Fields).(*Type)
	case map[*GongStruct]any:
		return any(&Stage.GongStructs).(*Type)
	case map[*GongdocCommand]any:
		return any(&Stage.GongdocCommands).(*Type)
	case map[*GongdocStatus]any:
		return any(&Stage.GongdocStatuss).(*Type)
	case map[*Link]any:
		return any(&Stage.Links).(*Type)
	case map[*Note]any:
		return any(&Stage.Notes).(*Type)
	case map[*Pkgelt]any:
		return any(&Stage.Pkgelts).(*Type)
	case map[*Position]any:
		return any(&Stage.Positions).(*Type)
	case map[*UmlState]any:
		return any(&Stage.UmlStates).(*Type)
	case map[*Umlsc]any:
		return any(&Stage.Umlscs).(*Type)
	case map[*Vertice]any:
		return any(&Stage.Vertices).(*Type)
	default:
		return nil
	}
}

// GongGetMap returns the map of staged GongstructType instances
// it is usefull because it allows refactoring of gong struct identifier
func GongGetMap[Type GongstructMapString]() *Type {
	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get functions
	case map[string]*Classdiagram:
		return any(&Stage.Classdiagrams_mapString).(*Type)
	case map[string]*Classshape:
		return any(&Stage.Classshapes_mapString).(*Type)
	case map[string]*Field:
		return any(&Stage.Fields_mapString).(*Type)
	case map[string]*GongStruct:
		return any(&Stage.GongStructs_mapString).(*Type)
	case map[string]*GongdocCommand:
		return any(&Stage.GongdocCommands_mapString).(*Type)
	case map[string]*GongdocStatus:
		return any(&Stage.GongdocStatuss_mapString).(*Type)
	case map[string]*Link:
		return any(&Stage.Links_mapString).(*Type)
	case map[string]*Note:
		return any(&Stage.Notes_mapString).(*Type)
	case map[string]*Pkgelt:
		return any(&Stage.Pkgelts_mapString).(*Type)
	case map[string]*Position:
		return any(&Stage.Positions_mapString).(*Type)
	case map[string]*UmlState:
		return any(&Stage.UmlStates_mapString).(*Type)
	case map[string]*Umlsc:
		return any(&Stage.Umlscs_mapString).(*Type)
	case map[string]*Vertice:
		return any(&Stage.Vertices_mapString).(*Type)
	default:
		return nil
	}
}

// GetGongstructInstancesSet returns the set staged GongstructType instances
// it is usefull because it allows refactoring of gongstruct identifier
func GetGongstructInstancesSet[Type Gongstruct]() *map[*Type]any {
	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get functions
	case Classdiagram:
		return any(&Stage.Classdiagrams).(*map[*Type]any)
	case Classshape:
		return any(&Stage.Classshapes).(*map[*Type]any)
	case Field:
		return any(&Stage.Fields).(*map[*Type]any)
	case GongStruct:
		return any(&Stage.GongStructs).(*map[*Type]any)
	case GongdocCommand:
		return any(&Stage.GongdocCommands).(*map[*Type]any)
	case GongdocStatus:
		return any(&Stage.GongdocStatuss).(*map[*Type]any)
	case Link:
		return any(&Stage.Links).(*map[*Type]any)
	case Note:
		return any(&Stage.Notes).(*map[*Type]any)
	case Pkgelt:
		return any(&Stage.Pkgelts).(*map[*Type]any)
	case Position:
		return any(&Stage.Positions).(*map[*Type]any)
	case UmlState:
		return any(&Stage.UmlStates).(*map[*Type]any)
	case Umlsc:
		return any(&Stage.Umlscs).(*map[*Type]any)
	case Vertice:
		return any(&Stage.Vertices).(*map[*Type]any)
	default:
		return nil
	}
}

// GetGongstructInstancesMap returns the map of staged GongstructType instances
// it is usefull because it allows refactoring of gong struct identifier
func GetGongstructInstancesMap[Type Gongstruct]() *map[string]*Type {
	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get functions
	case Classdiagram:
		return any(&Stage.Classdiagrams_mapString).(*map[string]*Type)
	case Classshape:
		return any(&Stage.Classshapes_mapString).(*map[string]*Type)
	case Field:
		return any(&Stage.Fields_mapString).(*map[string]*Type)
	case GongStruct:
		return any(&Stage.GongStructs_mapString).(*map[string]*Type)
	case GongdocCommand:
		return any(&Stage.GongdocCommands_mapString).(*map[string]*Type)
	case GongdocStatus:
		return any(&Stage.GongdocStatuss_mapString).(*map[string]*Type)
	case Link:
		return any(&Stage.Links_mapString).(*map[string]*Type)
	case Note:
		return any(&Stage.Notes_mapString).(*map[string]*Type)
	case Pkgelt:
		return any(&Stage.Pkgelts_mapString).(*map[string]*Type)
	case Position:
		return any(&Stage.Positions_mapString).(*map[string]*Type)
	case UmlState:
		return any(&Stage.UmlStates_mapString).(*map[string]*Type)
	case Umlsc:
		return any(&Stage.Umlscs_mapString).(*map[string]*Type)
	case Vertice:
		return any(&Stage.Vertices_mapString).(*map[string]*Type)
	default:
		return nil
	}
}

// GetAssociationName is a generic function that returns an instance of Type
// where each association is filled with an instance whose name is the name of the association
//
// This function can be handy for generating navigation function that are refactorable
func GetAssociationName[Type Gongstruct]() *Type {
	var ret Type

	switch any(ret).(type) {
	// insertion point for instance with special fields
	case Classdiagram:
		return any(&Classdiagram{
			// Initialisation of associations
			// field is initialized with an instance of Classshape with the name of the field
			Classshapes: []*Classshape{{Name: "Classshapes"}},
			// field is initialized with an instance of Note with the name of the field
			Notes: []*Note{{Name: "Notes"}},
		}).(*Type)
	case Classshape:
		return any(&Classshape{
			// Initialisation of associations
			// field is initialized with an instance of Position with the name of the field
			Position: &Position{Name: "Position"},
			// field is initialized with an instance of GongStruct with the name of the field
			GongStruct: &GongStruct{Name: "GongStruct"},
			// field is initialized with an instance of Field with the name of the field
			Fields: []*Field{{Name: "Fields"}},
			// field is initialized with an instance of Link with the name of the field
			Links: []*Link{{Name: "Links"}},
		}).(*Type)
	case Field:
		return any(&Field{
			// Initialisation of associations
		}).(*Type)
	case GongStruct:
		return any(&GongStruct{
			// Initialisation of associations
		}).(*Type)
	case GongdocCommand:
		return any(&GongdocCommand{
			// Initialisation of associations
		}).(*Type)
	case GongdocStatus:
		return any(&GongdocStatus{
			// Initialisation of associations
		}).(*Type)
	case Link:
		return any(&Link{
			// Initialisation of associations
			// field is initialized with an instance of Vertice with the name of the field
			Middlevertice: &Vertice{Name: "Middlevertice"},
		}).(*Type)
	case Note:
		return any(&Note{
			// Initialisation of associations
		}).(*Type)
	case Pkgelt:
		return any(&Pkgelt{
			// Initialisation of associations
			// field is initialized with an instance of Classdiagram with the name of the field
			Classdiagrams: []*Classdiagram{{Name: "Classdiagrams"}},
			// field is initialized with an instance of Umlsc with the name of the field
			Umlscs: []*Umlsc{{Name: "Umlscs"}},
		}).(*Type)
	case Position:
		return any(&Position{
			// Initialisation of associations
		}).(*Type)
	case UmlState:
		return any(&UmlState{
			// Initialisation of associations
		}).(*Type)
	case Umlsc:
		return any(&Umlsc{
			// Initialisation of associations
			// field is initialized with an instance of UmlState with the name of the field
			States: []*UmlState{{Name: "States"}},
		}).(*Type)
	case Vertice:
		return any(&Vertice{
			// Initialisation of associations
		}).(*Type)
	default:
		return nil
	}
}

// GetPointerReverseMap allows backtrack navigation of any Start.Fieldname
// associations (0..1) that is a pointer from one staged Gongstruct (type Start)
// instances to another (type End)
//
// The function provides a map with keys as instances of End and values to arrays of *Start
// the map is construed by iterating over all Start instances and populationg keys with End instances
// and values with slice of Start instances
func GetPointerReverseMap[Start, End Gongstruct](fieldname string) map[*End][]*Start {
	var ret Start

	switch any(ret).(type) {
	// insertion point of functions that provide maps for reverse associations
	// reverse maps of direct associations of Classdiagram
	case Classdiagram:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Classshape
	case Classshape:
		switch fieldname {
		// insertion point for per direct association field
		case "Position":
			res := make(map[*Position][]*Classshape)
			for classshape := range Stage.Classshapes {
				if classshape.Position != nil {
					position_ := classshape.Position
					var classshapes []*Classshape
					_, ok := res[position_]
					if ok {
						classshapes = res[position_]
					} else {
						classshapes = make([]*Classshape, 0)
					}
					classshapes = append(classshapes, classshape)
					res[position_] = classshapes
				}
			}
			return any(res).(map[*End][]*Start)
		case "GongStruct":
			res := make(map[*GongStruct][]*Classshape)
			for classshape := range Stage.Classshapes {
				if classshape.GongStruct != nil {
					gongstruct_ := classshape.GongStruct
					var classshapes []*Classshape
					_, ok := res[gongstruct_]
					if ok {
						classshapes = res[gongstruct_]
					} else {
						classshapes = make([]*Classshape, 0)
					}
					classshapes = append(classshapes, classshape)
					res[gongstruct_] = classshapes
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Field
	case Field:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of GongStruct
	case GongStruct:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of GongdocCommand
	case GongdocCommand:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of GongdocStatus
	case GongdocStatus:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Link
	case Link:
		switch fieldname {
		// insertion point for per direct association field
		case "Middlevertice":
			res := make(map[*Vertice][]*Link)
			for link := range Stage.Links {
				if link.Middlevertice != nil {
					vertice_ := link.Middlevertice
					var links []*Link
					_, ok := res[vertice_]
					if ok {
						links = res[vertice_]
					} else {
						links = make([]*Link, 0)
					}
					links = append(links, link)
					res[vertice_] = links
				}
			}
			return any(res).(map[*End][]*Start)
		}
	// reverse maps of direct associations of Note
	case Note:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Pkgelt
	case Pkgelt:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Position
	case Position:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of UmlState
	case UmlState:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Umlsc
	case Umlsc:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Vertice
	case Vertice:
		switch fieldname {
		// insertion point for per direct association field
		}
	}
	return nil
}

// GetSliceOfPointersReverseMap allows backtrack navigation of any Start.Fieldname
// associations (0..N) between one staged Gongstruct instances and many others
//
// The function provides a map with keys as instances of End and values to *Start instances
// the map is construed by iterating over all Start instances and populating keys with End instances
// and values with the Start instances
func GetSliceOfPointersReverseMap[Start, End Gongstruct](fieldname string) map[*End]*Start {
	var ret Start

	switch any(ret).(type) {
	// insertion point of functions that provide maps for reverse associations
	// reverse maps of direct associations of Classdiagram
	case Classdiagram:
		switch fieldname {
		// insertion point for per direct association field
		case "Classshapes":
			res := make(map[*Classshape]*Classdiagram)
			for classdiagram := range Stage.Classdiagrams {
				for _, classshape_ := range classdiagram.Classshapes {
					res[classshape_] = classdiagram
				}
			}
			return any(res).(map[*End]*Start)
		case "Notes":
			res := make(map[*Note]*Classdiagram)
			for classdiagram := range Stage.Classdiagrams {
				for _, note_ := range classdiagram.Notes {
					res[note_] = classdiagram
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Classshape
	case Classshape:
		switch fieldname {
		// insertion point for per direct association field
		case "Fields":
			res := make(map[*Field]*Classshape)
			for classshape := range Stage.Classshapes {
				for _, field_ := range classshape.Fields {
					res[field_] = classshape
				}
			}
			return any(res).(map[*End]*Start)
		case "Links":
			res := make(map[*Link]*Classshape)
			for classshape := range Stage.Classshapes {
				for _, link_ := range classshape.Links {
					res[link_] = classshape
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Field
	case Field:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of GongStruct
	case GongStruct:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of GongdocCommand
	case GongdocCommand:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of GongdocStatus
	case GongdocStatus:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Link
	case Link:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Note
	case Note:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Pkgelt
	case Pkgelt:
		switch fieldname {
		// insertion point for per direct association field
		case "Classdiagrams":
			res := make(map[*Classdiagram]*Pkgelt)
			for pkgelt := range Stage.Pkgelts {
				for _, classdiagram_ := range pkgelt.Classdiagrams {
					res[classdiagram_] = pkgelt
				}
			}
			return any(res).(map[*End]*Start)
		case "Umlscs":
			res := make(map[*Umlsc]*Pkgelt)
			for pkgelt := range Stage.Pkgelts {
				for _, umlsc_ := range pkgelt.Umlscs {
					res[umlsc_] = pkgelt
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Position
	case Position:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of UmlState
	case UmlState:
		switch fieldname {
		// insertion point for per direct association field
		}
	// reverse maps of direct associations of Umlsc
	case Umlsc:
		switch fieldname {
		// insertion point for per direct association field
		case "States":
			res := make(map[*UmlState]*Umlsc)
			for umlsc := range Stage.Umlscs {
				for _, umlstate_ := range umlsc.States {
					res[umlstate_] = umlsc
				}
			}
			return any(res).(map[*End]*Start)
		}
	// reverse maps of direct associations of Vertice
	case Vertice:
		switch fieldname {
		// insertion point for per direct association field
		}
	}
	return nil
}

// GetGongstructName returns the name of the Gongstruct
// this can be usefull if one want program robust to refactoring
func GetGongstructName[Type Gongstruct]() (res string) {

	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get gongstruct name
	case Classdiagram:
		res = "Classdiagram"
	case Classshape:
		res = "Classshape"
	case Field:
		res = "Field"
	case GongStruct:
		res = "GongStruct"
	case GongdocCommand:
		res = "GongdocCommand"
	case GongdocStatus:
		res = "GongdocStatus"
	case Link:
		res = "Link"
	case Note:
		res = "Note"
	case Pkgelt:
		res = "Pkgelt"
	case Position:
		res = "Position"
	case UmlState:
		res = "UmlState"
	case Umlsc:
		res = "Umlsc"
	case Vertice:
		res = "Vertice"
	}
	return res
}

// GetFields return the array of the fields
func GetFields[Type Gongstruct]() (res []string) {

	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get gongstruct name
	case Classdiagram:
		res = []string{"Name", "Classshapes", "Notes", "IsEditable"}
	case Classshape:
		res = []string{"Name", "Position", "Structname", "GongStruct", "ShowNbInstances", "NbInstances", "Fields", "Links", "Width", "Heigth", "ClassshapeTargetType"}
	case Field:
		res = []string{"Name", "Fieldname", "FieldTypeAsString", "Structname", "Fieldtypename"}
	case GongStruct:
		res = []string{"Name", "NbInstances"}
	case GongdocCommand:
		res = []string{"Name", "Command", "DiagramName", "Date", "GongdocNodeType", "StructName", "FieldName", "FieldTypeName", "PositionX", "PositionY", "NoteName"}
	case GongdocStatus:
		res = []string{"Name", "Status", "CommandCompletionDate"}
	case Link:
		res = []string{"Name", "Fieldname", "Structname", "Fieldtypename", "TargetMultiplicity", "SourceMultiplicity", "Middlevertice"}
	case Note:
		res = []string{"Name", "Body", "X", "Y", "Width", "Heigth", "Matched"}
	case Pkgelt:
		res = []string{"Name", "Path", "GongModelPath", "Classdiagrams", "Umlscs", "Editable"}
	case Position:
		res = []string{"X", "Y", "Name"}
	case UmlState:
		res = []string{"Name", "X", "Y"}
	case Umlsc:
		res = []string{"Name", "States", "Activestate"}
	case Vertice:
		res = []string{"X", "Y", "Name"}
	}
	return
}

func GetFieldStringValue[Type Gongstruct](instance Type, fieldName string) (res string) {
	var ret Type

	switch any(ret).(type) {
	// insertion point for generic get gongstruct field value
	case Classdiagram:
		switch fieldName {
		// string value of fields
		case "Name":
			res = any(instance).(Classdiagram).Name
		case "Classshapes":
			for idx, __instance__ := range any(instance).(Classdiagram).Classshapes {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Notes":
			for idx, __instance__ := range any(instance).(Classdiagram).Notes {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "IsEditable":
			res = fmt.Sprintf("%t", any(instance).(Classdiagram).IsEditable)
		}
	case Classshape:
		switch fieldName {
		// string value of fields
		case "Name":
			res = any(instance).(Classshape).Name
		case "Position":
			if any(instance).(Classshape).Position != nil {
				res = any(instance).(Classshape).Position.Name
			}
		case "Structname":
			res = any(instance).(Classshape).Structname
		case "GongStruct":
			if any(instance).(Classshape).GongStruct != nil {
				res = any(instance).(Classshape).GongStruct.Name
			}
		case "ShowNbInstances":
			res = fmt.Sprintf("%t", any(instance).(Classshape).ShowNbInstances)
		case "NbInstances":
			res = fmt.Sprintf("%d", any(instance).(Classshape).NbInstances)
		case "Fields":
			for idx, __instance__ := range any(instance).(Classshape).Fields {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Links":
			for idx, __instance__ := range any(instance).(Classshape).Links {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Width":
			res = fmt.Sprintf("%f", any(instance).(Classshape).Width)
		case "Heigth":
			res = fmt.Sprintf("%f", any(instance).(Classshape).Heigth)
		case "ClassshapeTargetType":
			enum := any(instance).(Classshape).ClassshapeTargetType
			res = enum.ToCodeString()
		}
	case Field:
		switch fieldName {
		// string value of fields
		case "Name":
			res = any(instance).(Field).Name
		case "Fieldname":
			res = any(instance).(Field).Fieldname
		case "FieldTypeAsString":
			res = any(instance).(Field).FieldTypeAsString
		case "Structname":
			res = any(instance).(Field).Structname
		case "Fieldtypename":
			res = any(instance).(Field).Fieldtypename
		}
	case GongStruct:
		switch fieldName {
		// string value of fields
		case "Name":
			res = any(instance).(GongStruct).Name
		case "NbInstances":
			res = fmt.Sprintf("%d", any(instance).(GongStruct).NbInstances)
		}
	case GongdocCommand:
		switch fieldName {
		// string value of fields
		case "Name":
			res = any(instance).(GongdocCommand).Name
		case "Command":
			enum := any(instance).(GongdocCommand).Command
			res = enum.ToCodeString()
		case "DiagramName":
			res = any(instance).(GongdocCommand).DiagramName
		case "Date":
			res = any(instance).(GongdocCommand).Date
		case "GongdocNodeType":
			enum := any(instance).(GongdocCommand).GongdocNodeType
			res = enum.ToCodeString()
		case "StructName":
			res = any(instance).(GongdocCommand).StructName
		case "FieldName":
			res = any(instance).(GongdocCommand).FieldName
		case "FieldTypeName":
			res = any(instance).(GongdocCommand).FieldTypeName
		case "PositionX":
			res = fmt.Sprintf("%d", any(instance).(GongdocCommand).PositionX)
		case "PositionY":
			res = fmt.Sprintf("%d", any(instance).(GongdocCommand).PositionY)
		case "NoteName":
			res = any(instance).(GongdocCommand).NoteName
		}
	case GongdocStatus:
		switch fieldName {
		// string value of fields
		case "Name":
			res = any(instance).(GongdocStatus).Name
		case "Status":
			enum := any(instance).(GongdocStatus).Status
			res = enum.ToCodeString()
		case "CommandCompletionDate":
			res = any(instance).(GongdocStatus).CommandCompletionDate
		}
	case Link:
		switch fieldName {
		// string value of fields
		case "Name":
			res = any(instance).(Link).Name
		case "Fieldname":
			res = any(instance).(Link).Fieldname
		case "Structname":
			res = any(instance).(Link).Structname
		case "Fieldtypename":
			res = any(instance).(Link).Fieldtypename
		case "TargetMultiplicity":
			enum := any(instance).(Link).TargetMultiplicity
			res = enum.ToCodeString()
		case "SourceMultiplicity":
			enum := any(instance).(Link).SourceMultiplicity
			res = enum.ToCodeString()
		case "Middlevertice":
			if any(instance).(Link).Middlevertice != nil {
				res = any(instance).(Link).Middlevertice.Name
			}
		}
	case Note:
		switch fieldName {
		// string value of fields
		case "Name":
			res = any(instance).(Note).Name
		case "Body":
			res = any(instance).(Note).Body
		case "X":
			res = fmt.Sprintf("%f", any(instance).(Note).X)
		case "Y":
			res = fmt.Sprintf("%f", any(instance).(Note).Y)
		case "Width":
			res = fmt.Sprintf("%f", any(instance).(Note).Width)
		case "Heigth":
			res = fmt.Sprintf("%f", any(instance).(Note).Heigth)
		case "Matched":
			res = fmt.Sprintf("%t", any(instance).(Note).Matched)
		}
	case Pkgelt:
		switch fieldName {
		// string value of fields
		case "Name":
			res = any(instance).(Pkgelt).Name
		case "Path":
			res = any(instance).(Pkgelt).Path
		case "GongModelPath":
			res = any(instance).(Pkgelt).GongModelPath
		case "Classdiagrams":
			for idx, __instance__ := range any(instance).(Pkgelt).Classdiagrams {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Umlscs":
			for idx, __instance__ := range any(instance).(Pkgelt).Umlscs {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Editable":
			res = fmt.Sprintf("%t", any(instance).(Pkgelt).Editable)
		}
	case Position:
		switch fieldName {
		// string value of fields
		case "X":
			res = fmt.Sprintf("%f", any(instance).(Position).X)
		case "Y":
			res = fmt.Sprintf("%f", any(instance).(Position).Y)
		case "Name":
			res = any(instance).(Position).Name
		}
	case UmlState:
		switch fieldName {
		// string value of fields
		case "Name":
			res = any(instance).(UmlState).Name
		case "X":
			res = fmt.Sprintf("%f", any(instance).(UmlState).X)
		case "Y":
			res = fmt.Sprintf("%f", any(instance).(UmlState).Y)
		}
	case Umlsc:
		switch fieldName {
		// string value of fields
		case "Name":
			res = any(instance).(Umlsc).Name
		case "States":
			for idx, __instance__ := range any(instance).(Umlsc).States {
				if idx > 0 {
					res += "\n"
				}
				res += __instance__.Name
			}
		case "Activestate":
			res = any(instance).(Umlsc).Activestate
		}
	case Vertice:
		switch fieldName {
		// string value of fields
		case "X":
			res = fmt.Sprintf("%f", any(instance).(Vertice).X)
		case "Y":
			res = fmt.Sprintf("%f", any(instance).(Vertice).Y)
		case "Name":
			res = any(instance).(Vertice).Name
		}
	}
	return
}

// insertion point of enum utility functions
// Utility function for ClassshapeTargetType
// if enum values are string, it is stored with the value
// if enum values are int, they are stored with the code of the value
func (classshapetargettype ClassshapeTargetType) ToString() (res string) {

	// migration of former implementation of enum
	switch classshapetargettype {
	// insertion code per enum code
	case STRUCT:
		res = "STRUCT"
	case ENUM:
		res = "ENUM"
	}
	return
}

func (classshapetargettype *ClassshapeTargetType) FromString(input string) {

	switch input {
	// insertion code per enum code
	case "STRUCT":
		*classshapetargettype = STRUCT
	case "ENUM":
		*classshapetargettype = ENUM
	}
}

func (classshapetargettype *ClassshapeTargetType) ToCodeString() (res string) {

	switch *classshapetargettype {
	// insertion code per enum code
	case STRUCT:
		res = "STRUCT"
	case ENUM:
		res = "ENUM"
	}
	return
}

// Utility function for EditionMode
// if enum values are string, it is stored with the value
// if enum values are int, they are stored with the code of the value
func (editionmode EditionMode) ToString() (res string) {

	// migration of former implementation of enum
	switch editionmode {
	// insertion code per enum code
	case PRODUCTION_MODE:
		res = "PRODUCTION_MODE"
	case DEVELOPMENT_MODE:
		res = "DEVELOPMENT_MODE"
	}
	return
}

func (editionmode *EditionMode) FromString(input string) {

	switch input {
	// insertion code per enum code
	case "PRODUCTION_MODE":
		*editionmode = PRODUCTION_MODE
	case "DEVELOPMENT_MODE":
		*editionmode = DEVELOPMENT_MODE
	}
}

func (editionmode *EditionMode) ToCodeString() (res string) {

	switch *editionmode {
	// insertion code per enum code
	case PRODUCTION_MODE:
		res = "PRODUCTION_MODE"
	case DEVELOPMENT_MODE:
		res = "DEVELOPMENT_MODE"
	}
	return
}

// Utility function for GongdocCommandType
// if enum values are string, it is stored with the value
// if enum values are int, they are stored with the code of the value
func (gongdoccommandtype GongdocCommandType) ToString() (res string) {

	// migration of former implementation of enum
	switch gongdoccommandtype {
	// insertion code per enum code
	case MARSHALL_DIAGRAM:
		res = "MARSHALL_ALL_DIAGRAMS"
	case PRINT_ALL_DOCUMENTS:
		res = "PRINT_ALL_DOCUMENTS"
	case DIAGRAM_ELEMENT_DELETE:
		res = "DIAGRAM_ELEMENT_DELETE"
	case DIAGRAM_ELEMENT_CREATE:
		res = "DIAGRAM_ELEMENT_CREATE"
	case DIAGRAM_GONGSTRUCT_DELETE:
		res = "DIAGRAM_GONGSTRUCT_DELETE"
	case DIAGRAM_GONGSTRUCT_CREATE:
		res = "DIAGRAM_GONGSTRUCT_CREATE"
	case DIAGRAM_BASICFIELD_DELETE:
		res = "DIAGRAM_BASICFIELD_DELETE"
	case DIAGRAM_BASICFIELD_CREATE:
		res = "DIAGRAM_BASICFIELD_CREATE"
	case DIAGRAM_POINTER_TO_GONGSTRUCT_DELETE:
		res = "DIAGRAM_POINTER_TO_GONGSTRUCT_DELETE"
	case DIAGRAM_POINTER_TO_GONGSTRUCT_CREATE:
		res = "DIAGRAM_POINTER_TO_GONGSTRUCT_CREATE"
	case DIAGRAM_SLICE_OF_POINTERS_TO_GONGSTRUCT_DELETE:
		res = "DIAGRAM_SLICE_OF_POINTERS_TO_GONGSTRUCT_DELETE"
	case DIAGRAM_SLICE_OF_POINTERS_TO_GONGSTRUCT_CREATE:
		res = "DIAGRAM_SLICE_OF_POINTERS_TO_GONGSTRUCT_CREATE"
	case DIAGRAM_GONGSTRUCT_SELECT:
		res = "DIAGRAM_GONGSTRUCT_SELECT"
	}
	return
}

func (gongdoccommandtype *GongdocCommandType) FromString(input string) {

	switch input {
	// insertion code per enum code
	case "MARSHALL_ALL_DIAGRAMS":
		*gongdoccommandtype = MARSHALL_DIAGRAM
	case "PRINT_ALL_DOCUMENTS":
		*gongdoccommandtype = PRINT_ALL_DOCUMENTS
	case "DIAGRAM_ELEMENT_DELETE":
		*gongdoccommandtype = DIAGRAM_ELEMENT_DELETE
	case "DIAGRAM_ELEMENT_CREATE":
		*gongdoccommandtype = DIAGRAM_ELEMENT_CREATE
	case "DIAGRAM_GONGSTRUCT_DELETE":
		*gongdoccommandtype = DIAGRAM_GONGSTRUCT_DELETE
	case "DIAGRAM_GONGSTRUCT_CREATE":
		*gongdoccommandtype = DIAGRAM_GONGSTRUCT_CREATE
	case "DIAGRAM_BASICFIELD_DELETE":
		*gongdoccommandtype = DIAGRAM_BASICFIELD_DELETE
	case "DIAGRAM_BASICFIELD_CREATE":
		*gongdoccommandtype = DIAGRAM_BASICFIELD_CREATE
	case "DIAGRAM_POINTER_TO_GONGSTRUCT_DELETE":
		*gongdoccommandtype = DIAGRAM_POINTER_TO_GONGSTRUCT_DELETE
	case "DIAGRAM_POINTER_TO_GONGSTRUCT_CREATE":
		*gongdoccommandtype = DIAGRAM_POINTER_TO_GONGSTRUCT_CREATE
	case "DIAGRAM_SLICE_OF_POINTERS_TO_GONGSTRUCT_DELETE":
		*gongdoccommandtype = DIAGRAM_SLICE_OF_POINTERS_TO_GONGSTRUCT_DELETE
	case "DIAGRAM_SLICE_OF_POINTERS_TO_GONGSTRUCT_CREATE":
		*gongdoccommandtype = DIAGRAM_SLICE_OF_POINTERS_TO_GONGSTRUCT_CREATE
	case "DIAGRAM_GONGSTRUCT_SELECT":
		*gongdoccommandtype = DIAGRAM_GONGSTRUCT_SELECT
	}
}

func (gongdoccommandtype *GongdocCommandType) ToCodeString() (res string) {

	switch *gongdoccommandtype {
	// insertion code per enum code
	case MARSHALL_DIAGRAM:
		res = "MARSHALL_DIAGRAM"
	case PRINT_ALL_DOCUMENTS:
		res = "PRINT_ALL_DOCUMENTS"
	case DIAGRAM_ELEMENT_DELETE:
		res = "DIAGRAM_ELEMENT_DELETE"
	case DIAGRAM_ELEMENT_CREATE:
		res = "DIAGRAM_ELEMENT_CREATE"
	case DIAGRAM_GONGSTRUCT_DELETE:
		res = "DIAGRAM_GONGSTRUCT_DELETE"
	case DIAGRAM_GONGSTRUCT_CREATE:
		res = "DIAGRAM_GONGSTRUCT_CREATE"
	case DIAGRAM_BASICFIELD_DELETE:
		res = "DIAGRAM_BASICFIELD_DELETE"
	case DIAGRAM_BASICFIELD_CREATE:
		res = "DIAGRAM_BASICFIELD_CREATE"
	case DIAGRAM_POINTER_TO_GONGSTRUCT_DELETE:
		res = "DIAGRAM_POINTER_TO_GONGSTRUCT_DELETE"
	case DIAGRAM_POINTER_TO_GONGSTRUCT_CREATE:
		res = "DIAGRAM_POINTER_TO_GONGSTRUCT_CREATE"
	case DIAGRAM_SLICE_OF_POINTERS_TO_GONGSTRUCT_DELETE:
		res = "DIAGRAM_SLICE_OF_POINTERS_TO_GONGSTRUCT_DELETE"
	case DIAGRAM_SLICE_OF_POINTERS_TO_GONGSTRUCT_CREATE:
		res = "DIAGRAM_SLICE_OF_POINTERS_TO_GONGSTRUCT_CREATE"
	case DIAGRAM_GONGSTRUCT_SELECT:
		res = "DIAGRAM_GONGSTRUCT_SELECT"
	}
	return
}

// Utility function for GongdocNodeType
// if enum values are string, it is stored with the value
// if enum values are int, they are stored with the code of the value
func (gongdocnodetype GongdocNodeType) ToString() (res string) {

	// migration of former implementation of enum
	switch gongdocnodetype {
	// insertion code per enum code
	case ROOT_OF_GONG_STRUCTS:
		res = "ROOT_OF_GONG_STRUCTS"
	case GONG_STRUCT:
		res = "GONG_STRUCT"
	case ROOT_OF_BASIC_FIELDS:
		res = "ROOT_OF_BASIC_FIELDS"
	case BASIC_FIELD:
		res = "BASIC_FIELD"
	case ROOT_OF_TIME_FIELDS:
		res = "ROOT_OF_TIME_FIELDS"
	case TIME_FIELD:
		res = "TIME_FIELD"
	case ROOT_OF_POINTER_TO_STRUCT_FIELDS:
		res = "ROOT_OF_POINTER_TO_STRUCT_FIELDS"
	case POINTER_TO_STRUCT:
		res = "POINTER_TO_STRUCT"
	case ROOT_OF_SLICE_OF_POINTER_TO_GONG_STRUCT_FIELDS:
		res = "ROOT_OF_SLICE_OF_POINTER_TO_GONG_STRUCT_FIELDS"
	case SLICE_OF_POINTER_TO_STRUCT:
		res = "SLICE_OF_POINTER_TO_STRUCT"
	case ROOT_OF_M_N_ASSOCIATION_FIELDS:
		res = "ROOT_OF_M_N_ASSOCIATION_FIELDS"
	case M_N_ASSOCIATION_FIELD:
		res = "M_N_ASSOCIATION_FIELD"
	case ROOT_OF_GONG_NOTES:
		res = "ROOT_OF_GONG_NOTES"
	case GONG_NOTE:
		res = "GONG_NOTE"
	}
	return
}

func (gongdocnodetype *GongdocNodeType) FromString(input string) {

	switch input {
	// insertion code per enum code
	case "ROOT_OF_GONG_STRUCTS":
		*gongdocnodetype = ROOT_OF_GONG_STRUCTS
	case "GONG_STRUCT":
		*gongdocnodetype = GONG_STRUCT
	case "ROOT_OF_BASIC_FIELDS":
		*gongdocnodetype = ROOT_OF_BASIC_FIELDS
	case "BASIC_FIELD":
		*gongdocnodetype = BASIC_FIELD
	case "ROOT_OF_TIME_FIELDS":
		*gongdocnodetype = ROOT_OF_TIME_FIELDS
	case "TIME_FIELD":
		*gongdocnodetype = TIME_FIELD
	case "ROOT_OF_POINTER_TO_STRUCT_FIELDS":
		*gongdocnodetype = ROOT_OF_POINTER_TO_STRUCT_FIELDS
	case "POINTER_TO_STRUCT":
		*gongdocnodetype = POINTER_TO_STRUCT
	case "ROOT_OF_SLICE_OF_POINTER_TO_GONG_STRUCT_FIELDS":
		*gongdocnodetype = ROOT_OF_SLICE_OF_POINTER_TO_GONG_STRUCT_FIELDS
	case "SLICE_OF_POINTER_TO_STRUCT":
		*gongdocnodetype = SLICE_OF_POINTER_TO_STRUCT
	case "ROOT_OF_M_N_ASSOCIATION_FIELDS":
		*gongdocnodetype = ROOT_OF_M_N_ASSOCIATION_FIELDS
	case "M_N_ASSOCIATION_FIELD":
		*gongdocnodetype = M_N_ASSOCIATION_FIELD
	case "ROOT_OF_GONG_NOTES":
		*gongdocnodetype = ROOT_OF_GONG_NOTES
	case "GONG_NOTE":
		*gongdocnodetype = GONG_NOTE
	}
}

func (gongdocnodetype *GongdocNodeType) ToCodeString() (res string) {

	switch *gongdocnodetype {
	// insertion code per enum code
	case ROOT_OF_GONG_STRUCTS:
		res = "ROOT_OF_GONG_STRUCTS"
	case GONG_STRUCT:
		res = "GONG_STRUCT"
	case ROOT_OF_BASIC_FIELDS:
		res = "ROOT_OF_BASIC_FIELDS"
	case BASIC_FIELD:
		res = "BASIC_FIELD"
	case ROOT_OF_TIME_FIELDS:
		res = "ROOT_OF_TIME_FIELDS"
	case TIME_FIELD:
		res = "TIME_FIELD"
	case ROOT_OF_POINTER_TO_STRUCT_FIELDS:
		res = "ROOT_OF_POINTER_TO_STRUCT_FIELDS"
	case POINTER_TO_STRUCT:
		res = "POINTER_TO_STRUCT"
	case ROOT_OF_SLICE_OF_POINTER_TO_GONG_STRUCT_FIELDS:
		res = "ROOT_OF_SLICE_OF_POINTER_TO_GONG_STRUCT_FIELDS"
	case SLICE_OF_POINTER_TO_STRUCT:
		res = "SLICE_OF_POINTER_TO_STRUCT"
	case ROOT_OF_M_N_ASSOCIATION_FIELDS:
		res = "ROOT_OF_M_N_ASSOCIATION_FIELDS"
	case M_N_ASSOCIATION_FIELD:
		res = "M_N_ASSOCIATION_FIELD"
	case ROOT_OF_GONG_NOTES:
		res = "ROOT_OF_GONG_NOTES"
	case GONG_NOTE:
		res = "GONG_NOTE"
	}
	return
}

// Utility function for MultiplicityType
// if enum values are string, it is stored with the value
// if enum values are int, they are stored with the code of the value
func (multiplicitytype MultiplicityType) ToString() (res string) {

	// migration of former implementation of enum
	switch multiplicitytype {
	// insertion code per enum code
	case ZERO_ONE:
		res = "0..1"
	case ONE:
		res = "1"
	case MANY:
		res = "*"
	}
	return
}

func (multiplicitytype *MultiplicityType) FromString(input string) {

	switch input {
	// insertion code per enum code
	case "0..1":
		*multiplicitytype = ZERO_ONE
	case "1":
		*multiplicitytype = ONE
	case "*":
		*multiplicitytype = MANY
	}
}

func (multiplicitytype *MultiplicityType) ToCodeString() (res string) {

	switch *multiplicitytype {
	// insertion code per enum code
	case ZERO_ONE:
		res = "ZERO_ONE"
	case ONE:
		res = "ONE"
	case MANY:
		res = "MANY"
	}
	return
}

// Last line of the template
