// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gongsvg/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_Rect_sql sql.NullBool
var dummy_Rect_time time.Duration
var dummy_Rect_sort sort.Float64Slice

// RectAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model rectAPI
type RectAPI struct {
	gorm.Model

	models.Rect

	// encoding of pointers
	RectPointersEnconding
}

// RectPointersEnconding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type RectPointersEnconding struct {
	// insertion for pointer fields encoding declaration

	// Implementation of a reverse ID for field Layer{}.Rects []*Rect
	Layer_RectsDBID sql.NullInt64

	// implementation of the index of the withing the slice
	Layer_RectsDBID_Index sql.NullInt64
}

// RectDB describes a rect in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model rectDB
type RectDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field rectDB.Name
	Name_Data sql.NullString

	// Declation for basic field rectDB.X
	X_Data sql.NullFloat64

	// Declation for basic field rectDB.Y
	Y_Data sql.NullFloat64

	// Declation for basic field rectDB.Width
	Width_Data sql.NullFloat64

	// Declation for basic field rectDB.Height
	Height_Data sql.NullFloat64

	// Declation for basic field rectDB.RX
	RX_Data sql.NullFloat64

	// Declation for basic field rectDB.Color
	Color_Data sql.NullString

	// Declation for basic field rectDB.FillOpacity
	FillOpacity_Data sql.NullFloat64

	// Declation for basic field rectDB.Stroke
	Stroke_Data sql.NullString

	// Declation for basic field rectDB.StrokeWidth
	StrokeWidth_Data sql.NullFloat64

	// Declation for basic field rectDB.StrokeDashArray
	StrokeDashArray_Data sql.NullString

	// Declation for basic field rectDB.StrokeDashArrayWhenSelected
	StrokeDashArrayWhenSelected_Data sql.NullString

	// Declation for basic field rectDB.Transform
	Transform_Data sql.NullString

	// Declation for basic field rectDB.IsSelectable
	// provide the sql storage for the boolan
	IsSelectable_Data sql.NullBool

	// Declation for basic field rectDB.IsSelected
	// provide the sql storage for the boolan
	IsSelected_Data sql.NullBool

	// Declation for basic field rectDB.CanHaveLeftHandle
	// provide the sql storage for the boolan
	CanHaveLeftHandle_Data sql.NullBool

	// Declation for basic field rectDB.HasLeftHandle
	// provide the sql storage for the boolan
	HasLeftHandle_Data sql.NullBool

	// Declation for basic field rectDB.CanHaveRightHandle
	// provide the sql storage for the boolan
	CanHaveRightHandle_Data sql.NullBool

	// Declation for basic field rectDB.HasRightHandle
	// provide the sql storage for the boolan
	HasRightHandle_Data sql.NullBool

	// Declation for basic field rectDB.CanHaveTopHandle
	// provide the sql storage for the boolan
	CanHaveTopHandle_Data sql.NullBool

	// Declation for basic field rectDB.HasTopHandle
	// provide the sql storage for the boolan
	HasTopHandle_Data sql.NullBool

	// Declation for basic field rectDB.CanHaveBottomHandle
	// provide the sql storage for the boolan
	CanHaveBottomHandle_Data sql.NullBool

	// Declation for basic field rectDB.HasBottomHandle
	// provide the sql storage for the boolan
	HasBottomHandle_Data sql.NullBool

	// Declation for basic field rectDB.CanMoveHorizontaly
	// provide the sql storage for the boolan
	CanMoveHorizontaly_Data sql.NullBool

	// Declation for basic field rectDB.CanMoveVerticaly
	// provide the sql storage for the boolan
	CanMoveVerticaly_Data sql.NullBool
	// encoding of pointers
	RectPointersEnconding
}

// RectDBs arrays rectDBs
// swagger:response rectDBsResponse
type RectDBs []RectDB

// RectDBResponse provides response
// swagger:response rectDBResponse
type RectDBResponse struct {
	RectDB
}

// RectWOP is a Rect without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type RectWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Name string `xlsx:"1"`

	X float64 `xlsx:"2"`

	Y float64 `xlsx:"3"`

	Width float64 `xlsx:"4"`

	Height float64 `xlsx:"5"`

	RX float64 `xlsx:"6"`

	Color string `xlsx:"7"`

	FillOpacity float64 `xlsx:"8"`

	Stroke string `xlsx:"9"`

	StrokeWidth float64 `xlsx:"10"`

	StrokeDashArray string `xlsx:"11"`

	StrokeDashArrayWhenSelected string `xlsx:"12"`

	Transform string `xlsx:"13"`

	IsSelectable bool `xlsx:"14"`

	IsSelected bool `xlsx:"15"`

	CanHaveLeftHandle bool `xlsx:"16"`

	HasLeftHandle bool `xlsx:"17"`

	CanHaveRightHandle bool `xlsx:"18"`

	HasRightHandle bool `xlsx:"19"`

	CanHaveTopHandle bool `xlsx:"20"`

	HasTopHandle bool `xlsx:"21"`

	CanHaveBottomHandle bool `xlsx:"22"`

	HasBottomHandle bool `xlsx:"23"`

	CanMoveHorizontaly bool `xlsx:"24"`

	CanMoveVerticaly bool `xlsx:"25"`
	// insertion for WOP pointer fields
}

var Rect_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Name",
	"X",
	"Y",
	"Width",
	"Height",
	"RX",
	"Color",
	"FillOpacity",
	"Stroke",
	"StrokeWidth",
	"StrokeDashArray",
	"StrokeDashArrayWhenSelected",
	"Transform",
	"IsSelectable",
	"IsSelected",
	"CanHaveLeftHandle",
	"HasLeftHandle",
	"CanHaveRightHandle",
	"HasRightHandle",
	"CanHaveTopHandle",
	"HasTopHandle",
	"CanHaveBottomHandle",
	"HasBottomHandle",
	"CanMoveHorizontaly",
	"CanMoveVerticaly",
}

type BackRepoRectStruct struct {
	// stores RectDB according to their gorm ID
	Map_RectDBID_RectDB map[uint]*RectDB

	// stores RectDB ID according to Rect address
	Map_RectPtr_RectDBID map[*models.Rect]uint

	// stores Rect according to their gorm ID
	Map_RectDBID_RectPtr map[uint]*models.Rect

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoRect *BackRepoRectStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoRect.stage
	return
}

func (backRepoRect *BackRepoRectStruct) GetDB() *gorm.DB {
	return backRepoRect.db
}

// GetRectDBFromRectPtr is a handy function to access the back repo instance from the stage instance
func (backRepoRect *BackRepoRectStruct) GetRectDBFromRectPtr(rect *models.Rect) (rectDB *RectDB) {
	id := backRepoRect.Map_RectPtr_RectDBID[rect]
	rectDB = backRepoRect.Map_RectDBID_RectDB[id]
	return
}

// BackRepoRect.CommitPhaseOne commits all staged instances of Rect to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoRect *BackRepoRectStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for rect := range stage.Rects {
		backRepoRect.CommitPhaseOneInstance(rect)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, rect := range backRepoRect.Map_RectDBID_RectPtr {
		if _, ok := stage.Rects[rect]; !ok {
			backRepoRect.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoRect.CommitDeleteInstance commits deletion of Rect to the BackRepo
func (backRepoRect *BackRepoRectStruct) CommitDeleteInstance(id uint) (Error error) {

	rect := backRepoRect.Map_RectDBID_RectPtr[id]

	// rect is not staged anymore, remove rectDB
	rectDB := backRepoRect.Map_RectDBID_RectDB[id]
	query := backRepoRect.db.Unscoped().Delete(&rectDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	delete(backRepoRect.Map_RectPtr_RectDBID, rect)
	delete(backRepoRect.Map_RectDBID_RectPtr, id)
	delete(backRepoRect.Map_RectDBID_RectDB, id)

	return
}

// BackRepoRect.CommitPhaseOneInstance commits rect staged instances of Rect to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoRect *BackRepoRectStruct) CommitPhaseOneInstance(rect *models.Rect) (Error error) {

	// check if the rect is not commited yet
	if _, ok := backRepoRect.Map_RectPtr_RectDBID[rect]; ok {
		return
	}

	// initiate rect
	var rectDB RectDB
	rectDB.CopyBasicFieldsFromRect(rect)

	query := backRepoRect.db.Create(&rectDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	backRepoRect.Map_RectPtr_RectDBID[rect] = rectDB.ID
	backRepoRect.Map_RectDBID_RectPtr[rectDB.ID] = rect
	backRepoRect.Map_RectDBID_RectDB[rectDB.ID] = &rectDB

	return
}

// BackRepoRect.CommitPhaseTwo commits all staged instances of Rect to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoRect *BackRepoRectStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, rect := range backRepoRect.Map_RectDBID_RectPtr {
		backRepoRect.CommitPhaseTwoInstance(backRepo, idx, rect)
	}

	return
}

// BackRepoRect.CommitPhaseTwoInstance commits {{structname }} of models.Rect to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoRect *BackRepoRectStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, rect *models.Rect) (Error error) {

	// fetch matching rectDB
	if rectDB, ok := backRepoRect.Map_RectDBID_RectDB[idx]; ok {

		rectDB.CopyBasicFieldsFromRect(rect)

		// insertion point for translating pointers encodings into actual pointers
		// This loop encodes the slice of pointers rect.Animations into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, animateAssocEnd := range rect.Animations {

			// get the back repo instance at the association end
			animateAssocEnd_DB :=
				backRepo.BackRepoAnimate.GetAnimateDBFromAnimatePtr(animateAssocEnd)

			// encode reverse pointer in the association end back repo instance
			animateAssocEnd_DB.Rect_AnimationsDBID.Int64 = int64(rectDB.ID)
			animateAssocEnd_DB.Rect_AnimationsDBID.Valid = true
			animateAssocEnd_DB.Rect_AnimationsDBID_Index.Int64 = int64(idx)
			animateAssocEnd_DB.Rect_AnimationsDBID_Index.Valid = true
			if q := backRepoRect.db.Save(animateAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		// This loop encodes the slice of pointers rect.RectAnchoredTexts into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, rectanchoredtextAssocEnd := range rect.RectAnchoredTexts {

			// get the back repo instance at the association end
			rectanchoredtextAssocEnd_DB :=
				backRepo.BackRepoRectAnchoredText.GetRectAnchoredTextDBFromRectAnchoredTextPtr(rectanchoredtextAssocEnd)

			// encode reverse pointer in the association end back repo instance
			rectanchoredtextAssocEnd_DB.Rect_RectAnchoredTextsDBID.Int64 = int64(rectDB.ID)
			rectanchoredtextAssocEnd_DB.Rect_RectAnchoredTextsDBID.Valid = true
			rectanchoredtextAssocEnd_DB.Rect_RectAnchoredTextsDBID_Index.Int64 = int64(idx)
			rectanchoredtextAssocEnd_DB.Rect_RectAnchoredTextsDBID_Index.Valid = true
			if q := backRepoRect.db.Save(rectanchoredtextAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		// This loop encodes the slice of pointers rect.RectAnchoredRects into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, rectanchoredrectAssocEnd := range rect.RectAnchoredRects {

			// get the back repo instance at the association end
			rectanchoredrectAssocEnd_DB :=
				backRepo.BackRepoRectAnchoredRect.GetRectAnchoredRectDBFromRectAnchoredRectPtr(rectanchoredrectAssocEnd)

			// encode reverse pointer in the association end back repo instance
			rectanchoredrectAssocEnd_DB.Rect_RectAnchoredRectsDBID.Int64 = int64(rectDB.ID)
			rectanchoredrectAssocEnd_DB.Rect_RectAnchoredRectsDBID.Valid = true
			rectanchoredrectAssocEnd_DB.Rect_RectAnchoredRectsDBID_Index.Int64 = int64(idx)
			rectanchoredrectAssocEnd_DB.Rect_RectAnchoredRectsDBID_Index.Valid = true
			if q := backRepoRect.db.Save(rectanchoredrectAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		query := backRepoRect.db.Save(&rectDB)
		if query.Error != nil {
			return query.Error
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Rect intance %s", rect.Name))
		return err
	}

	return
}

// BackRepoRect.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoRect *BackRepoRectStruct) CheckoutPhaseOne() (Error error) {

	rectDBArray := make([]RectDB, 0)
	query := backRepoRect.db.Find(&rectDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	rectInstancesToBeRemovedFromTheStage := make(map[*models.Rect]any)
	for key, value := range backRepoRect.stage.Rects {
		rectInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, rectDB := range rectDBArray {
		backRepoRect.CheckoutPhaseOneInstance(&rectDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		rect, ok := backRepoRect.Map_RectDBID_RectPtr[rectDB.ID]
		if ok {
			delete(rectInstancesToBeRemovedFromTheStage, rect)
		}
	}

	// remove from stage and back repo's 3 maps all rects that are not in the checkout
	for rect := range rectInstancesToBeRemovedFromTheStage {
		rect.Unstage(backRepoRect.GetStage())

		// remove instance from the back repo 3 maps
		rectID := backRepoRect.Map_RectPtr_RectDBID[rect]
		delete(backRepoRect.Map_RectPtr_RectDBID, rect)
		delete(backRepoRect.Map_RectDBID_RectDB, rectID)
		delete(backRepoRect.Map_RectDBID_RectPtr, rectID)
	}

	return
}

// CheckoutPhaseOneInstance takes a rectDB that has been found in the DB, updates the backRepo and stages the
// models version of the rectDB
func (backRepoRect *BackRepoRectStruct) CheckoutPhaseOneInstance(rectDB *RectDB) (Error error) {

	rect, ok := backRepoRect.Map_RectDBID_RectPtr[rectDB.ID]
	if !ok {
		rect = new(models.Rect)

		backRepoRect.Map_RectDBID_RectPtr[rectDB.ID] = rect
		backRepoRect.Map_RectPtr_RectDBID[rect] = rectDB.ID

		// append model store with the new element
		rect.Name = rectDB.Name_Data.String
		rect.Stage(backRepoRect.GetStage())
	}
	rectDB.CopyBasicFieldsToRect(rect)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	rect.Stage(backRepoRect.GetStage())

	// preserve pointer to rectDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_RectDBID_RectDB)[rectDB hold variable pointers
	rectDB_Data := *rectDB
	preservedPtrToRect := &rectDB_Data
	backRepoRect.Map_RectDBID_RectDB[rectDB.ID] = preservedPtrToRect

	return
}

// BackRepoRect.CheckoutPhaseTwo Checkouts all staged instances of Rect to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoRect *BackRepoRectStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, rectDB := range backRepoRect.Map_RectDBID_RectDB {
		backRepoRect.CheckoutPhaseTwoInstance(backRepo, rectDB)
	}
	return
}

// BackRepoRect.CheckoutPhaseTwoInstance Checkouts staged instances of Rect to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoRect *BackRepoRectStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, rectDB *RectDB) (Error error) {

	rect := backRepoRect.Map_RectDBID_RectPtr[rectDB.ID]
	_ = rect // sometimes, there is no code generated. This lines voids the "unused variable" compilation error

	// insertion point for checkout of pointer encoding
	// This loop redeem rect.Animations in the stage from the encode in the back repo
	// It parses all AnimateDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	rect.Animations = rect.Animations[:0]
	// 2. loop all instances in the type in the association end
	for _, animateDB_AssocEnd := range backRepo.BackRepoAnimate.Map_AnimateDBID_AnimateDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if animateDB_AssocEnd.Rect_AnimationsDBID.Int64 == int64(rectDB.ID) {
			// 4. fetch the associated instance in the stage
			animate_AssocEnd := backRepo.BackRepoAnimate.Map_AnimateDBID_AnimatePtr[animateDB_AssocEnd.ID]
			// 5. append it the association slice
			rect.Animations = append(rect.Animations, animate_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(rect.Animations, func(i, j int) bool {
		animateDB_i_ID := backRepo.BackRepoAnimate.Map_AnimatePtr_AnimateDBID[rect.Animations[i]]
		animateDB_j_ID := backRepo.BackRepoAnimate.Map_AnimatePtr_AnimateDBID[rect.Animations[j]]

		animateDB_i := backRepo.BackRepoAnimate.Map_AnimateDBID_AnimateDB[animateDB_i_ID]
		animateDB_j := backRepo.BackRepoAnimate.Map_AnimateDBID_AnimateDB[animateDB_j_ID]

		return animateDB_i.Rect_AnimationsDBID_Index.Int64 < animateDB_j.Rect_AnimationsDBID_Index.Int64
	})

	// This loop redeem rect.RectAnchoredTexts in the stage from the encode in the back repo
	// It parses all RectAnchoredTextDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	rect.RectAnchoredTexts = rect.RectAnchoredTexts[:0]
	// 2. loop all instances in the type in the association end
	for _, rectanchoredtextDB_AssocEnd := range backRepo.BackRepoRectAnchoredText.Map_RectAnchoredTextDBID_RectAnchoredTextDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if rectanchoredtextDB_AssocEnd.Rect_RectAnchoredTextsDBID.Int64 == int64(rectDB.ID) {
			// 4. fetch the associated instance in the stage
			rectanchoredtext_AssocEnd := backRepo.BackRepoRectAnchoredText.Map_RectAnchoredTextDBID_RectAnchoredTextPtr[rectanchoredtextDB_AssocEnd.ID]
			// 5. append it the association slice
			rect.RectAnchoredTexts = append(rect.RectAnchoredTexts, rectanchoredtext_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(rect.RectAnchoredTexts, func(i, j int) bool {
		rectanchoredtextDB_i_ID := backRepo.BackRepoRectAnchoredText.Map_RectAnchoredTextPtr_RectAnchoredTextDBID[rect.RectAnchoredTexts[i]]
		rectanchoredtextDB_j_ID := backRepo.BackRepoRectAnchoredText.Map_RectAnchoredTextPtr_RectAnchoredTextDBID[rect.RectAnchoredTexts[j]]

		rectanchoredtextDB_i := backRepo.BackRepoRectAnchoredText.Map_RectAnchoredTextDBID_RectAnchoredTextDB[rectanchoredtextDB_i_ID]
		rectanchoredtextDB_j := backRepo.BackRepoRectAnchoredText.Map_RectAnchoredTextDBID_RectAnchoredTextDB[rectanchoredtextDB_j_ID]

		return rectanchoredtextDB_i.Rect_RectAnchoredTextsDBID_Index.Int64 < rectanchoredtextDB_j.Rect_RectAnchoredTextsDBID_Index.Int64
	})

	// This loop redeem rect.RectAnchoredRects in the stage from the encode in the back repo
	// It parses all RectAnchoredRectDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	rect.RectAnchoredRects = rect.RectAnchoredRects[:0]
	// 2. loop all instances in the type in the association end
	for _, rectanchoredrectDB_AssocEnd := range backRepo.BackRepoRectAnchoredRect.Map_RectAnchoredRectDBID_RectAnchoredRectDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if rectanchoredrectDB_AssocEnd.Rect_RectAnchoredRectsDBID.Int64 == int64(rectDB.ID) {
			// 4. fetch the associated instance in the stage
			rectanchoredrect_AssocEnd := backRepo.BackRepoRectAnchoredRect.Map_RectAnchoredRectDBID_RectAnchoredRectPtr[rectanchoredrectDB_AssocEnd.ID]
			// 5. append it the association slice
			rect.RectAnchoredRects = append(rect.RectAnchoredRects, rectanchoredrect_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(rect.RectAnchoredRects, func(i, j int) bool {
		rectanchoredrectDB_i_ID := backRepo.BackRepoRectAnchoredRect.Map_RectAnchoredRectPtr_RectAnchoredRectDBID[rect.RectAnchoredRects[i]]
		rectanchoredrectDB_j_ID := backRepo.BackRepoRectAnchoredRect.Map_RectAnchoredRectPtr_RectAnchoredRectDBID[rect.RectAnchoredRects[j]]

		rectanchoredrectDB_i := backRepo.BackRepoRectAnchoredRect.Map_RectAnchoredRectDBID_RectAnchoredRectDB[rectanchoredrectDB_i_ID]
		rectanchoredrectDB_j := backRepo.BackRepoRectAnchoredRect.Map_RectAnchoredRectDBID_RectAnchoredRectDB[rectanchoredrectDB_j_ID]

		return rectanchoredrectDB_i.Rect_RectAnchoredRectsDBID_Index.Int64 < rectanchoredrectDB_j.Rect_RectAnchoredRectsDBID_Index.Int64
	})

	return
}

// CommitRect allows commit of a single rect (if already staged)
func (backRepo *BackRepoStruct) CommitRect(rect *models.Rect) {
	backRepo.BackRepoRect.CommitPhaseOneInstance(rect)
	if id, ok := backRepo.BackRepoRect.Map_RectPtr_RectDBID[rect]; ok {
		backRepo.BackRepoRect.CommitPhaseTwoInstance(backRepo, id, rect)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitRect allows checkout of a single rect (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutRect(rect *models.Rect) {
	// check if the rect is staged
	if _, ok := backRepo.BackRepoRect.Map_RectPtr_RectDBID[rect]; ok {

		if id, ok := backRepo.BackRepoRect.Map_RectPtr_RectDBID[rect]; ok {
			var rectDB RectDB
			rectDB.ID = id

			if err := backRepo.BackRepoRect.db.First(&rectDB, id).Error; err != nil {
				log.Panicln("CheckoutRect : Problem with getting object with id:", id)
			}
			backRepo.BackRepoRect.CheckoutPhaseOneInstance(&rectDB)
			backRepo.BackRepoRect.CheckoutPhaseTwoInstance(backRepo, &rectDB)
		}
	}
}

// CopyBasicFieldsFromRect
func (rectDB *RectDB) CopyBasicFieldsFromRect(rect *models.Rect) {
	// insertion point for fields commit

	rectDB.Name_Data.String = rect.Name
	rectDB.Name_Data.Valid = true

	rectDB.X_Data.Float64 = rect.X
	rectDB.X_Data.Valid = true

	rectDB.Y_Data.Float64 = rect.Y
	rectDB.Y_Data.Valid = true

	rectDB.Width_Data.Float64 = rect.Width
	rectDB.Width_Data.Valid = true

	rectDB.Height_Data.Float64 = rect.Height
	rectDB.Height_Data.Valid = true

	rectDB.RX_Data.Float64 = rect.RX
	rectDB.RX_Data.Valid = true

	rectDB.Color_Data.String = rect.Color
	rectDB.Color_Data.Valid = true

	rectDB.FillOpacity_Data.Float64 = rect.FillOpacity
	rectDB.FillOpacity_Data.Valid = true

	rectDB.Stroke_Data.String = rect.Stroke
	rectDB.Stroke_Data.Valid = true

	rectDB.StrokeWidth_Data.Float64 = rect.StrokeWidth
	rectDB.StrokeWidth_Data.Valid = true

	rectDB.StrokeDashArray_Data.String = rect.StrokeDashArray
	rectDB.StrokeDashArray_Data.Valid = true

	rectDB.StrokeDashArrayWhenSelected_Data.String = rect.StrokeDashArrayWhenSelected
	rectDB.StrokeDashArrayWhenSelected_Data.Valid = true

	rectDB.Transform_Data.String = rect.Transform
	rectDB.Transform_Data.Valid = true

	rectDB.IsSelectable_Data.Bool = rect.IsSelectable
	rectDB.IsSelectable_Data.Valid = true

	rectDB.IsSelected_Data.Bool = rect.IsSelected
	rectDB.IsSelected_Data.Valid = true

	rectDB.CanHaveLeftHandle_Data.Bool = rect.CanHaveLeftHandle
	rectDB.CanHaveLeftHandle_Data.Valid = true

	rectDB.HasLeftHandle_Data.Bool = rect.HasLeftHandle
	rectDB.HasLeftHandle_Data.Valid = true

	rectDB.CanHaveRightHandle_Data.Bool = rect.CanHaveRightHandle
	rectDB.CanHaveRightHandle_Data.Valid = true

	rectDB.HasRightHandle_Data.Bool = rect.HasRightHandle
	rectDB.HasRightHandle_Data.Valid = true

	rectDB.CanHaveTopHandle_Data.Bool = rect.CanHaveTopHandle
	rectDB.CanHaveTopHandle_Data.Valid = true

	rectDB.HasTopHandle_Data.Bool = rect.HasTopHandle
	rectDB.HasTopHandle_Data.Valid = true

	rectDB.CanHaveBottomHandle_Data.Bool = rect.CanHaveBottomHandle
	rectDB.CanHaveBottomHandle_Data.Valid = true

	rectDB.HasBottomHandle_Data.Bool = rect.HasBottomHandle
	rectDB.HasBottomHandle_Data.Valid = true

	rectDB.CanMoveHorizontaly_Data.Bool = rect.CanMoveHorizontaly
	rectDB.CanMoveHorizontaly_Data.Valid = true

	rectDB.CanMoveVerticaly_Data.Bool = rect.CanMoveVerticaly
	rectDB.CanMoveVerticaly_Data.Valid = true
}

// CopyBasicFieldsFromRectWOP
func (rectDB *RectDB) CopyBasicFieldsFromRectWOP(rect *RectWOP) {
	// insertion point for fields commit

	rectDB.Name_Data.String = rect.Name
	rectDB.Name_Data.Valid = true

	rectDB.X_Data.Float64 = rect.X
	rectDB.X_Data.Valid = true

	rectDB.Y_Data.Float64 = rect.Y
	rectDB.Y_Data.Valid = true

	rectDB.Width_Data.Float64 = rect.Width
	rectDB.Width_Data.Valid = true

	rectDB.Height_Data.Float64 = rect.Height
	rectDB.Height_Data.Valid = true

	rectDB.RX_Data.Float64 = rect.RX
	rectDB.RX_Data.Valid = true

	rectDB.Color_Data.String = rect.Color
	rectDB.Color_Data.Valid = true

	rectDB.FillOpacity_Data.Float64 = rect.FillOpacity
	rectDB.FillOpacity_Data.Valid = true

	rectDB.Stroke_Data.String = rect.Stroke
	rectDB.Stroke_Data.Valid = true

	rectDB.StrokeWidth_Data.Float64 = rect.StrokeWidth
	rectDB.StrokeWidth_Data.Valid = true

	rectDB.StrokeDashArray_Data.String = rect.StrokeDashArray
	rectDB.StrokeDashArray_Data.Valid = true

	rectDB.StrokeDashArrayWhenSelected_Data.String = rect.StrokeDashArrayWhenSelected
	rectDB.StrokeDashArrayWhenSelected_Data.Valid = true

	rectDB.Transform_Data.String = rect.Transform
	rectDB.Transform_Data.Valid = true

	rectDB.IsSelectable_Data.Bool = rect.IsSelectable
	rectDB.IsSelectable_Data.Valid = true

	rectDB.IsSelected_Data.Bool = rect.IsSelected
	rectDB.IsSelected_Data.Valid = true

	rectDB.CanHaveLeftHandle_Data.Bool = rect.CanHaveLeftHandle
	rectDB.CanHaveLeftHandle_Data.Valid = true

	rectDB.HasLeftHandle_Data.Bool = rect.HasLeftHandle
	rectDB.HasLeftHandle_Data.Valid = true

	rectDB.CanHaveRightHandle_Data.Bool = rect.CanHaveRightHandle
	rectDB.CanHaveRightHandle_Data.Valid = true

	rectDB.HasRightHandle_Data.Bool = rect.HasRightHandle
	rectDB.HasRightHandle_Data.Valid = true

	rectDB.CanHaveTopHandle_Data.Bool = rect.CanHaveTopHandle
	rectDB.CanHaveTopHandle_Data.Valid = true

	rectDB.HasTopHandle_Data.Bool = rect.HasTopHandle
	rectDB.HasTopHandle_Data.Valid = true

	rectDB.CanHaveBottomHandle_Data.Bool = rect.CanHaveBottomHandle
	rectDB.CanHaveBottomHandle_Data.Valid = true

	rectDB.HasBottomHandle_Data.Bool = rect.HasBottomHandle
	rectDB.HasBottomHandle_Data.Valid = true

	rectDB.CanMoveHorizontaly_Data.Bool = rect.CanMoveHorizontaly
	rectDB.CanMoveHorizontaly_Data.Valid = true

	rectDB.CanMoveVerticaly_Data.Bool = rect.CanMoveVerticaly
	rectDB.CanMoveVerticaly_Data.Valid = true
}

// CopyBasicFieldsToRect
func (rectDB *RectDB) CopyBasicFieldsToRect(rect *models.Rect) {
	// insertion point for checkout of basic fields (back repo to stage)
	rect.Name = rectDB.Name_Data.String
	rect.X = rectDB.X_Data.Float64
	rect.Y = rectDB.Y_Data.Float64
	rect.Width = rectDB.Width_Data.Float64
	rect.Height = rectDB.Height_Data.Float64
	rect.RX = rectDB.RX_Data.Float64
	rect.Color = rectDB.Color_Data.String
	rect.FillOpacity = rectDB.FillOpacity_Data.Float64
	rect.Stroke = rectDB.Stroke_Data.String
	rect.StrokeWidth = rectDB.StrokeWidth_Data.Float64
	rect.StrokeDashArray = rectDB.StrokeDashArray_Data.String
	rect.StrokeDashArrayWhenSelected = rectDB.StrokeDashArrayWhenSelected_Data.String
	rect.Transform = rectDB.Transform_Data.String
	rect.IsSelectable = rectDB.IsSelectable_Data.Bool
	rect.IsSelected = rectDB.IsSelected_Data.Bool
	rect.CanHaveLeftHandle = rectDB.CanHaveLeftHandle_Data.Bool
	rect.HasLeftHandle = rectDB.HasLeftHandle_Data.Bool
	rect.CanHaveRightHandle = rectDB.CanHaveRightHandle_Data.Bool
	rect.HasRightHandle = rectDB.HasRightHandle_Data.Bool
	rect.CanHaveTopHandle = rectDB.CanHaveTopHandle_Data.Bool
	rect.HasTopHandle = rectDB.HasTopHandle_Data.Bool
	rect.CanHaveBottomHandle = rectDB.CanHaveBottomHandle_Data.Bool
	rect.HasBottomHandle = rectDB.HasBottomHandle_Data.Bool
	rect.CanMoveHorizontaly = rectDB.CanMoveHorizontaly_Data.Bool
	rect.CanMoveVerticaly = rectDB.CanMoveVerticaly_Data.Bool
}

// CopyBasicFieldsToRectWOP
func (rectDB *RectDB) CopyBasicFieldsToRectWOP(rect *RectWOP) {
	rect.ID = int(rectDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	rect.Name = rectDB.Name_Data.String
	rect.X = rectDB.X_Data.Float64
	rect.Y = rectDB.Y_Data.Float64
	rect.Width = rectDB.Width_Data.Float64
	rect.Height = rectDB.Height_Data.Float64
	rect.RX = rectDB.RX_Data.Float64
	rect.Color = rectDB.Color_Data.String
	rect.FillOpacity = rectDB.FillOpacity_Data.Float64
	rect.Stroke = rectDB.Stroke_Data.String
	rect.StrokeWidth = rectDB.StrokeWidth_Data.Float64
	rect.StrokeDashArray = rectDB.StrokeDashArray_Data.String
	rect.StrokeDashArrayWhenSelected = rectDB.StrokeDashArrayWhenSelected_Data.String
	rect.Transform = rectDB.Transform_Data.String
	rect.IsSelectable = rectDB.IsSelectable_Data.Bool
	rect.IsSelected = rectDB.IsSelected_Data.Bool
	rect.CanHaveLeftHandle = rectDB.CanHaveLeftHandle_Data.Bool
	rect.HasLeftHandle = rectDB.HasLeftHandle_Data.Bool
	rect.CanHaveRightHandle = rectDB.CanHaveRightHandle_Data.Bool
	rect.HasRightHandle = rectDB.HasRightHandle_Data.Bool
	rect.CanHaveTopHandle = rectDB.CanHaveTopHandle_Data.Bool
	rect.HasTopHandle = rectDB.HasTopHandle_Data.Bool
	rect.CanHaveBottomHandle = rectDB.CanHaveBottomHandle_Data.Bool
	rect.HasBottomHandle = rectDB.HasBottomHandle_Data.Bool
	rect.CanMoveHorizontaly = rectDB.CanMoveHorizontaly_Data.Bool
	rect.CanMoveVerticaly = rectDB.CanMoveVerticaly_Data.Bool
}

// Backup generates a json file from a slice of all RectDB instances in the backrepo
func (backRepoRect *BackRepoRectStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "RectDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*RectDB, 0)
	for _, rectDB := range backRepoRect.Map_RectDBID_RectDB {
		forBackup = append(forBackup, rectDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Panic("Cannot json Rect ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Panic("Cannot write the json Rect file", err.Error())
	}
}

// Backup generates a json file from a slice of all RectDB instances in the backrepo
func (backRepoRect *BackRepoRectStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*RectDB, 0)
	for _, rectDB := range backRepoRect.Map_RectDBID_RectDB {
		forBackup = append(forBackup, rectDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("Rect")
	if err != nil {
		log.Panic("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&Rect_Fields, -1)
	for _, rectDB := range forBackup {

		var rectWOP RectWOP
		rectDB.CopyBasicFieldsToRectWOP(&rectWOP)

		row := sh.AddRow()
		row.WriteStruct(&rectWOP, -1)
	}
}

// RestoreXL from the "Rect" sheet all RectDB instances
func (backRepoRect *BackRepoRectStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoRectid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["Rect"]
	_ = sh
	if !ok {
		log.Panic(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoRect.rowVisitorRect)
	if err != nil {
		log.Panic("Err=", err)
	}
}

func (backRepoRect *BackRepoRectStruct) rowVisitorRect(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var rectWOP RectWOP
		row.ReadStruct(&rectWOP)

		// add the unmarshalled struct to the stage
		rectDB := new(RectDB)
		rectDB.CopyBasicFieldsFromRectWOP(&rectWOP)

		rectDB_ID_atBackupTime := rectDB.ID
		rectDB.ID = 0
		query := backRepoRect.db.Create(rectDB)
		if query.Error != nil {
			log.Panic(query.Error)
		}
		backRepoRect.Map_RectDBID_RectDB[rectDB.ID] = rectDB
		BackRepoRectid_atBckpTime_newID[rectDB_ID_atBackupTime] = rectDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "RectDB.json" in dirPath that stores an array
// of RectDB and stores it in the database
// the map BackRepoRectid_atBckpTime_newID is updated accordingly
func (backRepoRect *BackRepoRectStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoRectid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "RectDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Panic("Cannot restore/open the json Rect file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*RectDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_RectDBID_RectDB
	for _, rectDB := range forRestore {

		rectDB_ID_atBackupTime := rectDB.ID
		rectDB.ID = 0
		query := backRepoRect.db.Create(rectDB)
		if query.Error != nil {
			log.Panic(query.Error)
		}
		backRepoRect.Map_RectDBID_RectDB[rectDB.ID] = rectDB
		BackRepoRectid_atBckpTime_newID[rectDB_ID_atBackupTime] = rectDB.ID
	}

	if err != nil {
		log.Panic("Cannot restore/unmarshall json Rect file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<Rect>id_atBckpTime_newID
// to compute new index
func (backRepoRect *BackRepoRectStruct) RestorePhaseTwo() {

	for _, rectDB := range backRepoRect.Map_RectDBID_RectDB {

		// next line of code is to avert unused variable compilation error
		_ = rectDB

		// insertion point for reindexing pointers encoding
		// This reindex rect.Rects
		if rectDB.Layer_RectsDBID.Int64 != 0 {
			rectDB.Layer_RectsDBID.Int64 =
				int64(BackRepoLayerid_atBckpTime_newID[uint(rectDB.Layer_RectsDBID.Int64)])
		}

		// update databse with new index encoding
		query := backRepoRect.db.Model(rectDB).Updates(*rectDB)
		if query.Error != nil {
			log.Panic(query.Error)
		}
	}

}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoRectid_atBckpTime_newID map[uint]uint
