// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gongsvg/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_Layer_sql sql.NullBool
var dummy_Layer_time time.Duration
var dummy_Layer_sort sort.Float64Slice

// LayerAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model layerAPI
type LayerAPI struct {
	gorm.Model

	models.Layer

	// encoding of pointers
	LayerPointersEnconding
}

// LayerPointersEnconding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type LayerPointersEnconding struct {
	// insertion for pointer fields encoding declaration

	// Implementation of a reverse ID for field SVG{}.Layers []*Layer
	SVG_LayersDBID sql.NullInt64

	// implementation of the index of the withing the slice
	SVG_LayersDBID_Index sql.NullInt64
}

// LayerDB describes a layer in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model layerDB
type LayerDB struct {
	gorm.Model

	// insertion for basic fields declaration

	// Declation for basic field layerDB.Display
	// provide the sql storage for the boolan
	Display_Data sql.NullBool

	// Declation for basic field layerDB.Name
	Name_Data sql.NullString
	// encoding of pointers
	LayerPointersEnconding
}

// LayerDBs arrays layerDBs
// swagger:response layerDBsResponse
type LayerDBs []LayerDB

// LayerDBResponse provides response
// swagger:response layerDBResponse
type LayerDBResponse struct {
	LayerDB
}

// LayerWOP is a Layer without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type LayerWOP struct {
	ID int `xlsx:"0"`

	// insertion for WOP basic fields

	Display bool `xlsx:"1"`

	Name string `xlsx:"2"`
	// insertion for WOP pointer fields
}

var Layer_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Display",
	"Name",
}

type BackRepoLayerStruct struct {
	// stores LayerDB according to their gorm ID
	Map_LayerDBID_LayerDB map[uint]*LayerDB

	// stores LayerDB ID according to Layer address
	Map_LayerPtr_LayerDBID map[*models.Layer]uint

	// stores Layer according to their gorm ID
	Map_LayerDBID_LayerPtr map[uint]*models.Layer

	db *gorm.DB

	stage *models.StageStruct
}

func (backRepoLayer *BackRepoLayerStruct) GetStage() (stage *models.StageStruct) {
	stage = backRepoLayer.stage
	return
}

func (backRepoLayer *BackRepoLayerStruct) GetDB() *gorm.DB {
	return backRepoLayer.db
}

// GetLayerDBFromLayerPtr is a handy function to access the back repo instance from the stage instance
func (backRepoLayer *BackRepoLayerStruct) GetLayerDBFromLayerPtr(layer *models.Layer) (layerDB *LayerDB) {
	id := backRepoLayer.Map_LayerPtr_LayerDBID[layer]
	layerDB = backRepoLayer.Map_LayerDBID_LayerDB[id]
	return
}

// BackRepoLayer.CommitPhaseOne commits all staged instances of Layer to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoLayer *BackRepoLayerStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for layer := range stage.Layers {
		backRepoLayer.CommitPhaseOneInstance(layer)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, layer := range backRepoLayer.Map_LayerDBID_LayerPtr {
		if _, ok := stage.Layers[layer]; !ok {
			backRepoLayer.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoLayer.CommitDeleteInstance commits deletion of Layer to the BackRepo
func (backRepoLayer *BackRepoLayerStruct) CommitDeleteInstance(id uint) (Error error) {

	layer := backRepoLayer.Map_LayerDBID_LayerPtr[id]

	// layer is not staged anymore, remove layerDB
	layerDB := backRepoLayer.Map_LayerDBID_LayerDB[id]
	query := backRepoLayer.db.Unscoped().Delete(&layerDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	delete(backRepoLayer.Map_LayerPtr_LayerDBID, layer)
	delete(backRepoLayer.Map_LayerDBID_LayerPtr, id)
	delete(backRepoLayer.Map_LayerDBID_LayerDB, id)

	return
}

// BackRepoLayer.CommitPhaseOneInstance commits layer staged instances of Layer to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoLayer *BackRepoLayerStruct) CommitPhaseOneInstance(layer *models.Layer) (Error error) {

	// check if the layer is not commited yet
	if _, ok := backRepoLayer.Map_LayerPtr_LayerDBID[layer]; ok {
		return
	}

	// initiate layer
	var layerDB LayerDB
	layerDB.CopyBasicFieldsFromLayer(layer)

	query := backRepoLayer.db.Create(&layerDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	backRepoLayer.Map_LayerPtr_LayerDBID[layer] = layerDB.ID
	backRepoLayer.Map_LayerDBID_LayerPtr[layerDB.ID] = layer
	backRepoLayer.Map_LayerDBID_LayerDB[layerDB.ID] = &layerDB

	return
}

// BackRepoLayer.CommitPhaseTwo commits all staged instances of Layer to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoLayer *BackRepoLayerStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, layer := range backRepoLayer.Map_LayerDBID_LayerPtr {
		backRepoLayer.CommitPhaseTwoInstance(backRepo, idx, layer)
	}

	return
}

// BackRepoLayer.CommitPhaseTwoInstance commits {{structname }} of models.Layer to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoLayer *BackRepoLayerStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, layer *models.Layer) (Error error) {

	// fetch matching layerDB
	if layerDB, ok := backRepoLayer.Map_LayerDBID_LayerDB[idx]; ok {

		layerDB.CopyBasicFieldsFromLayer(layer)

		// insertion point for translating pointers encodings into actual pointers
		// This loop encodes the slice of pointers layer.Rects into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, rectAssocEnd := range layer.Rects {

			// get the back repo instance at the association end
			rectAssocEnd_DB :=
				backRepo.BackRepoRect.GetRectDBFromRectPtr(rectAssocEnd)

			// encode reverse pointer in the association end back repo instance
			rectAssocEnd_DB.Layer_RectsDBID.Int64 = int64(layerDB.ID)
			rectAssocEnd_DB.Layer_RectsDBID.Valid = true
			rectAssocEnd_DB.Layer_RectsDBID_Index.Int64 = int64(idx)
			rectAssocEnd_DB.Layer_RectsDBID_Index.Valid = true
			if q := backRepoLayer.db.Save(rectAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		// This loop encodes the slice of pointers layer.Texts into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, textAssocEnd := range layer.Texts {

			// get the back repo instance at the association end
			textAssocEnd_DB :=
				backRepo.BackRepoText.GetTextDBFromTextPtr(textAssocEnd)

			// encode reverse pointer in the association end back repo instance
			textAssocEnd_DB.Layer_TextsDBID.Int64 = int64(layerDB.ID)
			textAssocEnd_DB.Layer_TextsDBID.Valid = true
			textAssocEnd_DB.Layer_TextsDBID_Index.Int64 = int64(idx)
			textAssocEnd_DB.Layer_TextsDBID_Index.Valid = true
			if q := backRepoLayer.db.Save(textAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		// This loop encodes the slice of pointers layer.Circles into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, circleAssocEnd := range layer.Circles {

			// get the back repo instance at the association end
			circleAssocEnd_DB :=
				backRepo.BackRepoCircle.GetCircleDBFromCirclePtr(circleAssocEnd)

			// encode reverse pointer in the association end back repo instance
			circleAssocEnd_DB.Layer_CirclesDBID.Int64 = int64(layerDB.ID)
			circleAssocEnd_DB.Layer_CirclesDBID.Valid = true
			circleAssocEnd_DB.Layer_CirclesDBID_Index.Int64 = int64(idx)
			circleAssocEnd_DB.Layer_CirclesDBID_Index.Valid = true
			if q := backRepoLayer.db.Save(circleAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		// This loop encodes the slice of pointers layer.Lines into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, lineAssocEnd := range layer.Lines {

			// get the back repo instance at the association end
			lineAssocEnd_DB :=
				backRepo.BackRepoLine.GetLineDBFromLinePtr(lineAssocEnd)

			// encode reverse pointer in the association end back repo instance
			lineAssocEnd_DB.Layer_LinesDBID.Int64 = int64(layerDB.ID)
			lineAssocEnd_DB.Layer_LinesDBID.Valid = true
			lineAssocEnd_DB.Layer_LinesDBID_Index.Int64 = int64(idx)
			lineAssocEnd_DB.Layer_LinesDBID_Index.Valid = true
			if q := backRepoLayer.db.Save(lineAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		// This loop encodes the slice of pointers layer.Ellipses into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, ellipseAssocEnd := range layer.Ellipses {

			// get the back repo instance at the association end
			ellipseAssocEnd_DB :=
				backRepo.BackRepoEllipse.GetEllipseDBFromEllipsePtr(ellipseAssocEnd)

			// encode reverse pointer in the association end back repo instance
			ellipseAssocEnd_DB.Layer_EllipsesDBID.Int64 = int64(layerDB.ID)
			ellipseAssocEnd_DB.Layer_EllipsesDBID.Valid = true
			ellipseAssocEnd_DB.Layer_EllipsesDBID_Index.Int64 = int64(idx)
			ellipseAssocEnd_DB.Layer_EllipsesDBID_Index.Valid = true
			if q := backRepoLayer.db.Save(ellipseAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		// This loop encodes the slice of pointers layer.Polylines into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, polylineAssocEnd := range layer.Polylines {

			// get the back repo instance at the association end
			polylineAssocEnd_DB :=
				backRepo.BackRepoPolyline.GetPolylineDBFromPolylinePtr(polylineAssocEnd)

			// encode reverse pointer in the association end back repo instance
			polylineAssocEnd_DB.Layer_PolylinesDBID.Int64 = int64(layerDB.ID)
			polylineAssocEnd_DB.Layer_PolylinesDBID.Valid = true
			polylineAssocEnd_DB.Layer_PolylinesDBID_Index.Int64 = int64(idx)
			polylineAssocEnd_DB.Layer_PolylinesDBID_Index.Valid = true
			if q := backRepoLayer.db.Save(polylineAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		// This loop encodes the slice of pointers layer.Polygones into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, polygoneAssocEnd := range layer.Polygones {

			// get the back repo instance at the association end
			polygoneAssocEnd_DB :=
				backRepo.BackRepoPolygone.GetPolygoneDBFromPolygonePtr(polygoneAssocEnd)

			// encode reverse pointer in the association end back repo instance
			polygoneAssocEnd_DB.Layer_PolygonesDBID.Int64 = int64(layerDB.ID)
			polygoneAssocEnd_DB.Layer_PolygonesDBID.Valid = true
			polygoneAssocEnd_DB.Layer_PolygonesDBID_Index.Int64 = int64(idx)
			polygoneAssocEnd_DB.Layer_PolygonesDBID_Index.Valid = true
			if q := backRepoLayer.db.Save(polygoneAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		// This loop encodes the slice of pointers layer.Paths into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, pathAssocEnd := range layer.Paths {

			// get the back repo instance at the association end
			pathAssocEnd_DB :=
				backRepo.BackRepoPath.GetPathDBFromPathPtr(pathAssocEnd)

			// encode reverse pointer in the association end back repo instance
			pathAssocEnd_DB.Layer_PathsDBID.Int64 = int64(layerDB.ID)
			pathAssocEnd_DB.Layer_PathsDBID.Valid = true
			pathAssocEnd_DB.Layer_PathsDBID_Index.Int64 = int64(idx)
			pathAssocEnd_DB.Layer_PathsDBID_Index.Valid = true
			if q := backRepoLayer.db.Save(pathAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		// This loop encodes the slice of pointers layer.Links into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, linkAssocEnd := range layer.Links {

			// get the back repo instance at the association end
			linkAssocEnd_DB :=
				backRepo.BackRepoLink.GetLinkDBFromLinkPtr(linkAssocEnd)

			// encode reverse pointer in the association end back repo instance
			linkAssocEnd_DB.Layer_LinksDBID.Int64 = int64(layerDB.ID)
			linkAssocEnd_DB.Layer_LinksDBID.Valid = true
			linkAssocEnd_DB.Layer_LinksDBID_Index.Int64 = int64(idx)
			linkAssocEnd_DB.Layer_LinksDBID_Index.Valid = true
			if q := backRepoLayer.db.Save(linkAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		// This loop encodes the slice of pointers layer.RectLinkLinks into the back repo.
		// Each back repo instance at the end of the association encode the ID of the association start
		// into a dedicated field for coding the association. The back repo instance is then saved to the db
		for idx, rectlinklinkAssocEnd := range layer.RectLinkLinks {

			// get the back repo instance at the association end
			rectlinklinkAssocEnd_DB :=
				backRepo.BackRepoRectLinkLink.GetRectLinkLinkDBFromRectLinkLinkPtr(rectlinklinkAssocEnd)

			// encode reverse pointer in the association end back repo instance
			rectlinklinkAssocEnd_DB.Layer_RectLinkLinksDBID.Int64 = int64(layerDB.ID)
			rectlinklinkAssocEnd_DB.Layer_RectLinkLinksDBID.Valid = true
			rectlinklinkAssocEnd_DB.Layer_RectLinkLinksDBID_Index.Int64 = int64(idx)
			rectlinklinkAssocEnd_DB.Layer_RectLinkLinksDBID_Index.Valid = true
			if q := backRepoLayer.db.Save(rectlinklinkAssocEnd_DB); q.Error != nil {
				return q.Error
			}
		}

		query := backRepoLayer.db.Save(&layerDB)
		if query.Error != nil {
			return query.Error
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Layer intance %s", layer.Name))
		return err
	}

	return
}

// BackRepoLayer.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for phase two)
func (backRepoLayer *BackRepoLayerStruct) CheckoutPhaseOne() (Error error) {

	layerDBArray := make([]LayerDB, 0)
	query := backRepoLayer.db.Find(&layerDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	layerInstancesToBeRemovedFromTheStage := make(map[*models.Layer]any)
	for key, value := range backRepoLayer.stage.Layers {
		layerInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, layerDB := range layerDBArray {
		backRepoLayer.CheckoutPhaseOneInstance(&layerDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		layer, ok := backRepoLayer.Map_LayerDBID_LayerPtr[layerDB.ID]
		if ok {
			delete(layerInstancesToBeRemovedFromTheStage, layer)
		}
	}

	// remove from stage and back repo's 3 maps all layers that are not in the checkout
	for layer := range layerInstancesToBeRemovedFromTheStage {
		layer.Unstage(backRepoLayer.GetStage())

		// remove instance from the back repo 3 maps
		layerID := backRepoLayer.Map_LayerPtr_LayerDBID[layer]
		delete(backRepoLayer.Map_LayerPtr_LayerDBID, layer)
		delete(backRepoLayer.Map_LayerDBID_LayerDB, layerID)
		delete(backRepoLayer.Map_LayerDBID_LayerPtr, layerID)
	}

	return
}

// CheckoutPhaseOneInstance takes a layerDB that has been found in the DB, updates the backRepo and stages the
// models version of the layerDB
func (backRepoLayer *BackRepoLayerStruct) CheckoutPhaseOneInstance(layerDB *LayerDB) (Error error) {

	layer, ok := backRepoLayer.Map_LayerDBID_LayerPtr[layerDB.ID]
	if !ok {
		layer = new(models.Layer)

		backRepoLayer.Map_LayerDBID_LayerPtr[layerDB.ID] = layer
		backRepoLayer.Map_LayerPtr_LayerDBID[layer] = layerDB.ID

		// append model store with the new element
		layer.Name = layerDB.Name_Data.String
		layer.Stage(backRepoLayer.GetStage())
	}
	layerDB.CopyBasicFieldsToLayer(layer)

	// in some cases, the instance might have been unstaged. It is necessary to stage it again
	layer.Stage(backRepoLayer.GetStage())

	// preserve pointer to layerDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_LayerDBID_LayerDB)[layerDB hold variable pointers
	layerDB_Data := *layerDB
	preservedPtrToLayer := &layerDB_Data
	backRepoLayer.Map_LayerDBID_LayerDB[layerDB.ID] = preservedPtrToLayer

	return
}

// BackRepoLayer.CheckoutPhaseTwo Checkouts all staged instances of Layer to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoLayer *BackRepoLayerStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, layerDB := range backRepoLayer.Map_LayerDBID_LayerDB {
		backRepoLayer.CheckoutPhaseTwoInstance(backRepo, layerDB)
	}
	return
}

// BackRepoLayer.CheckoutPhaseTwoInstance Checkouts staged instances of Layer to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoLayer *BackRepoLayerStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, layerDB *LayerDB) (Error error) {

	layer := backRepoLayer.Map_LayerDBID_LayerPtr[layerDB.ID]
	_ = layer // sometimes, there is no code generated. This lines voids the "unused variable" compilation error

	// insertion point for checkout of pointer encoding
	// This loop redeem layer.Rects in the stage from the encode in the back repo
	// It parses all RectDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	layer.Rects = layer.Rects[:0]
	// 2. loop all instances in the type in the association end
	for _, rectDB_AssocEnd := range backRepo.BackRepoRect.Map_RectDBID_RectDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if rectDB_AssocEnd.Layer_RectsDBID.Int64 == int64(layerDB.ID) {
			// 4. fetch the associated instance in the stage
			rect_AssocEnd := backRepo.BackRepoRect.Map_RectDBID_RectPtr[rectDB_AssocEnd.ID]
			// 5. append it the association slice
			layer.Rects = append(layer.Rects, rect_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(layer.Rects, func(i, j int) bool {
		rectDB_i_ID := backRepo.BackRepoRect.Map_RectPtr_RectDBID[layer.Rects[i]]
		rectDB_j_ID := backRepo.BackRepoRect.Map_RectPtr_RectDBID[layer.Rects[j]]

		rectDB_i := backRepo.BackRepoRect.Map_RectDBID_RectDB[rectDB_i_ID]
		rectDB_j := backRepo.BackRepoRect.Map_RectDBID_RectDB[rectDB_j_ID]

		return rectDB_i.Layer_RectsDBID_Index.Int64 < rectDB_j.Layer_RectsDBID_Index.Int64
	})

	// This loop redeem layer.Texts in the stage from the encode in the back repo
	// It parses all TextDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	layer.Texts = layer.Texts[:0]
	// 2. loop all instances in the type in the association end
	for _, textDB_AssocEnd := range backRepo.BackRepoText.Map_TextDBID_TextDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if textDB_AssocEnd.Layer_TextsDBID.Int64 == int64(layerDB.ID) {
			// 4. fetch the associated instance in the stage
			text_AssocEnd := backRepo.BackRepoText.Map_TextDBID_TextPtr[textDB_AssocEnd.ID]
			// 5. append it the association slice
			layer.Texts = append(layer.Texts, text_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(layer.Texts, func(i, j int) bool {
		textDB_i_ID := backRepo.BackRepoText.Map_TextPtr_TextDBID[layer.Texts[i]]
		textDB_j_ID := backRepo.BackRepoText.Map_TextPtr_TextDBID[layer.Texts[j]]

		textDB_i := backRepo.BackRepoText.Map_TextDBID_TextDB[textDB_i_ID]
		textDB_j := backRepo.BackRepoText.Map_TextDBID_TextDB[textDB_j_ID]

		return textDB_i.Layer_TextsDBID_Index.Int64 < textDB_j.Layer_TextsDBID_Index.Int64
	})

	// This loop redeem layer.Circles in the stage from the encode in the back repo
	// It parses all CircleDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	layer.Circles = layer.Circles[:0]
	// 2. loop all instances in the type in the association end
	for _, circleDB_AssocEnd := range backRepo.BackRepoCircle.Map_CircleDBID_CircleDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if circleDB_AssocEnd.Layer_CirclesDBID.Int64 == int64(layerDB.ID) {
			// 4. fetch the associated instance in the stage
			circle_AssocEnd := backRepo.BackRepoCircle.Map_CircleDBID_CirclePtr[circleDB_AssocEnd.ID]
			// 5. append it the association slice
			layer.Circles = append(layer.Circles, circle_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(layer.Circles, func(i, j int) bool {
		circleDB_i_ID := backRepo.BackRepoCircle.Map_CirclePtr_CircleDBID[layer.Circles[i]]
		circleDB_j_ID := backRepo.BackRepoCircle.Map_CirclePtr_CircleDBID[layer.Circles[j]]

		circleDB_i := backRepo.BackRepoCircle.Map_CircleDBID_CircleDB[circleDB_i_ID]
		circleDB_j := backRepo.BackRepoCircle.Map_CircleDBID_CircleDB[circleDB_j_ID]

		return circleDB_i.Layer_CirclesDBID_Index.Int64 < circleDB_j.Layer_CirclesDBID_Index.Int64
	})

	// This loop redeem layer.Lines in the stage from the encode in the back repo
	// It parses all LineDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	layer.Lines = layer.Lines[:0]
	// 2. loop all instances in the type in the association end
	for _, lineDB_AssocEnd := range backRepo.BackRepoLine.Map_LineDBID_LineDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if lineDB_AssocEnd.Layer_LinesDBID.Int64 == int64(layerDB.ID) {
			// 4. fetch the associated instance in the stage
			line_AssocEnd := backRepo.BackRepoLine.Map_LineDBID_LinePtr[lineDB_AssocEnd.ID]
			// 5. append it the association slice
			layer.Lines = append(layer.Lines, line_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(layer.Lines, func(i, j int) bool {
		lineDB_i_ID := backRepo.BackRepoLine.Map_LinePtr_LineDBID[layer.Lines[i]]
		lineDB_j_ID := backRepo.BackRepoLine.Map_LinePtr_LineDBID[layer.Lines[j]]

		lineDB_i := backRepo.BackRepoLine.Map_LineDBID_LineDB[lineDB_i_ID]
		lineDB_j := backRepo.BackRepoLine.Map_LineDBID_LineDB[lineDB_j_ID]

		return lineDB_i.Layer_LinesDBID_Index.Int64 < lineDB_j.Layer_LinesDBID_Index.Int64
	})

	// This loop redeem layer.Ellipses in the stage from the encode in the back repo
	// It parses all EllipseDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	layer.Ellipses = layer.Ellipses[:0]
	// 2. loop all instances in the type in the association end
	for _, ellipseDB_AssocEnd := range backRepo.BackRepoEllipse.Map_EllipseDBID_EllipseDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if ellipseDB_AssocEnd.Layer_EllipsesDBID.Int64 == int64(layerDB.ID) {
			// 4. fetch the associated instance in the stage
			ellipse_AssocEnd := backRepo.BackRepoEllipse.Map_EllipseDBID_EllipsePtr[ellipseDB_AssocEnd.ID]
			// 5. append it the association slice
			layer.Ellipses = append(layer.Ellipses, ellipse_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(layer.Ellipses, func(i, j int) bool {
		ellipseDB_i_ID := backRepo.BackRepoEllipse.Map_EllipsePtr_EllipseDBID[layer.Ellipses[i]]
		ellipseDB_j_ID := backRepo.BackRepoEllipse.Map_EllipsePtr_EllipseDBID[layer.Ellipses[j]]

		ellipseDB_i := backRepo.BackRepoEllipse.Map_EllipseDBID_EllipseDB[ellipseDB_i_ID]
		ellipseDB_j := backRepo.BackRepoEllipse.Map_EllipseDBID_EllipseDB[ellipseDB_j_ID]

		return ellipseDB_i.Layer_EllipsesDBID_Index.Int64 < ellipseDB_j.Layer_EllipsesDBID_Index.Int64
	})

	// This loop redeem layer.Polylines in the stage from the encode in the back repo
	// It parses all PolylineDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	layer.Polylines = layer.Polylines[:0]
	// 2. loop all instances in the type in the association end
	for _, polylineDB_AssocEnd := range backRepo.BackRepoPolyline.Map_PolylineDBID_PolylineDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if polylineDB_AssocEnd.Layer_PolylinesDBID.Int64 == int64(layerDB.ID) {
			// 4. fetch the associated instance in the stage
			polyline_AssocEnd := backRepo.BackRepoPolyline.Map_PolylineDBID_PolylinePtr[polylineDB_AssocEnd.ID]
			// 5. append it the association slice
			layer.Polylines = append(layer.Polylines, polyline_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(layer.Polylines, func(i, j int) bool {
		polylineDB_i_ID := backRepo.BackRepoPolyline.Map_PolylinePtr_PolylineDBID[layer.Polylines[i]]
		polylineDB_j_ID := backRepo.BackRepoPolyline.Map_PolylinePtr_PolylineDBID[layer.Polylines[j]]

		polylineDB_i := backRepo.BackRepoPolyline.Map_PolylineDBID_PolylineDB[polylineDB_i_ID]
		polylineDB_j := backRepo.BackRepoPolyline.Map_PolylineDBID_PolylineDB[polylineDB_j_ID]

		return polylineDB_i.Layer_PolylinesDBID_Index.Int64 < polylineDB_j.Layer_PolylinesDBID_Index.Int64
	})

	// This loop redeem layer.Polygones in the stage from the encode in the back repo
	// It parses all PolygoneDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	layer.Polygones = layer.Polygones[:0]
	// 2. loop all instances in the type in the association end
	for _, polygoneDB_AssocEnd := range backRepo.BackRepoPolygone.Map_PolygoneDBID_PolygoneDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if polygoneDB_AssocEnd.Layer_PolygonesDBID.Int64 == int64(layerDB.ID) {
			// 4. fetch the associated instance in the stage
			polygone_AssocEnd := backRepo.BackRepoPolygone.Map_PolygoneDBID_PolygonePtr[polygoneDB_AssocEnd.ID]
			// 5. append it the association slice
			layer.Polygones = append(layer.Polygones, polygone_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(layer.Polygones, func(i, j int) bool {
		polygoneDB_i_ID := backRepo.BackRepoPolygone.Map_PolygonePtr_PolygoneDBID[layer.Polygones[i]]
		polygoneDB_j_ID := backRepo.BackRepoPolygone.Map_PolygonePtr_PolygoneDBID[layer.Polygones[j]]

		polygoneDB_i := backRepo.BackRepoPolygone.Map_PolygoneDBID_PolygoneDB[polygoneDB_i_ID]
		polygoneDB_j := backRepo.BackRepoPolygone.Map_PolygoneDBID_PolygoneDB[polygoneDB_j_ID]

		return polygoneDB_i.Layer_PolygonesDBID_Index.Int64 < polygoneDB_j.Layer_PolygonesDBID_Index.Int64
	})

	// This loop redeem layer.Paths in the stage from the encode in the back repo
	// It parses all PathDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	layer.Paths = layer.Paths[:0]
	// 2. loop all instances in the type in the association end
	for _, pathDB_AssocEnd := range backRepo.BackRepoPath.Map_PathDBID_PathDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if pathDB_AssocEnd.Layer_PathsDBID.Int64 == int64(layerDB.ID) {
			// 4. fetch the associated instance in the stage
			path_AssocEnd := backRepo.BackRepoPath.Map_PathDBID_PathPtr[pathDB_AssocEnd.ID]
			// 5. append it the association slice
			layer.Paths = append(layer.Paths, path_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(layer.Paths, func(i, j int) bool {
		pathDB_i_ID := backRepo.BackRepoPath.Map_PathPtr_PathDBID[layer.Paths[i]]
		pathDB_j_ID := backRepo.BackRepoPath.Map_PathPtr_PathDBID[layer.Paths[j]]

		pathDB_i := backRepo.BackRepoPath.Map_PathDBID_PathDB[pathDB_i_ID]
		pathDB_j := backRepo.BackRepoPath.Map_PathDBID_PathDB[pathDB_j_ID]

		return pathDB_i.Layer_PathsDBID_Index.Int64 < pathDB_j.Layer_PathsDBID_Index.Int64
	})

	// This loop redeem layer.Links in the stage from the encode in the back repo
	// It parses all LinkDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	layer.Links = layer.Links[:0]
	// 2. loop all instances in the type in the association end
	for _, linkDB_AssocEnd := range backRepo.BackRepoLink.Map_LinkDBID_LinkDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if linkDB_AssocEnd.Layer_LinksDBID.Int64 == int64(layerDB.ID) {
			// 4. fetch the associated instance in the stage
			link_AssocEnd := backRepo.BackRepoLink.Map_LinkDBID_LinkPtr[linkDB_AssocEnd.ID]
			// 5. append it the association slice
			layer.Links = append(layer.Links, link_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(layer.Links, func(i, j int) bool {
		linkDB_i_ID := backRepo.BackRepoLink.Map_LinkPtr_LinkDBID[layer.Links[i]]
		linkDB_j_ID := backRepo.BackRepoLink.Map_LinkPtr_LinkDBID[layer.Links[j]]

		linkDB_i := backRepo.BackRepoLink.Map_LinkDBID_LinkDB[linkDB_i_ID]
		linkDB_j := backRepo.BackRepoLink.Map_LinkDBID_LinkDB[linkDB_j_ID]

		return linkDB_i.Layer_LinksDBID_Index.Int64 < linkDB_j.Layer_LinksDBID_Index.Int64
	})

	// This loop redeem layer.RectLinkLinks in the stage from the encode in the back repo
	// It parses all RectLinkLinkDB in the back repo and if the reverse pointer encoding matches the back repo ID
	// it appends the stage instance
	// 1. reset the slice
	layer.RectLinkLinks = layer.RectLinkLinks[:0]
	// 2. loop all instances in the type in the association end
	for _, rectlinklinkDB_AssocEnd := range backRepo.BackRepoRectLinkLink.Map_RectLinkLinkDBID_RectLinkLinkDB {
		// 3. Does the ID encoding at the end and the ID at the start matches ?
		if rectlinklinkDB_AssocEnd.Layer_RectLinkLinksDBID.Int64 == int64(layerDB.ID) {
			// 4. fetch the associated instance in the stage
			rectlinklink_AssocEnd := backRepo.BackRepoRectLinkLink.Map_RectLinkLinkDBID_RectLinkLinkPtr[rectlinklinkDB_AssocEnd.ID]
			// 5. append it the association slice
			layer.RectLinkLinks = append(layer.RectLinkLinks, rectlinklink_AssocEnd)
		}
	}

	// sort the array according to the order
	sort.Slice(layer.RectLinkLinks, func(i, j int) bool {
		rectlinklinkDB_i_ID := backRepo.BackRepoRectLinkLink.Map_RectLinkLinkPtr_RectLinkLinkDBID[layer.RectLinkLinks[i]]
		rectlinklinkDB_j_ID := backRepo.BackRepoRectLinkLink.Map_RectLinkLinkPtr_RectLinkLinkDBID[layer.RectLinkLinks[j]]

		rectlinklinkDB_i := backRepo.BackRepoRectLinkLink.Map_RectLinkLinkDBID_RectLinkLinkDB[rectlinklinkDB_i_ID]
		rectlinklinkDB_j := backRepo.BackRepoRectLinkLink.Map_RectLinkLinkDBID_RectLinkLinkDB[rectlinklinkDB_j_ID]

		return rectlinklinkDB_i.Layer_RectLinkLinksDBID_Index.Int64 < rectlinklinkDB_j.Layer_RectLinkLinksDBID_Index.Int64
	})

	return
}

// CommitLayer allows commit of a single layer (if already staged)
func (backRepo *BackRepoStruct) CommitLayer(layer *models.Layer) {
	backRepo.BackRepoLayer.CommitPhaseOneInstance(layer)
	if id, ok := backRepo.BackRepoLayer.Map_LayerPtr_LayerDBID[layer]; ok {
		backRepo.BackRepoLayer.CommitPhaseTwoInstance(backRepo, id, layer)
	}
	backRepo.CommitFromBackNb = backRepo.CommitFromBackNb + 1
}

// CommitLayer allows checkout of a single layer (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutLayer(layer *models.Layer) {
	// check if the layer is staged
	if _, ok := backRepo.BackRepoLayer.Map_LayerPtr_LayerDBID[layer]; ok {

		if id, ok := backRepo.BackRepoLayer.Map_LayerPtr_LayerDBID[layer]; ok {
			var layerDB LayerDB
			layerDB.ID = id

			if err := backRepo.BackRepoLayer.db.First(&layerDB, id).Error; err != nil {
				log.Panicln("CheckoutLayer : Problem with getting object with id:", id)
			}
			backRepo.BackRepoLayer.CheckoutPhaseOneInstance(&layerDB)
			backRepo.BackRepoLayer.CheckoutPhaseTwoInstance(backRepo, &layerDB)
		}
	}
}

// CopyBasicFieldsFromLayer
func (layerDB *LayerDB) CopyBasicFieldsFromLayer(layer *models.Layer) {
	// insertion point for fields commit

	layerDB.Display_Data.Bool = layer.Display
	layerDB.Display_Data.Valid = true

	layerDB.Name_Data.String = layer.Name
	layerDB.Name_Data.Valid = true
}

// CopyBasicFieldsFromLayerWOP
func (layerDB *LayerDB) CopyBasicFieldsFromLayerWOP(layer *LayerWOP) {
	// insertion point for fields commit

	layerDB.Display_Data.Bool = layer.Display
	layerDB.Display_Data.Valid = true

	layerDB.Name_Data.String = layer.Name
	layerDB.Name_Data.Valid = true
}

// CopyBasicFieldsToLayer
func (layerDB *LayerDB) CopyBasicFieldsToLayer(layer *models.Layer) {
	// insertion point for checkout of basic fields (back repo to stage)
	layer.Display = layerDB.Display_Data.Bool
	layer.Name = layerDB.Name_Data.String
}

// CopyBasicFieldsToLayerWOP
func (layerDB *LayerDB) CopyBasicFieldsToLayerWOP(layer *LayerWOP) {
	layer.ID = int(layerDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	layer.Display = layerDB.Display_Data.Bool
	layer.Name = layerDB.Name_Data.String
}

// Backup generates a json file from a slice of all LayerDB instances in the backrepo
func (backRepoLayer *BackRepoLayerStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "LayerDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*LayerDB, 0)
	for _, layerDB := range backRepoLayer.Map_LayerDBID_LayerDB {
		forBackup = append(forBackup, layerDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Panic("Cannot json Layer ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Panic("Cannot write the json Layer file", err.Error())
	}
}

// Backup generates a json file from a slice of all LayerDB instances in the backrepo
func (backRepoLayer *BackRepoLayerStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*LayerDB, 0)
	for _, layerDB := range backRepoLayer.Map_LayerDBID_LayerDB {
		forBackup = append(forBackup, layerDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("Layer")
	if err != nil {
		log.Panic("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&Layer_Fields, -1)
	for _, layerDB := range forBackup {

		var layerWOP LayerWOP
		layerDB.CopyBasicFieldsToLayerWOP(&layerWOP)

		row := sh.AddRow()
		row.WriteStruct(&layerWOP, -1)
	}
}

// RestoreXL from the "Layer" sheet all LayerDB instances
func (backRepoLayer *BackRepoLayerStruct) RestoreXLPhaseOne(file *xlsx.File) {

	// resets the map
	BackRepoLayerid_atBckpTime_newID = make(map[uint]uint)

	sh, ok := file.Sheet["Layer"]
	_ = sh
	if !ok {
		log.Panic(errors.New("sheet not found"))
	}

	// log.Println("Max row is", sh.MaxRow)
	err := sh.ForEachRow(backRepoLayer.rowVisitorLayer)
	if err != nil {
		log.Panic("Err=", err)
	}
}

func (backRepoLayer *BackRepoLayerStruct) rowVisitorLayer(row *xlsx.Row) error {

	log.Printf("row line %d\n", row.GetCoordinate())
	log.Println(row)

	// skip first line
	if row.GetCoordinate() > 0 {
		var layerWOP LayerWOP
		row.ReadStruct(&layerWOP)

		// add the unmarshalled struct to the stage
		layerDB := new(LayerDB)
		layerDB.CopyBasicFieldsFromLayerWOP(&layerWOP)

		layerDB_ID_atBackupTime := layerDB.ID
		layerDB.ID = 0
		query := backRepoLayer.db.Create(layerDB)
		if query.Error != nil {
			log.Panic(query.Error)
		}
		backRepoLayer.Map_LayerDBID_LayerDB[layerDB.ID] = layerDB
		BackRepoLayerid_atBckpTime_newID[layerDB_ID_atBackupTime] = layerDB.ID
	}
	return nil
}

// RestorePhaseOne read the file "LayerDB.json" in dirPath that stores an array
// of LayerDB and stores it in the database
// the map BackRepoLayerid_atBckpTime_newID is updated accordingly
func (backRepoLayer *BackRepoLayerStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoLayerid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "LayerDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Panic("Cannot restore/open the json Layer file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*LayerDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_LayerDBID_LayerDB
	for _, layerDB := range forRestore {

		layerDB_ID_atBackupTime := layerDB.ID
		layerDB.ID = 0
		query := backRepoLayer.db.Create(layerDB)
		if query.Error != nil {
			log.Panic(query.Error)
		}
		backRepoLayer.Map_LayerDBID_LayerDB[layerDB.ID] = layerDB
		BackRepoLayerid_atBckpTime_newID[layerDB_ID_atBackupTime] = layerDB.ID
	}

	if err != nil {
		log.Panic("Cannot restore/unmarshall json Layer file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<Layer>id_atBckpTime_newID
// to compute new index
func (backRepoLayer *BackRepoLayerStruct) RestorePhaseTwo() {

	for _, layerDB := range backRepoLayer.Map_LayerDBID_LayerDB {

		// next line of code is to avert unused variable compilation error
		_ = layerDB

		// insertion point for reindexing pointers encoding
		// This reindex layer.Layers
		if layerDB.SVG_LayersDBID.Int64 != 0 {
			layerDB.SVG_LayersDBID.Int64 =
				int64(BackRepoSVGid_atBckpTime_newID[uint(layerDB.SVG_LayersDBID.Int64)])
		}

		// update databse with new index encoding
		query := backRepoLayer.db.Model(layerDB).Updates(*layerDB)
		if query.Error != nil {
			log.Panic(query.Error)
		}
	}

}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoLayerid_atBckpTime_newID map[uint]uint
