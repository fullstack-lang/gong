// generated by gong
import { Component, OnInit, AfterViewInit, ViewChild, Inject, Optional, Input } from '@angular/core';
import { BehaviorSubject } from 'rxjs'
import { MatSort } from '@angular/material/sort';
import { MatPaginator } from '@angular/material/paginator';
import { MatTableDataSource } from '@angular/material/table';
import { MatButton } from '@angular/material/button'

import { MatDialogRef, MAT_DIALOG_DATA, MatDialog } from '@angular/material/dialog'
import { DialogData, FrontRepoService, FrontRepo, SelectionMode } from '../front-repo.service'
import { NullInt64 } from '../null-int64'
import { SelectionModel } from '@angular/cdk/collections';

const allowMultiSelect = true;

import { ActivatedRoute, Router, RouterState } from '@angular/router';
import { RectDB } from '../rect-db'
import { RectService } from '../rect.service'

// insertion point for additional imports

import { RouteService } from '../route-service';

// TableComponent is initilizaed from different routes
// TableComponentMode detail different cases 
enum TableComponentMode {
  DISPLAY_MODE,
  ONE_MANY_ASSOCIATION_MODE,
  MANY_MANY_ASSOCIATION_MODE,
}

// generated table component
@Component({
  selector: 'app-rectstable',
  templateUrl: './rects-table.component.html',
  styleUrls: ['./rects-table.component.css'],
})
export class RectsTableComponent implements OnInit {

  @Input() GONG__StackPath: string = ""

  // mode at invocation
  mode: TableComponentMode = TableComponentMode.DISPLAY_MODE

  // used if the component is called as a selection component of Rect instances
  selection: SelectionModel<RectDB> = new (SelectionModel)
  initialSelection = new Array<RectDB>()

  // the data source for the table
  rects: RectDB[] = []
  matTableDataSource: MatTableDataSource<RectDB> = new (MatTableDataSource)

  // front repo, that will be referenced by this.rects
  frontRepo: FrontRepo = new (FrontRepo)

  // displayedColumns is referenced by the MatTable component for specify what columns
  // have to be displayed and in what order
  displayedColumns: string[];

  // for sorting & pagination
  @ViewChild(MatSort)
  sort: MatSort | undefined
  @ViewChild(MatPaginator)
  paginator: MatPaginator | undefined;

  ngAfterViewInit() {

    // enable sorting on all fields (including pointers and reverse pointer)
    this.matTableDataSource.sortingDataAccessor = (rectDB: RectDB, property: string) => {
      switch (property) {
        case 'ID':
          return rectDB.ID

        // insertion point for specific sorting accessor
        case 'Name':
          return rectDB.Name;

        case 'X':
          return rectDB.X;

        case 'Y':
          return rectDB.Y;

        case 'Width':
          return rectDB.Width;

        case 'Height':
          return rectDB.Height;

        case 'RX':
          return rectDB.RX;

        case 'Color':
          return rectDB.Color;

        case 'FillOpacity':
          return rectDB.FillOpacity;

        case 'Stroke':
          return rectDB.Stroke;

        case 'StrokeWidth':
          return rectDB.StrokeWidth;

        case 'StrokeDashArray':
          return rectDB.StrokeDashArray;

        case 'StrokeDashArrayWhenSelected':
          return rectDB.StrokeDashArrayWhenSelected;

        case 'Transform':
          return rectDB.Transform;

        case 'IsSelectable':
          return rectDB.IsSelectable ? "true" : "false";

        case 'IsSelected':
          return rectDB.IsSelected ? "true" : "false";

        case 'CanHaveLeftHandle':
          return rectDB.CanHaveLeftHandle ? "true" : "false";

        case 'HasLeftHandle':
          return rectDB.HasLeftHandle ? "true" : "false";

        case 'CanHaveRightHandle':
          return rectDB.CanHaveRightHandle ? "true" : "false";

        case 'HasRightHandle':
          return rectDB.HasRightHandle ? "true" : "false";

        case 'CanHaveTopHandle':
          return rectDB.CanHaveTopHandle ? "true" : "false";

        case 'HasTopHandle':
          return rectDB.HasTopHandle ? "true" : "false";

        case 'CanHaveBottomHandle':
          return rectDB.CanHaveBottomHandle ? "true" : "false";

        case 'HasBottomHandle':
          return rectDB.HasBottomHandle ? "true" : "false";

        case 'CanMoveHorizontaly':
          return rectDB.CanMoveHorizontaly ? "true" : "false";

        case 'CanMoveVerticaly':
          return rectDB.CanMoveVerticaly ? "true" : "false";

        case 'Layer_Rects':
          if (this.frontRepo.Layers.get(rectDB.Layer_RectsDBID.Int64) != undefined) {
            return this.frontRepo.Layers.get(rectDB.Layer_RectsDBID.Int64)!.Name
          } else {
            return ""
          }

        default:
          console.assert(false, "Unknown field")
          return "";
      }
    };

    // enable filtering on all fields (including pointers and reverse pointer, which is not done by default)
    this.matTableDataSource.filterPredicate = (rectDB: RectDB, filter: string) => {

      // filtering is based on finding a lower case filter into a concatenated string
      // the rectDB properties
      let mergedContent = ""

      // insertion point for merging of fields
      mergedContent += rectDB.Name.toLowerCase()
      mergedContent += rectDB.X.toString()
      mergedContent += rectDB.Y.toString()
      mergedContent += rectDB.Width.toString()
      mergedContent += rectDB.Height.toString()
      mergedContent += rectDB.RX.toString()
      mergedContent += rectDB.Color.toLowerCase()
      mergedContent += rectDB.FillOpacity.toString()
      mergedContent += rectDB.Stroke.toLowerCase()
      mergedContent += rectDB.StrokeWidth.toString()
      mergedContent += rectDB.StrokeDashArray.toLowerCase()
      mergedContent += rectDB.StrokeDashArrayWhenSelected.toLowerCase()
      mergedContent += rectDB.Transform.toLowerCase()
      if (rectDB.Layer_RectsDBID.Int64 != 0) {
        mergedContent += this.frontRepo.Layers.get(rectDB.Layer_RectsDBID.Int64)!.Name.toLowerCase()
      }


      let isSelected = mergedContent.includes(filter.toLowerCase())
      return isSelected
    };

    this.matTableDataSource.sort = this.sort!
    this.matTableDataSource.paginator = this.paginator!
  }

  applyFilter(event: Event) {
    const filterValue = (event.target as HTMLInputElement).value;
    this.matTableDataSource.filter = filterValue.trim().toLowerCase();
  }

  constructor(
    private rectService: RectService,
    private frontRepoService: FrontRepoService,

    // not null if the component is called as a selection component of rect instances
    public dialogRef: MatDialogRef<RectsTableComponent>,
    @Optional() @Inject(MAT_DIALOG_DATA) public dialogData: DialogData,

    private router: Router,
    private activatedRoute: ActivatedRoute,

    private routeService: RouteService,
  ) {

    // compute mode
    if (dialogData == undefined) {
      this.mode = TableComponentMode.DISPLAY_MODE
    } else {
      this.GONG__StackPath = dialogData.GONG__StackPath
      switch (dialogData.SelectionMode) {
        case SelectionMode.ONE_MANY_ASSOCIATION_MODE:
          this.mode = TableComponentMode.ONE_MANY_ASSOCIATION_MODE
          break
        case SelectionMode.MANY_MANY_ASSOCIATION_MODE:
          this.mode = TableComponentMode.MANY_MANY_ASSOCIATION_MODE
          break
        default:
      }
    }

    // observable for changes in structs
    this.rectService.RectServiceChanged.subscribe(
      message => {
        if (message == "post" || message == "update" || message == "delete") {
          this.getRects()
        }
      }
    )
    if (this.mode == TableComponentMode.DISPLAY_MODE) {
      this.displayedColumns = ['ID', 'Delete', // insertion point for columns to display
        "Name",
        "X",
        "Y",
        "Width",
        "Height",
        "RX",
        "Color",
        "FillOpacity",
        "Stroke",
        "StrokeWidth",
        "StrokeDashArray",
        "StrokeDashArrayWhenSelected",
        "Transform",
        "IsSelectable",
        "IsSelected",
        "CanHaveLeftHandle",
        "HasLeftHandle",
        "CanHaveRightHandle",
        "HasRightHandle",
        "CanHaveTopHandle",
        "HasTopHandle",
        "CanHaveBottomHandle",
        "HasBottomHandle",
        "CanMoveHorizontaly",
        "CanMoveVerticaly",
        "Layer_Rects",
      ]
    } else {
      this.displayedColumns = ['select', 'ID', // insertion point for columns to display
        "Name",
        "X",
        "Y",
        "Width",
        "Height",
        "RX",
        "Color",
        "FillOpacity",
        "Stroke",
        "StrokeWidth",
        "StrokeDashArray",
        "StrokeDashArrayWhenSelected",
        "Transform",
        "IsSelectable",
        "IsSelected",
        "CanHaveLeftHandle",
        "HasLeftHandle",
        "CanHaveRightHandle",
        "HasRightHandle",
        "CanHaveTopHandle",
        "HasTopHandle",
        "CanHaveBottomHandle",
        "HasBottomHandle",
        "CanMoveHorizontaly",
        "CanMoveVerticaly",
        "Layer_Rects",
      ]
      this.selection = new SelectionModel<RectDB>(allowMultiSelect, this.initialSelection);
    }

  }

  ngOnInit(): void {
    let stackPath = this.activatedRoute.snapshot.paramMap.get('GONG__StackPath')
    if (stackPath != undefined) {
      this.GONG__StackPath = stackPath
    }

    this.getRects()

    this.matTableDataSource = new MatTableDataSource(this.rects)
  }

  getRects(): void {
    this.frontRepoService.pull(this.GONG__StackPath).subscribe(
      frontRepo => {
        this.frontRepo = frontRepo

        this.rects = this.frontRepo.Rects_array;

        // insertion point for time duration Recoveries
        // insertion point for enum int Recoveries

        // in case the component is called as a selection component
        if (this.mode == TableComponentMode.ONE_MANY_ASSOCIATION_MODE) {
          for (let rect of this.rects) {
            let ID = this.dialogData.ID
            let revPointer = rect[this.dialogData.ReversePointer as keyof RectDB] as unknown as NullInt64
            if (revPointer.Int64 == ID) {
              this.initialSelection.push(rect)
            }
            this.selection = new SelectionModel<RectDB>(allowMultiSelect, this.initialSelection);
          }
        }

        if (this.mode == TableComponentMode.MANY_MANY_ASSOCIATION_MODE) {

          let mapOfSourceInstances = this.frontRepo[this.dialogData.SourceStruct + "s" as keyof FrontRepo] as Map<number, RectDB>
          let sourceInstance = mapOfSourceInstances.get(this.dialogData.ID)!

          // we associates on sourceInstance of type SourceStruct with a MANY MANY associations to RectDB
          // the field name is sourceField
          let sourceFieldArray = sourceInstance[this.dialogData.SourceField as keyof typeof sourceInstance]! as unknown as RectDB[]
          if (sourceFieldArray != null) {
            for (let associationInstance of sourceFieldArray) {
              let rect = associationInstance[this.dialogData.IntermediateStructField as keyof typeof associationInstance] as unknown as RectDB
              this.initialSelection.push(rect)
            }
          }

          this.selection = new SelectionModel<RectDB>(allowMultiSelect, this.initialSelection);
        }

        // update the mat table data source
        this.matTableDataSource.data = this.rects
      }
    )
  }

  // newRect initiate a new rect
  // create a new Rect objet
  newRect() {
  }

  deleteRect(rectID: number, rect: RectDB) {
    // list of rects is truncated of rect before the delete
    this.rects = this.rects.filter(h => h !== rect);

    this.rectService.deleteRect(rectID, this.GONG__StackPath).subscribe(
      rect => {
        this.rectService.RectServiceChanged.next("delete")
      }
    );
  }

  editRect(rectID: number, rect: RectDB) {

  }

  // set editor outlet
  setEditorRouterOutlet(rectID: number) {
    let outletName = this.routeService.getEditorOutlet(this.GONG__StackPath)
    let fullPath = this.routeService.getPathRoot() + "-" + "rect" + "-detail"

    let outletConf: any = {}
    outletConf[outletName] = [fullPath, rectID, this.GONG__StackPath]

    this.router.navigate([{ outlets: outletConf }])
  }

  /** Whether the number of selected elements matches the total number of rows. */
  isAllSelected() {
    const numSelected = this.selection.selected.length;
    const numRows = this.rects.length;
    return numSelected === numRows;
  }

  /** Selects all rows if they are not all selected; otherwise clear selection. */
  masterToggle() {
    this.isAllSelected() ?
      this.selection.clear() :
      this.rects.forEach(row => this.selection.select(row));
  }

  save() {

    if (this.mode == TableComponentMode.ONE_MANY_ASSOCIATION_MODE) {

      let toUpdate = new Set<RectDB>()

      // reset all initial selection of rect that belong to rect
      for (let rect of this.initialSelection) {
        let index = rect[this.dialogData.ReversePointer as keyof RectDB] as unknown as NullInt64
        index.Int64 = 0
        index.Valid = true
        toUpdate.add(rect)

      }

      // from selection, set rect that belong to rect
      for (let rect of this.selection.selected) {
        let ID = this.dialogData.ID as number
        let reversePointer = rect[this.dialogData.ReversePointer as keyof RectDB] as unknown as NullInt64
        reversePointer.Int64 = ID
        reversePointer.Valid = true
        toUpdate.add(rect)
      }


      // update all rect (only update selection & initial selection)
      for (let rect of toUpdate) {
        this.rectService.updateRect(rect, this.GONG__StackPath)
          .subscribe(rect => {
            this.rectService.RectServiceChanged.next("update")
          });
      }
    }

    if (this.mode == TableComponentMode.MANY_MANY_ASSOCIATION_MODE) {

      // get the source instance via the map of instances in the front repo
      let mapOfSourceInstances = this.frontRepo[this.dialogData.SourceStruct + "s" as keyof FrontRepo] as Map<number, RectDB>
      let sourceInstance = mapOfSourceInstances.get(this.dialogData.ID)!

      // First, parse all instance of the association struct and remove the instance
      // that have unselect
      let unselectedRect = new Set<number>()
      for (let rect of this.initialSelection) {
        if (this.selection.selected.includes(rect)) {
          // console.log("rect " + rect.Name + " is still selected")
        } else {
          console.log("rect " + rect.Name + " has been unselected")
          unselectedRect.add(rect.ID)
          console.log("is unselected " + unselectedRect.has(rect.ID))
        }
      }

      // delete the association instance
      let associationInstance = sourceInstance[this.dialogData.SourceField as keyof typeof sourceInstance]
      let rect = associationInstance![this.dialogData.IntermediateStructField as keyof typeof associationInstance] as unknown as RectDB
      if (unselectedRect.has(rect.ID)) {
        this.frontRepoService.deleteService(this.dialogData.IntermediateStruct, associationInstance)


      }

      // is the source array is empty create it
      if (sourceInstance[this.dialogData.SourceField as keyof typeof sourceInstance] == undefined) {
        (sourceInstance[this.dialogData.SourceField as keyof typeof sourceInstance] as unknown as Array<RectDB>) = new Array<RectDB>()
      }

      // second, parse all instance of the selected
      if (sourceInstance[this.dialogData.SourceField as keyof typeof sourceInstance]) {
        this.selection.selected.forEach(
          rect => {
            if (!this.initialSelection.includes(rect)) {
              // console.log("rect " + rect.Name + " has been added to the selection")

              let associationInstance = {
                Name: sourceInstance["Name"] + "-" + rect.Name,
              }

              let index = associationInstance[this.dialogData.IntermediateStructField + "ID" as keyof typeof associationInstance] as unknown as NullInt64
              index.Int64 = rect.ID
              index.Valid = true

              let indexDB = associationInstance[this.dialogData.IntermediateStructField + "DBID" as keyof typeof associationInstance] as unknown as NullInt64
              indexDB.Int64 = rect.ID
              index.Valid = true

              this.frontRepoService.postService(this.dialogData.IntermediateStruct, associationInstance)

            } else {
              // console.log("rect " + rect.Name + " is still selected")
            }
          }
        )
      }

      // this.selection = new SelectionModel<RectDB>(allowMultiSelect, this.initialSelection);
    }

    // why pizza ?
    this.dialogRef.close('Pizza!');
  }
}
