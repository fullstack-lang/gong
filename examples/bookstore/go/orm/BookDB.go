// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"errors"
	"fmt"
	"log"

	"github.com/fullstack-lang/examples/bookstore/go/models"
	"github.com/jinzhu/gorm"
)

// dummy variable to have the import database/sql wihthout compile failure id no sql is used
var dummy_Book sql.NullBool

// BookAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model bookAPI
type BookAPI struct {
	models.Book

	// insertion for fields declaration
	// Declation for basic field bookDB.Name {{BasicKind}} (to be completed)
	Name_Data sql.NullString

	// Declation for basic field bookDB.Author {{BasicKind}} (to be completed)
	Author_Data sql.NullString

	// Declation for basic field bookDB.City {{BasicKind}} (to be completed)
	City_Data sql.NullString

	// Declation for basic field bookDB.Year {{BasicKind}} (to be completed)
	Year_Data sql.NullInt64

	// Declation for basic field bookDB.Price {{BasicKind}} (to be completed)
	Price_Data sql.NullFloat64

	// Declation for basic field bookDB.Recommanded bool (to be completed)
	// provide the sql storage for the boolan
	Recommanded_Data sql.NullBool

	// field Area is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	AreaID sql.NullInt64

	// all gong Struct has a Name field, this enables this data to object field
	AreaName string

	// Implementation of a reverse ID for field Editor{}.Books []*Book
	Editor_BooksDBID sql.NullInt64

	// end of insertion
}

// BookDB describes a book in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model bookDB
type BookDB struct {
	gorm.Model

	BookAPI
}

// BookDBs arrays bookDBs
// swagger:response bookDBsResponse
type BookDBs []BookDB

// BookDBResponse provides response
// swagger:response bookDBResponse
type BookDBResponse struct {
	BookDB
}

type BackRepoBookStruct struct {
	// stores BookDB according to their gorm ID
	Map_BookDBID_BookDB *map[uint]*BookDB

	// stores BookDB ID according to Book address
	Map_BookPtr_BookDBID *map[*models.Book]uint

	// stores Book according to their gorm ID
	Map_BookDBID_BookPtr *map[uint]*models.Book

	db *gorm.DB
}

// BackRepoBook.Init set up the BackRepo of the Book
func (backRepoBook *BackRepoBookStruct) Init(db *gorm.DB) (Error error) {

	if backRepoBook.Map_BookDBID_BookPtr != nil {
		err := errors.New("In Init, backRepoBook.Map_BookDBID_BookPtr should be nil")
		return err
	}

	if backRepoBook.Map_BookDBID_BookDB != nil {
		err := errors.New("In Init, backRepoBook.Map_BookDBID_BookDB should be nil")
		return err
	}

	if backRepoBook.Map_BookPtr_BookDBID != nil {
		err := errors.New("In Init, backRepoBook.Map_BookPtr_BookDBID should be nil")
		return err
	}

	tmp := make(map[uint]*models.Book, 0)
	backRepoBook.Map_BookDBID_BookPtr = &tmp

	tmpDB := make(map[uint]*BookDB, 0)
	backRepoBook.Map_BookDBID_BookDB = &tmpDB

	tmpID := make(map[*models.Book]uint, 0)
	backRepoBook.Map_BookPtr_BookDBID = &tmpID

	backRepoBook.db = db
	return
}

// BackRepoBook.CommitPhaseOne commits all staged instances of Book to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoBook *BackRepoBookStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for book := range stage.Books {
		backRepoBook.CommitPhaseOneInstance(book)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, book := range *backRepoBook.Map_BookDBID_BookPtr {
		if _, ok := stage.Books[book]; !ok {
			backRepoBook.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoBook.CommitDeleteInstance commits deletion of Book to the BackRepo
func (backRepoBook *BackRepoBookStruct) CommitDeleteInstance(id uint) (Error error) {

	book := (*backRepoBook.Map_BookDBID_BookPtr)[id]

	// book is not staged anymore, remove bookDB
	bookDB := (*backRepoBook.Map_BookDBID_BookDB)[id]
	query := backRepoBook.db.Unscoped().Delete(&bookDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	delete((*backRepoBook.Map_BookPtr_BookDBID), book)
	delete((*backRepoBook.Map_BookDBID_BookPtr), id)
	delete((*backRepoBook.Map_BookDBID_BookDB), id)

	return
}

// BackRepoBook.CommitPhaseOneInstance commits book staged instances of Book to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoBook *BackRepoBookStruct) CommitPhaseOneInstance(book *models.Book) (Error error) {

	// check if the book is not commited yet
	if _, ok := (*backRepoBook.Map_BookPtr_BookDBID)[book]; ok {
		return
	}

	// initiate book
	var bookDB BookDB
	bookDB.Book = *book

	query := backRepoBook.db.Create(&bookDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*backRepoBook.Map_BookPtr_BookDBID)[book] = bookDB.ID
	(*backRepoBook.Map_BookDBID_BookPtr)[bookDB.ID] = book
	(*backRepoBook.Map_BookDBID_BookDB)[bookDB.ID] = &bookDB

	return
}

// BackRepoBook.CommitPhaseTwo commits all staged instances of Book to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoBook *BackRepoBookStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, book := range *backRepoBook.Map_BookDBID_BookPtr {
		backRepoBook.CommitPhaseTwoInstance(backRepo, idx, book)
	}

	return
}

// BackRepoBook.CommitPhaseTwoInstance commits {{structname }} of models.Book to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoBook *BackRepoBookStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, book *models.Book) (Error error) {

	// fetch matching bookDB
	if bookDB, ok := (*backRepoBook.Map_BookDBID_BookDB)[idx]; ok {

		{
			{
				// insertion point for fields commit
				bookDB.Name_Data.String = book.Name
				bookDB.Name_Data.Valid = true

				bookDB.Author_Data.String = book.Author
				bookDB.Author_Data.Valid = true

				bookDB.City_Data.String = book.City
				bookDB.City_Data.Valid = true

				bookDB.Year_Data.Int64 = int64(book.Year)
				bookDB.Year_Data.Valid = true

				bookDB.Price_Data.Float64 = book.Price
				bookDB.Price_Data.Valid = true

				bookDB.Recommanded_Data.Bool = book.Recommanded
				bookDB.Recommanded_Data.Valid = true

				// commit pointer value book.Area translates to updating the book.AreaID
				bookDB.AreaID.Valid = true // allow for a 0 value (nil association)
				if book.Area != nil {
					if AreaId, ok := (*backRepo.BackRepoArea.Map_AreaPtr_AreaDBID)[book.Area]; ok {
						bookDB.AreaID.Int64 = int64(AreaId)
					}
				}

			}
		}
		query := backRepoBook.db.Save(&bookDB)
		if query.Error != nil {
			return query.Error
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown Book intance %s", book.Name))
		return err
	}

	return
}

// BackRepoBook.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One is the creation of instance in the stage
//
// NOTE: the is supposed to have been reset before
//
func (backRepoBook *BackRepoBookStruct) CheckoutPhaseOne() (Error error) {

	bookDBArray := make([]BookDB, 0)
	query := backRepoBook.db.Find(&bookDBArray)
	if query.Error != nil {
		return query.Error
	}

	// copy orm objects to the the map
	for _, bookDB := range bookDBArray {
		backRepoBook.CheckoutPhaseOneInstance(&bookDB)
	}

	return
}

// CheckoutPhaseOneInstance takes a bookDB that has been found in the DB, updates the backRepo and stages the
// models version of the bookDB
func (backRepoBook *BackRepoBookStruct) CheckoutPhaseOneInstance(bookDB *BookDB) (Error error) {

	// if absent, create entries in the backRepoBook maps.
	bookWithNewFieldValues := bookDB.Book
	if _, ok := (*backRepoBook.Map_BookDBID_BookPtr)[bookDB.ID]; !ok {

		(*backRepoBook.Map_BookDBID_BookPtr)[bookDB.ID] = &bookWithNewFieldValues
		(*backRepoBook.Map_BookPtr_BookDBID)[&bookWithNewFieldValues] = bookDB.ID

		// append model store with the new element
		bookWithNewFieldValues.Stage()
	}
	bookDBWithNewFieldValues := *bookDB
	(*backRepoBook.Map_BookDBID_BookDB)[bookDB.ID] = &bookDBWithNewFieldValues

	return
}

// BackRepoBook.CheckoutPhaseTwo Checkouts all staged instances of Book to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoBook *BackRepoBookStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, bookDB := range *backRepoBook.Map_BookDBID_BookDB {
		backRepoBook.CheckoutPhaseTwoInstance(backRepo, bookDB)
	}
	return
}

// BackRepoBook.CheckoutPhaseTwoInstance Checkouts staged instances of Book to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoBook *BackRepoBookStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, bookDB *BookDB) (Error error) {

	book := (*backRepoBook.Map_BookDBID_BookPtr)[bookDB.ID]
	_ = book // sometimes, there is no code generated. This lines voids the "unused variable" compilation error
	{
		{
			// insertion point for checkout, i.e. update of fields of stage instance from fields of back repo instances
			//
			book.Name = bookDB.Name_Data.String

			book.Author = bookDB.Author_Data.String

			book.City = bookDB.City_Data.String

			book.Year = int(bookDB.Year_Data.Int64)

			book.Price = bookDB.Price_Data.Float64

			book.Recommanded = bookDB.Recommanded_Data.Bool
			// Area field
			if bookDB.AreaID.Int64 != 0 {
				book.Area = (*backRepo.BackRepoArea.Map_AreaDBID_AreaPtr)[uint(bookDB.AreaID.Int64)]
			}

		}
	}
	return
}

// CommitBook allows commit of a single book (if already staged)
func (backRepo *BackRepoStruct) CommitBook(book *models.Book) {
	backRepo.BackRepoBook.CommitPhaseOneInstance(book)
	if id, ok := (*backRepo.BackRepoBook.Map_BookPtr_BookDBID)[book]; ok {
		backRepo.BackRepoBook.CommitPhaseTwoInstance(backRepo, id, book)
	}
}

// CommitBook allows checkout of a single book (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutBook(book *models.Book) {
	// check if the book is staged
	if _, ok := (*backRepo.BackRepoBook.Map_BookPtr_BookDBID)[book]; ok {

		if id, ok := (*backRepo.BackRepoBook.Map_BookPtr_BookDBID)[book]; ok {
			var bookDB BookDB
			bookDB.ID = id

			if err := backRepo.BackRepoBook.db.First(&bookDB, id).Error; err != nil {
				log.Panicln("CheckoutBook : Problem with getting object with id:", id)
			}
			backRepo.BackRepoBook.CheckoutPhaseOneInstance(&bookDB)
			backRepo.BackRepoBook.CheckoutPhaseTwoInstance(backRepo, &bookDB)
		}
	}
}
