// generated by ModelGongFileTemplate
package models

import "sort"

// swagger:ignore
type __void struct{}

// needed for creating set of instances in the stage
var __member __void

// StageStruct enables storage of staged instances
// swagger:ignore
type StageStruct struct { // insertion point for definition of arrays registering instances
	Areas map[*Area]struct{}

	Books map[*Book]struct{}

	Editors map[*Editor]struct{}

	AllModelsStructCreateCallback AllModelsStructCreateInterface

	AllModelsStructDeleteCallback AllModelsStructDeleteInterface

	BackRepo BackRepoInterface
}

type BackRepoInterface interface {
	Commit(stage *StageStruct)
	Checkout(stage *StageStruct)
	// insertion point for Commit and Checkout signatures
	CommitArea(area *Area)
	CheckoutArea(area *Area)
	CommitBook(book *Book)
	CheckoutBook(book *Book)
	CommitEditor(editor *Editor)
	CheckoutEditor(editor *Editor)
	GetLastCommitNb() uint
}

// swagger:ignore instructs the gong compiler (gongc) to avoid this particular struct
var Stage StageStruct = StageStruct{ // insertion point for array initiatialisation
	Areas: make(map[*Area]struct{}, 0),

	Books: make(map[*Book]struct{}, 0),

	Editors: make(map[*Editor]struct{}, 0),

}

func (stage *StageStruct) Commit() {
	if stage.BackRepo != nil {
		stage.BackRepo.Commit(stage)
	}
}

func (stage *StageStruct) Checkout() {
	if stage.BackRepo != nil {
		stage.BackRepo.Checkout(stage)
	}
}

// insertion point for cumulative sub template with model space calls
func (stage *StageStruct) getAreaOrderedStructWithNameField() []*Area {
	// have alphabetical order generation
	areaOrdered := []*Area{}
	for area := range stage.Areas {
		areaOrdered = append(areaOrdered, area)
	}
	sort.Slice(areaOrdered[:], func(i, j int) bool {
		return areaOrdered[i].Name < areaOrdered[j].Name
	})
	return areaOrdered
}

// Stage puts area to the model stage
func (area *Area) Stage() *Area {
	Stage.Areas[area] = __member
	return area
}

// Unstage removes area off the model stage
func (area *Area) Unstage() *Area {
	delete(Stage.Areas, area)
	return area
}

// commit area to the back repo (if it is already staged)
func (area *Area) Commit() *Area {
	if _, ok := Stage.Areas[area]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitArea(area)
		}
	}
	return area
}

// Checkout area to the back repo (if it is already staged)
func (area *Area) Checkout() *Area {
	if _, ok := Stage.Areas[area]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutArea(area)
		}
	}
	return area
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of area to the model stage
func (area *Area) StageCopy() *Area {
	_area := new(Area)
	*_area = *area
	_area.Stage()
	return _area
}

// StageAndCommit appends area to the model stage and commit to the orm repo
func (area *Area) StageAndCommit() *Area {
	area.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMArea(area)
	}
	return area
}

// DeleteStageAndCommit appends area to the model stage and commit to the orm repo
func (area *Area) DeleteStageAndCommit() *Area {
	area.Unstage()
	DeleteORMArea(area)
	return area
}

// StageCopyAndCommit appends a copy of area to the model stage and commit to the orm repo
func (area *Area) StageCopyAndCommit() *Area {
	_area := new(Area)
	*_area = *area
	_area.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMArea(area)
	}
	return _area
}

// CreateORMArea enables dynamic staging of a Area instance
func CreateORMArea(area *Area) {
	area.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMArea(area)
	}
}

// DeleteORMArea enables dynamic staging of a Area instance
func DeleteORMArea(area *Area) {
	area.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMArea(area)
	}
}

func (stage *StageStruct) getBookOrderedStructWithNameField() []*Book {
	// have alphabetical order generation
	bookOrdered := []*Book{}
	for book := range stage.Books {
		bookOrdered = append(bookOrdered, book)
	}
	sort.Slice(bookOrdered[:], func(i, j int) bool {
		return bookOrdered[i].Name < bookOrdered[j].Name
	})
	return bookOrdered
}

// Stage puts book to the model stage
func (book *Book) Stage() *Book {
	Stage.Books[book] = __member
	return book
}

// Unstage removes book off the model stage
func (book *Book) Unstage() *Book {
	delete(Stage.Books, book)
	return book
}

// commit book to the back repo (if it is already staged)
func (book *Book) Commit() *Book {
	if _, ok := Stage.Books[book]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitBook(book)
		}
	}
	return book
}

// Checkout book to the back repo (if it is already staged)
func (book *Book) Checkout() *Book {
	if _, ok := Stage.Books[book]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutBook(book)
		}
	}
	return book
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of book to the model stage
func (book *Book) StageCopy() *Book {
	_book := new(Book)
	*_book = *book
	_book.Stage()
	return _book
}

// StageAndCommit appends book to the model stage and commit to the orm repo
func (book *Book) StageAndCommit() *Book {
	book.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMBook(book)
	}
	return book
}

// DeleteStageAndCommit appends book to the model stage and commit to the orm repo
func (book *Book) DeleteStageAndCommit() *Book {
	book.Unstage()
	DeleteORMBook(book)
	return book
}

// StageCopyAndCommit appends a copy of book to the model stage and commit to the orm repo
func (book *Book) StageCopyAndCommit() *Book {
	_book := new(Book)
	*_book = *book
	_book.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMBook(book)
	}
	return _book
}

// CreateORMBook enables dynamic staging of a Book instance
func CreateORMBook(book *Book) {
	book.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMBook(book)
	}
}

// DeleteORMBook enables dynamic staging of a Book instance
func DeleteORMBook(book *Book) {
	book.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMBook(book)
	}
}

func (stage *StageStruct) getEditorOrderedStructWithNameField() []*Editor {
	// have alphabetical order generation
	editorOrdered := []*Editor{}
	for editor := range stage.Editors {
		editorOrdered = append(editorOrdered, editor)
	}
	sort.Slice(editorOrdered[:], func(i, j int) bool {
		return editorOrdered[i].Name < editorOrdered[j].Name
	})
	return editorOrdered
}

// Stage puts editor to the model stage
func (editor *Editor) Stage() *Editor {
	Stage.Editors[editor] = __member
	return editor
}

// Unstage removes editor off the model stage
func (editor *Editor) Unstage() *Editor {
	delete(Stage.Editors, editor)
	return editor
}

// commit editor to the back repo (if it is already staged)
func (editor *Editor) Commit() *Editor {
	if _, ok := Stage.Editors[editor]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitEditor(editor)
		}
	}
	return editor
}

// Checkout editor to the back repo (if it is already staged)
func (editor *Editor) Checkout() *Editor {
	if _, ok := Stage.Editors[editor]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutEditor(editor)
		}
	}
	return editor
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of editor to the model stage
func (editor *Editor) StageCopy() *Editor {
	_editor := new(Editor)
	*_editor = *editor
	_editor.Stage()
	return _editor
}

// StageAndCommit appends editor to the model stage and commit to the orm repo
func (editor *Editor) StageAndCommit() *Editor {
	editor.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMEditor(editor)
	}
	return editor
}

// DeleteStageAndCommit appends editor to the model stage and commit to the orm repo
func (editor *Editor) DeleteStageAndCommit() *Editor {
	editor.Unstage()
	DeleteORMEditor(editor)
	return editor
}

// StageCopyAndCommit appends a copy of editor to the model stage and commit to the orm repo
func (editor *Editor) StageCopyAndCommit() *Editor {
	_editor := new(Editor)
	*_editor = *editor
	_editor.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMEditor(editor)
	}
	return _editor
}

// CreateORMEditor enables dynamic staging of a Editor instance
func CreateORMEditor(editor *Editor) {
	editor.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMEditor(editor)
	}
}

// DeleteORMEditor enables dynamic staging of a Editor instance
func DeleteORMEditor(editor *Editor) {
	editor.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMEditor(editor)
	}
}

// swagger:ignore
type AllModelsStructCreateInterface interface { // insertion point for Callbacks on creation
	CreateORMArea(Area *Area)
	CreateORMBook(Book *Book)
	CreateORMEditor(Editor *Editor)
}

type AllModelsStructDeleteInterface interface { // insertion point for Callbacks on deletion
	DeleteORMArea(Area *Area)
	DeleteORMBook(Book *Book)
	DeleteORMEditor(Editor *Editor)
}

func (stage *StageStruct) Reset() { // insertion point for array reset
	stage.Areas = make(map[*Area]struct{}, 0)
	stage.Books = make(map[*Book]struct{}, 0)
	stage.Editors = make(map[*Editor]struct{}, 0)
}

func (stage *StageStruct) Nil() { // insertion point for array nil
	stage.Areas = nil
	stage.Books = nil
	stage.Editors = nil
}
